# 常用算法及其实现

## 本文结构

*	[概述](#overview)
*	[数组](#array)


<h2 id="overview">概述</h2>

不管你是刚毕业的小白还是工作三五年的老狗，数据结构和算法一般都是面试的重要关注点，老狗还需要关注专业技能和项目经验，这也是面试官考察的重点。

本文将总结面试中常考的数据结构、算法题，借鉴了《剑指 offer》、《算法导论公开课》、及 github 上 star 较多的算法仓库。

常用数据结构及算法列表如下：

1. 数组、字符串、链表（插入、删除）、栈、队列、哈希表、树（遍历、递归）、动态表、跳跃表、C++/java 容器特性及其底层实现；
2. 查找、排序（二分、归并、快排）、
3. 分治法、动态规划、贪婪算法；
4. 在正确的算法实现下，还要注意算法的鲁棒性（稳定性），关注特殊情况、特殊输入、边界条件等，不能让算法随意崩溃，有时候面试官就考这个。

<h2 id="array">数组</h2>

数组是最简单的数据结构之一，它占据一块连续的内存并按照顺序存储数据。**创建数组前需要先指定其容量大小**，由于代码里一般都是指定最大需要的容量大小，所以其空间不能被有效利用。

C++ 里一般使用 vector 来代替数组，其内存也是连续的，也能按照下标随机读写，其内部扩张策略是**动态表，即当容量不够时，重新分配一个当前容量的两倍的空间**，然后将旧数据复制到新空间中，如果其数据是类实例，那么会调用复制构造函数。vector 有专门的函数可以控制容量的大小（`shrink_to_fit`）。

数组的考察方式很简单，一般是求 sizeof 及 数组指针的特性（增减）等，推荐在牛客上练习相应的题目。

<h2 id="string">字符串</h2>

字符串也是连续存储的，C/C++ 中每个字符串都是以字符 '\0' 结尾，这个特性也是经常与数组结合起来考察 sizeof。

掌握 C 里面字符串的常用函数：printf,sprintf,strcpy,strcat,strcmp,memcpy,memmove 及其安全函数；

熟悉 C++ 里面 string 的添加(append)、查找(find) 函数。

字符串的考察方式很多，大多都是与算法结合一起考。

<h2 id="list">链表</h2>

链表是面试最为频繁的数据结构，链表在任意位置插入、删除都很快，但是其读写不太方便。

链表的考察方式一般是现场编写插入、删除、反转链表代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct ListNode
{
	int m_nValue;
	struct ListNode* m_pNext;
}ListNode;

void PrintList(const ListNode* pHead);
void AddToTail(ListNode** pHead, int value);
void RemoveNode(ListNode** pHead, int value);
void ReverseList(ListNode** pHead);

int main(void)
{
	ListNode* list = NULL;

	// 随机生成链表项
	srand((unsigned)time(NULL));
	for (int i = 0; i < 10; ++i)
	{
		AddToTail(&list, rand() % 10);
	}
	PrintList(list);

	// 删除链表项
	for (int i = 0; i < 5; ++i)
	{
		RemoveNode(&list, i);
	}
	PrintList(list);

	// 反转链表
	ReverseList(&list);
	PrintList(list);

	return 0;
}

void PrintList(const ListNode* pHead)
{
	while (pHead)
	{
		printf(" %d", pHead->m_nValue);
		pHead = pHead->m_pNext;
	}
	printf("\n");
}

void AddToTail(ListNode** pHead, int value)
{
	if (NULL == pHead)
	{
		return;
	}

	ListNode* tmp = (ListNode*)malloc(sizeof(ListNode));
	if (NULL == tmp)
	{
		printf("malloc error\n");
		return;
	}

	tmp->m_nValue = value;
	tmp->m_pNext = NULL;

	if (NULL == *pHead)
	{
		*pHead = tmp;
		return;
	}

	ListNode* pTail = *pHead;
	while (pTail->m_pNext)
	{
		pTail = pTail->m_pNext;
	}
	pTail->m_pNext = tmp;
}

void RemoveNode(ListNode** pHead, int value)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	while (curr)
	{
		if (curr->m_nValue == value)
		{
			if (NULL == pre)
			{
				*pHead = curr->m_pNext;
				free(curr);
				curr = *pHead;
			}
			else
			{
				pre->m_pNext = curr->m_pNext;
				free(curr);
				curr = pre->m_pNext;
			}
		}
		else
		{
			pre = curr;
			curr = curr->m_pNext;
		}
	}
}

void ReverseList(ListNode** pHead)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	ListNode* next = NULL;
	while (curr)
	{
		next = curr->m_pNext;
		if (NULL == next)
		{
			*pHead = curr;
		}

		curr->m_pNext = pre;
		pre = curr;
		curr = next;
	}
}
```

<h2 id="hash_table">哈希表</h2>

哈希表最大的好处是查找方便，可以使用数组实现最简单的哈希表。

当键的哈希值重复时，有两种常用策略来避免冲突，一种是以链表的形式链接起来，另一种就是递归哈希（该算法在算法导论中做过证明，再次冲突的概率很小），工程中一般使用链表来解决冲突。

哈希表的考察方式很多，大多是与算法结合一起考，如查找数组中和为某个数字的两个或多个数；也有直接让写哈希表的：



