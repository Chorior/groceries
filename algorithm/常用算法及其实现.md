# 常用算法及其实现

## 本文结构

*	[概述](#overview)
*	[数组](#array)


<h2 id="overview">概述</h2>

不管你是刚毕业的小白还是工作三五年的老狗，数据结构和算法一般都是面试的重要关注点，老狗还需要关注专业技能和项目经验，这也是面试官考察的重点。

本文将总结面试中常考的数据结构、算法题，借鉴了《剑指 offer》、《算法导论公开课》、及 github 上 star 较多的算法仓库。

常用数据结构及算法列表如下：

1. 数组、字符串、链表（插入、删除）、栈、队列、哈希表、树（遍历、递归）、动态表、跳跃表、C++/java 容器特性及其底层实现；
2. 查找、排序（二分、归并、快排）、
3. 分治法、动态规划、贪婪算法；
4. 在正确的算法实现下，还要注意算法的鲁棒性（稳定性），关注特殊情况、特殊输入、边界条件等，不能让算法随意崩溃，有时候面试官就考这个。

本文所有示例均在 windows7 visual studio 2015 上进行过实验，其他环境如有报错请自行修改。

<h2 id="array">数组</h2>

数组是最简单的数据结构之一，它占据一块连续的内存并按照顺序存储数据。**创建数组前需要先指定其容量大小**，由于代码里一般都是指定最大需要的容量大小，所以其空间不能被有效利用。

C++ 里一般使用 vector 来代替数组，其内存也是连续的，也能按照下标随机读写，其内部扩张策略是**动态表，即当容量不够时，重新分配一个当前容量的两倍的空间**，然后将旧数据复制到新空间中，如果其数据是类实例，那么会调用复制构造函数。vector 有专门的函数可以控制容量的大小（`shrink_to_fit`）。

数组的考察方式很简单，一般是求 sizeof 及 数组指针的特性（增减）等，推荐在牛客上练习相应的题目。

<h2 id="string">字符串</h2>

字符串也是连续存储的，C/C++ 中每个字符串都是以字符 '\0' 结尾，这个特性也是经常与数组结合起来考察 sizeof。

掌握 C 里面字符串的常用函数：printf,sprintf,strcpy,strcat,strcmp,memcpy,memmove 及其安全函数；

熟悉 C++ 里面 string 的添加(append)、查找(find) 函数。

字符串的考察方式很多，大多都是与算法结合一起考。

<h2 id="list">链表</h2>

链表是面试最为频繁的数据结构，链表在任意位置插入、删除都很快，但是其读写不太方便。

链表的考察方式一般是现场编写插入、删除、反转链表代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct ListNode
{
	int m_nValue;
	struct ListNode* m_pNext;
}ListNode;

void PrintList(const ListNode* pHead);
void AddToTail(ListNode** pHead, int value);
void RemoveNode(ListNode** pHead, int value);
void ReverseList(ListNode** pHead);

int main(void)
{
	ListNode* list = NULL;

	// 随机生成链表项
	srand((unsigned)time(NULL));
	for (int i = 0; i < 10; ++i)
	{
		AddToTail(&list, rand() % 10);
	}
	PrintList(list);

	// 删除链表项
	for (int i = 0; i < 5; ++i)
	{
		RemoveNode(&list, i);
	}
	PrintList(list);

	// 反转链表
	ReverseList(&list);
	PrintList(list);

	return 0;
}

void PrintList(const ListNode* pHead)
{
	while (pHead)
	{
		printf(" %d", pHead->m_nValue);
		pHead = pHead->m_pNext;
	}
	printf("\n");
}

void AddToTail(ListNode** pHead, int value)
{
	if (NULL == pHead)
	{
		return;
	}

	ListNode* tmp = (ListNode*)malloc(sizeof(ListNode));
	if (NULL == tmp)
	{
		printf("malloc error\n");
		return;
	}

	tmp->m_nValue = value;
	tmp->m_pNext = NULL;

	if (NULL == *pHead)
	{
		*pHead = tmp;
		return;
	}

	ListNode* pTail = *pHead;
	while (pTail->m_pNext)
	{
		pTail = pTail->m_pNext;
	}
	pTail->m_pNext = tmp;
}

void RemoveNode(ListNode** pHead, int value)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	while (curr)
	{
		if (curr->m_nValue == value)
		{
			if (NULL == pre)
			{
				*pHead = curr->m_pNext;
				free(curr);
				curr = *pHead;
			}
			else
			{
				pre->m_pNext = curr->m_pNext;
				free(curr);
				curr = pre->m_pNext;
			}
		}
		else
		{
			pre = curr;
			curr = curr->m_pNext;
		}
	}
}

void ReverseList(ListNode** pHead)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	ListNode* next = NULL;
	while (curr)
	{
		next = curr->m_pNext;
		if (NULL == next)
		{
			*pHead = curr;
		}

		curr->m_pNext = pre;
		pre = curr;
		curr = next;
	}
}
```

<h2 id="hash_table">哈希表</h2>

哈希表最大的好处是查找方便，可以使用数组实现最简单的哈希表。

当键的哈希值重复时，有两种常用策略来避免冲突，一种是以链表的形式链接起来，另一种就是递归哈希（该算法在算法导论中做过证明，再次冲突的概率很小），工程中一般使用链表来解决冲突。

哈希表的考察方式很多，大多是与算法结合一起考，如查找数组中和为某个数字的两个或多个数；也有直接让写哈希表的：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct ListNode
{
	int m_nValue;
	struct ListNode* m_pNext;
}ListNode;

void PrintList(const ListNode* pHead);
void AddToTail(ListNode** pHead, int value);
void RemoveNode(ListNode** pHead, int value);
void ReverseList(ListNode** pHead);
void DeleteList(ListNode** pHead);

typedef struct Hashmap
{
	ListNode** m_ppListNode;
	size_t m_uSize;
}Hashmap;

void CreateHashmap(Hashmap** ppHashmap, const unsigned size);
void DeleteHashmap(Hashmap** ppHashmap);
size_t GenHash(const size_t key, const size_t size);
void AddToHashmap(Hashmap* pHashmap, const int key, const int value);
void RemoveFromHashmap(Hashmap* pHashmap, const int key, const int value);
void PrintHashmap(const Hashmap* pHashmap);

int main(void)
{
	// 创建哈希表
	Hashmap* pHashmap = NULL;
	CreateHashmap(&pHashmap, 5);

	// 随机生成键值相同的键值对，并添加到哈希表中
	int tmp = 0;
	srand((unsigned)time(NULL));
	for (int i = 0; i < 20; ++i)
	{
		tmp = rand() % 20;
		AddToHashmap(pHashmap, tmp, tmp);
	}
	PrintHashmap(pHashmap);

	// 删除哈希项
	for (int i = 0; i < 5; ++i)
	{
		RemoveFromHashmap(pHashmap, i, i);
	}
	PrintHashmap(pHashmap);

	// 删除哈希表
	DeleteHashmap(&pHashmap);

	return 0;
}

void PrintList(const ListNode* pHead)
{
	while (pHead)
	{
		printf(" %d", pHead->m_nValue);
		pHead = pHead->m_pNext;
	}
	printf("\n");
}

void AddToTail(ListNode** pHead, int value)
{
	if (NULL == pHead)
	{
		return;
	}

	ListNode* tmp = (ListNode*)malloc(sizeof(ListNode));
	if (NULL == tmp)
	{
		printf("malloc error\n");
		return;
	}

	tmp->m_nValue = value;
	tmp->m_pNext = NULL;

	if (NULL == *pHead)
	{
		*pHead = tmp;
		return;
	}

	ListNode* pTail = *pHead;
	while (pTail->m_pNext)
	{
		pTail = pTail->m_pNext;
	}
	pTail->m_pNext = tmp;
}

void RemoveNode(ListNode** pHead, int value)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	while (curr)
	{
		if (curr->m_nValue == value)
		{
			if (NULL == pre)
			{
				*pHead = curr->m_pNext;
				free(curr);
				curr = *pHead;
			}
			else
			{
				pre->m_pNext = curr->m_pNext;
				free(curr);
				curr = pre->m_pNext;
			}
		}
		else
		{
			pre = curr;
			curr = curr->m_pNext;
		}
	}
}

void ReverseList(ListNode** pHead)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	ListNode* next = NULL;
	while (curr)
	{
		next = curr->m_pNext;
		if (NULL == next)
		{
			*pHead = curr;
		}

		curr->m_pNext = pre;
		pre = curr;
		curr = next;
	}
}

void DeleteList(ListNode** pHead)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* curr = *pHead;
	ListNode* next = NULL;
	while (curr)
	{
		next = curr->m_pNext;
		free(curr);
		curr = next;
	}
	*pHead = NULL;
}

void CreateHashmap(Hashmap** ppHashmap, const unsigned size)
{
	if (NULL == ppHashmap || 0 == size)
	{
		return;
	}

	Hashmap* pHashmap = (Hashmap*)malloc(sizeof(Hashmap));
	if (NULL == pHashmap)
	{
		printf("malloc error\n");
		return;
	}

	if (NULL != *ppHashmap)
	{
		DeleteHashmap(ppHashmap);
	}
	*ppHashmap = pHashmap;

	ListNode** ppListNode = (ListNode**)malloc(size * sizeof(ListNode*));
	if (NULL == ppListNode)
	{
		printf("malloc error\n");
		return;
	}

	for (size_t i = 0; i < size; ++i)
	{
		ppListNode[i] = NULL;
	}

	pHashmap->m_ppListNode = ppListNode;
	pHashmap->m_uSize = size;
}

void DeleteHashmap(Hashmap** ppHashmap)
{
	if (NULL == ppHashmap || NULL == *ppHashmap)
	{
		return;
	}

	Hashmap* pHashmap = *ppHashmap;
	if (NULL == pHashmap->m_ppListNode)
	{
		free(pHashmap);
		*ppHashmap = NULL;
		return;
	}

	ListNode** ppListNode = pHashmap->m_ppListNode;
	for (size_t i = 0; i < pHashmap->m_uSize; ++i)
	{
		DeleteList(ppListNode + i);
	}

	free(pHashmap);
	*ppHashmap = NULL;
}

size_t GenHash(const size_t key, const size_t size)
{
	return key%size;
}

void AddToHashmap(Hashmap* pHashmap, const int key, const int value)
{
	if (NULL == pHashmap || 0 == pHashmap->m_uSize)
	{
		return;
	}

	size_t index = GenHash(key, pHashmap->m_uSize);
	AddToTail(pHashmap->m_ppListNode + index, value);
}

void RemoveFromHashmap(Hashmap* pHashmap, const int key, const int value)
{
	if (NULL == pHashmap || 0 == pHashmap->m_uSize)
	{
		return;
	}

	size_t index = GenHash(key, pHashmap->m_uSize);
	RemoveNode(pHashmap->m_ppListNode + index, value);
}

void PrintHashmap(const Hashmap* pHashmap)
{
	if (NULL == pHashmap || NULL == pHashmap->m_ppListNode)
	{
		return;
	}

	for (size_t i = 0; i < pHashmap->m_uSize; ++i)
	{
		printf("%d:", i);
		PrintList((pHashmap->m_ppListNode)[i]);
	}
}
```

<h2 id="tree">树</h2>

树是一种在实际编程中经常遇到的数据结构，它的逻辑很简单：

1.	除了根节点外每个节点只有一个父节点，根节点没有父节点；
2.	除了叶节点之外，所有节点都有一个或多个子节点，叶节点没有子节点；
3.	父节点和子节点之间用指针链接。

有关树的考察方式一般有两种：

1.	某种树的特性，熟悉[各种树](https://www.cnblogs.com/maybe2030/p/4732377.html)；
2.	树的遍历--前序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根）
	1. 编程实现树的各种遍历；
	2. 前中后缀表达式转换--波兰表达式实现。


```C

```