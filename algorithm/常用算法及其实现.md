# 常用算法及其实现

## 本文结构

*	[概述](#overview)
*	[数组](#array)
*	[字符串](#string)
*	[链表](#list)
*	[哈希表](#hash_table)
*	[树](#tree)
*	[动态表](#dynamic_table)
*	[跳跃表](#skip_table)
*	[标准容器](#stl)
*	[查找](#search_algorithm)

<h2 id="overview">概述</h2>

不管你是刚毕业的小白还是工作三五年的老狗，数据结构和算法一般都是面试的重要关注点，老狗还需要关注专业技能和项目经验，这也是面试官考察的重点。

本文将总结面试中常考的数据结构、算法题，借鉴了《剑指 offer》、《算法导论公开课》、及 github 上 star 较多的算法仓库。

常用数据结构及算法列表如下：

1. 数组、字符串、链表（插入、删除）、栈、队列、哈希表、树（遍历、递归）、动态表、跳跃表、C++/java 容器特性及其底层实现；
2. 查找、排序（二分、归并、快排）、
3. 分治法、动态规划、贪婪算法；
4. 在正确的算法实现下，还要注意算法的鲁棒性（稳定性），关注特殊情况、特殊输入、边界条件等，不能让算法随意崩溃，有时候面试官就考这个。

本文所有示例均在 windows7 visual studio 2015 上进行过实验，其他环境如有报错请自行修改。

<h2 id="array">数组</h2>

数组是最简单的数据结构之一，它占据一块连续的内存并按照顺序存储数据。**创建数组前需要先指定其容量大小**，由于代码里一般都是指定最大需要的容量大小，所以其空间不能被有效利用。

C++ 里一般使用 vector 来代替数组，其内存也是连续的，也能按照下标随机读写，其内部扩张策略是**动态表，即当容量不够时，重新分配一个当前容量的两倍的空间**，然后将旧数据复制到新空间中，如果其数据是类实例，那么会调用复制构造函数。vector 有专门的函数可以控制容量的大小（`shrink_to_fit`）。

数组的考察方式很简单，一般是求 sizeof 及 数组指针的特性（增减）等，推荐在牛客上练习相应的题目。

<h2 id="string">字符串</h2>

字符串也是连续存储的，C/C++ 中每个字符串都是以字符 '\0' 结尾，这个特性也是经常与数组结合起来考察 sizeof。

掌握 C 里面字符串的常用函数：printf,sprintf,strcpy,strcat,strcmp,memcpy,memmove 及其安全函数；

熟悉 C++ 里面 string 的添加(append)、查找(find) 函数。

字符串的考察方式很多，大多都是与算法结合一起考。

<h2 id="list">链表</h2>

链表是面试最为频繁的数据结构，链表在任意位置插入、删除都很快，但是其读写不太方便。

链表的考察方式一般是现场编写插入、删除、反转链表代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct ListNode
{
	int m_nValue;
	struct ListNode* m_pNext;
}ListNode;

void PrintList(const ListNode* pHead);
void AddToTail(ListNode** pHead, int value);
void RemoveNode(ListNode** pHead, int value);
void ReverseList(ListNode** pHead);

int main(void)
{
	ListNode* list = NULL;

	// 随机生成链表项
	srand((unsigned)time(NULL));
	for (int i = 0; i < 10; ++i)
	{
		AddToTail(&list, rand() % 10);
	}
	PrintList(list);

	// 删除链表项
	for (int i = 0; i < 5; ++i)
	{
		RemoveNode(&list, i);
	}
	PrintList(list);

	// 反转链表
	ReverseList(&list);
	PrintList(list);

	return 0;
}

void PrintList(const ListNode* pHead)
{
	while (pHead)
	{
		printf(" %d", pHead->m_nValue);
		pHead = pHead->m_pNext;
	}
	printf("\n");
}

void AddToTail(ListNode** pHead, int value)
{
	if (NULL == pHead)
	{
		return;
	}

	ListNode* tmp = (ListNode*)malloc(sizeof(ListNode));
	if (NULL == tmp)
	{
		printf("malloc error\n");
		return;
	}

	tmp->m_nValue = value;
	tmp->m_pNext = NULL;

	if (NULL == *pHead)
	{
		*pHead = tmp;
		return;
	}

	ListNode* pTail = *pHead;
	while (pTail->m_pNext)
	{
		pTail = pTail->m_pNext;
	}
	pTail->m_pNext = tmp;
}

void RemoveNode(ListNode** pHead, int value)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	while (curr)
	{
		if (curr->m_nValue == value)
		{
			if (NULL == pre)
			{
				*pHead = curr->m_pNext;
				free(curr);
				curr = *pHead;
			}
			else
			{
				pre->m_pNext = curr->m_pNext;
				free(curr);
				curr = pre->m_pNext;
			}
		}
		else
		{
			pre = curr;
			curr = curr->m_pNext;
		}
	}
}

void ReverseList(ListNode** pHead)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	ListNode* next = NULL;
	while (curr)
	{
		next = curr->m_pNext;
		if (NULL == next)
		{
			*pHead = curr;
		}

		curr->m_pNext = pre;
		pre = curr;
		curr = next;
	}
}
```

<h2 id="hash_table">哈希表</h2>

哈希表最大的好处是查找方便，可以使用数组实现最简单的哈希表。

当键的哈希值重复时，有两种常用策略来避免冲突，一种是以链表的形式链接起来，另一种就是递归哈希（该算法在算法导论中做过证明，再次冲突的概率很小），工程中一般使用链表来解决冲突。

哈希表的考察方式很多，大多是与算法结合一起考，如查找数组中和为某个数字的两个或多个数；也有直接让写哈希表的：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct ListNode
{
	int m_nValue;
	struct ListNode* m_pNext;
}ListNode;

void PrintList(const ListNode* pHead);
void AddToTail(ListNode** pHead, int value);
void RemoveNode(ListNode** pHead, int value);
void ReverseList(ListNode** pHead);
void DeleteList(ListNode** pHead);

typedef struct Hashmap
{
	ListNode** m_ppListNode;
	size_t m_uSize;
}Hashmap;

void CreateHashmap(Hashmap** ppHashmap, const unsigned size);
void DeleteHashmap(Hashmap** ppHashmap);
size_t GenHash(const size_t key, const size_t size);
void AddToHashmap(Hashmap* pHashmap, const int key, const int value);
void RemoveFromHashmap(Hashmap* pHashmap, const int key, const int value);
void PrintHashmap(const Hashmap* pHashmap);

int main(void)
{
	// 创建哈希表
	Hashmap* pHashmap = NULL;
	CreateHashmap(&pHashmap, 5);

	// 随机生成键值相同的键值对，并添加到哈希表中
	int tmp = 0;
	srand((unsigned)time(NULL));
	for (int i = 0; i < 20; ++i)
	{
		tmp = rand() % 20;
		AddToHashmap(pHashmap, tmp, tmp);
	}
	PrintHashmap(pHashmap);

	// 删除哈希项
	for (int i = 0; i < 5; ++i)
	{
		RemoveFromHashmap(pHashmap, i, i);
	}
	PrintHashmap(pHashmap);

	// 删除哈希表
	DeleteHashmap(&pHashmap);

	return 0;
}

void PrintList(const ListNode* pHead)
{
	while (pHead)
	{
		printf(" %d", pHead->m_nValue);
		pHead = pHead->m_pNext;
	}
	printf("\n");
}

void AddToTail(ListNode** pHead, int value)
{
	if (NULL == pHead)
	{
		return;
	}

	ListNode* tmp = (ListNode*)malloc(sizeof(ListNode));
	if (NULL == tmp)
	{
		printf("malloc error\n");
		return;
	}

	tmp->m_nValue = value;
	tmp->m_pNext = NULL;

	if (NULL == *pHead)
	{
		*pHead = tmp;
		return;
	}

	ListNode* pTail = *pHead;
	while (pTail->m_pNext)
	{
		pTail = pTail->m_pNext;
	}
	pTail->m_pNext = tmp;
}

void RemoveNode(ListNode** pHead, int value)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	while (curr)
	{
		if (curr->m_nValue == value)
		{
			if (NULL == pre)
			{
				*pHead = curr->m_pNext;
				free(curr);
				curr = *pHead;
			}
			else
			{
				pre->m_pNext = curr->m_pNext;
				free(curr);
				curr = pre->m_pNext;
			}
		}
		else
		{
			pre = curr;
			curr = curr->m_pNext;
		}
	}
}

void ReverseList(ListNode** pHead)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* pre = NULL;
	ListNode* curr = *pHead;
	ListNode* next = NULL;
	while (curr)
	{
		next = curr->m_pNext;
		if (NULL == next)
		{
			*pHead = curr;
		}

		curr->m_pNext = pre;
		pre = curr;
		curr = next;
	}
}

void DeleteList(ListNode** pHead)
{
	if (NULL == pHead || NULL == *pHead)
	{
		return;
	}

	ListNode* curr = *pHead;
	ListNode* next = NULL;
	while (curr)
	{
		next = curr->m_pNext;
		free(curr);
		curr = next;
	}
	*pHead = NULL;
}

void CreateHashmap(Hashmap** ppHashmap, const unsigned size)
{
	if (NULL == ppHashmap || 0 == size)
	{
		return;
	}

	Hashmap* pHashmap = (Hashmap*)malloc(sizeof(Hashmap));
	if (NULL == pHashmap)
	{
		printf("malloc error\n");
		return;
	}

	ListNode** ppListNode = (ListNode**)malloc(size * sizeof(ListNode*));
	if (NULL == ppListNode)
	{
		printf("malloc error\n");
		free(pHashmap);
		return;
	}

	for (size_t i = 0; i < size; ++i)
	{
		ppListNode[i] = NULL;
	}

	pHashmap->m_ppListNode = ppListNode;
	pHashmap->m_uSize = size;
	*ppHashmap = pHashmap;
}

void DeleteHashmap(Hashmap** ppHashmap)
{
	if (NULL == ppHashmap || NULL == *ppHashmap)
	{
		return;
	}

	Hashmap* pHashmap = *ppHashmap;
	if (NULL == pHashmap->m_ppListNode)
	{
		free(pHashmap);
		*ppHashmap = NULL;
		return;
	}

	ListNode** ppListNode = pHashmap->m_ppListNode;
	for (size_t i = 0; i < pHashmap->m_uSize; ++i)
	{
		DeleteList(ppListNode + i);
	}

	free(pHashmap);
	*ppHashmap = NULL;
}

size_t GenHash(const size_t key, const size_t size)
{
	return key%size;
}

void AddToHashmap(Hashmap* pHashmap, const int key, const int value)
{
	if (NULL == pHashmap || 0 == pHashmap->m_uSize)
	{
		return;
	}

	size_t index = GenHash(key, pHashmap->m_uSize);
	AddToTail(pHashmap->m_ppListNode + index, value);
}

void RemoveFromHashmap(Hashmap* pHashmap, const int key, const int value)
{
	if (NULL == pHashmap || 0 == pHashmap->m_uSize)
	{
		return;
	}

	size_t index = GenHash(key, pHashmap->m_uSize);
	RemoveNode(pHashmap->m_ppListNode + index, value);
}

void PrintHashmap(const Hashmap* pHashmap)
{
	if (NULL == pHashmap || NULL == pHashmap->m_ppListNode)
	{
		return;
	}

	for (size_t i = 0; i < pHashmap->m_uSize; ++i)
	{
		printf("%d:", i);
		PrintList((pHashmap->m_ppListNode)[i]);
	}
}
```

<h2 id="tree">树</h2>

树是一种在实际编程中经常遇到的数据结构，它的逻辑很简单：

1.	除了根节点外每个节点只有一个父节点，根节点没有父节点；
2.	除了叶节点之外，所有节点都有一个或多个子节点，叶节点没有子节点；
3.	父节点和子节点之间用指针链接。

有关树的考察方式一般有两种：

1.	某种树的特性，熟悉[各种树](https://www.cnblogs.com/maybe2030/p/4732377.html)；
2.	树的遍历--前序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根）、层级遍历
	1. 编程实现树的各种遍历；
	2. 前中后缀表达式转换--波兰表达式实现。

下面实现二叉搜索树的插入、移除、删除、查找、获取树的高度、前中后序遍历、层级遍历：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#define MAX_NUM 11

typedef struct BSTree
{
	int m_nValue;
	int m_nCount; // 记录添加m_nValue的次数
	struct BSTree* m_pLeft;
	struct BSTree* m_pRight;
}BSTree;

void AddToBSTree(BSTree** ppBSTree, const int value);
void RemoveFromBSTree(BSTree** ppBSTree, const int value);
void DeleteBSTree(BSTree** ppBSTree);
const BSTree* SearchBSTree(const BSTree* pBSTree, const int value);
int GetHeight(const BSTree* pBSTree);

// 递归实现
void PreOrderPrint(const BSTree* pBSTree);
void InOrderPrint(const BSTree* pBSTree);
void PostOrderPrint(const BSTree* pBSTree);

// 循环实现
void PreOrderPrint2(const BSTree* pBSTree);
void InOrderPrint2(const BSTree* pBSTree);
void PostOrderPrint2(const BSTree* pBSTree);

// 层级遍历
void LevelPrint(const BSTree* pBSTree);

int main(void)
{
	// 创建BST
	BSTree* pBSTree = NULL;

	// 随机生成项，并添加到BST
	srand((unsigned)time(NULL));
	for (int i = 0; i < 20; ++i)
	{
		AddToBSTree(&pBSTree, rand() % MAX_NUM);
	}
	printf("height: %d\n", GetHeight(pBSTree));
	PreOrderPrint(pBSTree); printf("\n");
	PreOrderPrint2(pBSTree); printf("\n");
	InOrderPrint(pBSTree); printf("\n");// 检验BST的正确性
	InOrderPrint2(pBSTree); printf("\n");
	PostOrderPrint(pBSTree); printf("\n");
	PostOrderPrint2(pBSTree); printf("\n");
	LevelPrint(pBSTree); printf("\n");

	// 搜索树
	srand((unsigned)time(NULL)<<2);
	for (int i = 0; i < 5; ++i)
	{
		int tmp = rand() % MAX_NUM;
		if (SearchBSTree(pBSTree, tmp))
		{
			printf("%d: is in the BSTree\n", tmp);
		}
		else
		{
			printf("%d: is not in the BSTree\n", tmp);
		}
	}

	// 删除节点
	for (int i = 0; i < 10; ++i)
	{
		RemoveFromBSTree(&pBSTree, i);
	}
	printf("height: %d\n", GetHeight(pBSTree));
	PreOrderPrint(pBSTree); printf("\n");
	PreOrderPrint2(pBSTree); printf("\n");
	InOrderPrint(pBSTree); printf("\n");// 检验BST的正确性
	InOrderPrint2(pBSTree); printf("\n");
	PostOrderPrint(pBSTree); printf("\n");
	PostOrderPrint2(pBSTree); printf("\n");
	LevelPrint(pBSTree); printf("\n");

	// 删除BST
	DeleteBSTree(&pBSTree);

	return 0;
}

void DeleteBSTree(BSTree** ppBSTree)
{
	if (NULL == ppBSTree || NULL == *ppBSTree)
	{
		return;
	}

	BSTree* pBSTree = *ppBSTree;
	DeleteBSTree(&(pBSTree->m_pLeft));
	DeleteBSTree(&(pBSTree->m_pRight));
	free(pBSTree);
	*ppBSTree = NULL;
}

void AddToBSTree(BSTree** ppBSTree, const int value)
{
	if (NULL == ppBSTree)
	{
		return;
	}

	BSTree* pTmp = *ppBSTree;
	BSTree** ppPlaceToAdd = ppBSTree;
	while (pTmp)
	{
		if (value == pTmp->m_nValue)
		{
			++pTmp->m_nCount;
			return;
		}
		else if (value > pTmp->m_nValue)
		{
			ppPlaceToAdd = &(pTmp->m_pRight);
			pTmp = pTmp->m_pRight;
		}
		else
		{
			ppPlaceToAdd = &(pTmp->m_pLeft);
			pTmp = pTmp->m_pLeft;
		}
	}

	BSTree* pNode = (BSTree*)malloc(sizeof(BSTree));
	if (NULL == pNode)
	{
		printf("malloc error\n");
		return;
	}

	pNode->m_nCount = 1;
	pNode->m_nValue = value;
	pNode->m_pLeft = NULL;
	pNode->m_pRight = NULL;
	*ppPlaceToAdd = pNode;
}

void RemoveFromBSTree(BSTree** ppBSTree, const int value)
{
	if (NULL == ppBSTree || NULL == *ppBSTree)
	{
		return;
	}

	BSTree* pBSTree = *ppBSTree;
	BSTree** ppPlaceToRemove = ppBSTree;
	while (pBSTree)
	{
		if (value == pBSTree->m_nValue)
		{
			break;
		}
		else if (value < pBSTree->m_nValue)
		{
			ppPlaceToRemove = &(pBSTree->m_pLeft);
			pBSTree = pBSTree->m_pLeft;
		}
		else
		{
			ppPlaceToRemove = &(pBSTree->m_pRight);
			pBSTree = pBSTree->m_pRight;
		}
	}

	if (NULL == pBSTree)
	{
		return;
	}
	if (NULL == pBSTree->m_pLeft && NULL == pBSTree->m_pRight)
	{
		*ppPlaceToRemove = NULL;
		free(pBSTree);
	}
	else if (NULL == pBSTree->m_pLeft && NULL != pBSTree->m_pRight)
	{
		*ppPlaceToRemove = pBSTree->m_pRight;
		free(pBSTree);
	}
	else if (NULL != pBSTree->m_pLeft && NULL == pBSTree->m_pRight)
	{
		*ppPlaceToRemove = pBSTree->m_pLeft;
		free(pBSTree);
	}
	else
	{
		// 找到右子树最左边的节点
		BSTree* pFather = pBSTree;
		BSTree* pTmp = pBSTree->m_pRight;
		while (pTmp->m_pLeft)
		{
			pFather = pTmp;
			pTmp = pTmp->m_pLeft;
		}
		// 右子树没有左节点
		if (pTmp == pBSTree->m_pRight)
		{
			pFather->m_pRight = pTmp->m_pRight;
		}
		else
		{
			pFather->m_pLeft = pTmp->m_pRight;
		}
		pFather->m_nValue = pTmp->m_nValue;
		pFather->m_nCount = pTmp->m_nCount;
		free(pTmp);
	}
}

const BSTree* SearchBSTree(const BSTree* pBSTree, const int value)
{
	while (pBSTree)
	{
		if (value == pBSTree->m_nValue)
		{
			break;
		}
		else if (value < pBSTree->m_nValue)
		{
			pBSTree = pBSTree->m_pLeft;
		}
		else
		{
			pBSTree = pBSTree->m_pRight;
		}
	}
	return pBSTree;
}

// 这里用arr来保存已经查找过的节点的高度，可以用unordered_map来解决最大值限定问题
int GetHeightInner(const BSTree* pBSTree, int arr[])
{
	if (NULL == pBSTree || NULL == arr)
	{
		return 0;
	}

	if (arr[pBSTree->m_nValue] != 0)
	{
		return arr[pBSTree->m_nValue];
	}

	int left = GetHeightInner(pBSTree->m_pLeft, arr);
	int right = GetHeightInner(pBSTree->m_pRight, arr);
	int height = left > right ? left + 1 : right + 1;
	arr[pBSTree->m_nValue] = height;
	return height;
}

int GetHeight(const BSTree* pBSTree)
{
	int arr[MAX_NUM] = { 0 };
	return GetHeightInner(pBSTree, arr);
}

void PreOrderPrint(const BSTree* pBSTree)
{
	if (NULL == pBSTree)
	{
		return;
	}

	printf(" %d", pBSTree->m_nValue);
	PreOrderPrint(pBSTree->m_pLeft);
	PreOrderPrint(pBSTree->m_pRight);
}

void InOrderPrint(const BSTree* pBSTree)
{
	if (NULL == pBSTree)
	{
		return;
	}

	InOrderPrint(pBSTree->m_pLeft);
	printf(" %d", pBSTree->m_nValue);
	InOrderPrint(pBSTree->m_pRight);
}

void PostOrderPrint(const BSTree* pBSTree)
{
	if (NULL == pBSTree)
	{
		return;
	}

	PostOrderPrint(pBSTree->m_pLeft);
	PostOrderPrint(pBSTree->m_pRight);
	printf(" %d", pBSTree->m_nValue);
}

void LevelPrint(const BSTree* pBSTree)
{
	if (NULL == pBSTree)
	{
		return;
	}

	// 通过高度，得到最大节点数，便于保存所有节点信息
	// 可以使用queue代替
	int height = GetHeight(pBSTree);
	int maxNodeNum = (int)pow(2, height) - 1;
	const BSTree** levelNodeArr = (const BSTree**)malloc(maxNodeNum * sizeof(BSTree*));
	if (NULL == levelNodeArr)
	{
		printf("malloc error\n");
		return;
	}

	int i = 0, j = 0;
	for (i = 0; i < maxNodeNum; ++i)
	{
		levelNodeArr[i] = NULL;
	}
	levelNodeArr[0] = pBSTree;

	// 按层级将节点指针保存在数组中
	i = 0;
	while (j <= i && levelNodeArr[j])
	{
		if (NULL != levelNodeArr[j]->m_pLeft)
		{
			levelNodeArr[++i] = levelNodeArr[j]->m_pLeft;
		}
		if (NULL != levelNodeArr[j]->m_pRight)
		{
			levelNodeArr[++i] = levelNodeArr[j]->m_pRight;
		}
		++j;
	}

	// 按数组顺序打印节点
	for (i = 0; i < j; ++i)
	{
		printf(" %d", levelNodeArr[i]->m_nValue);
	}
	free((void*)levelNodeArr);
}

void PreOrderPrint2(const BSTree* pBSTree)
{
	if (NULL == pBSTree)
	{
		return;
	}

	// 通过高度，得到最大节点数，便于保存所有节点信息
	// 可以使用stack代替
	int height = GetHeight(pBSTree);
	int maxNodeNum = (int)pow(2, height) - 1;
	const BSTree** stack = (const BSTree**)malloc(maxNodeNum * sizeof(BSTree*));
	if (NULL == stack)
	{
		printf("malloc error\n");
		return;
	}

	int i = 0;
	for (i = 0; i < maxNodeNum; ++i)
	{
		stack[i] = NULL;
	}

	i = 0;
	while (i > 0 || pBSTree)
	{
		while (pBSTree)
		{
			printf(" %d", pBSTree->m_nValue);
			stack[i++] = pBSTree;
			pBSTree = pBSTree->m_pLeft;
		}
		pBSTree = stack[--i]->m_pRight;
	}
	free((void*)stack);
}

void InOrderPrint2(const BSTree* pBSTree)
{
	if (NULL == pBSTree)
	{
		return;
	}

	// 通过高度，得到最大节点数，便于保存所有节点信息
	// 可以使用stack代替
	int height = GetHeight(pBSTree);
	int maxNodeNum = (int)pow(2, height) - 1;
	const BSTree** stack = (const BSTree**)malloc(maxNodeNum * sizeof(BSTree*));
	if (NULL == stack)
	{
		printf("malloc error\n");
		return;
	}

	int i = 0;
	for (i = 0; i < maxNodeNum; ++i)
	{
		stack[i] = NULL;
	}

	i = 0;
	while (i > 0 || pBSTree)
	{
		while (pBSTree)
		{
			stack[i++] = pBSTree;
			pBSTree = pBSTree->m_pLeft;
		}
		pBSTree = stack[--i];
		printf(" %d", pBSTree->m_nValue);
		pBSTree = pBSTree->m_pRight;
	}
	free((void*)stack);
}

// 循环后序遍历很难，需要标志根节点被访问的次数，只有第二次访问时才能打印
void PostOrderPrint2(const BSTree* pBSTree)
{
	if (NULL == pBSTree)
	{
		return;
	}

	// 通过高度，得到最大节点数，便于保存所有节点信息
	// 可以使用stack代替
	int height = GetHeight(pBSTree);
	int maxNodeNum = (int)pow(2, height) - 1;
	const BSTree** NodeStack = (const BSTree**)malloc(maxNodeNum * sizeof(BSTree*));
	if (NULL == NodeStack)
	{
		printf("malloc error\n");
		return;
	}

	// 节点标志数组（栈）
	int* SymbolStack = (int*)malloc(maxNodeNum * sizeof(int));
	if (NULL == SymbolStack)
	{
		printf("malloc error\n");
		free((void*)NodeStack);
		return;
	}

	int i = 0;
	for (i = 0; i < maxNodeNum; ++i)
	{
		NodeStack[i] = NULL;
		SymbolStack[i] = 0;
	}

	i = 0;
	while (i > 0 || pBSTree)
	{
		// 压栈，第一次访问
		while (pBSTree)
		{
			NodeStack[i] = pBSTree;
			SymbolStack[i++] = 0;
			pBSTree = pBSTree->m_pLeft;
		}
		// 本次循环所有左节点进栈结束
		// 若栈顶元素只访问了一次，不弹出
		if (0 == SymbolStack[i - 1])
		{
			SymbolStack[i-1] = 1;
			pBSTree = NodeStack[i-1]->m_pRight;
		}
		// 第二次访问了，出栈打印
		else
		{
			printf(" %d", NodeStack[--i]->m_nValue);
		}
	}
	free((void*)NodeStack);
	free((void*)SymbolStack);
}
```

<h2 id="dynamic_table">动态表</h2>

动态表是一种动态扩增容量的算法，**每当容量不够用时，将容量扩增一倍**。该算法在能减小平均扩增的次数，如vector容器就是用的这种算法。

动态表没什么好考的，最近发现在获取用户输入的字符串时，可以使用这种算法：

```C
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define string char*

char* GetString();

int main(void)
{
	// 获取输入
	string str = GetString();
	if (NULL == str)
	{
		printf("GetString failed\n");
		return 1;
	}
	// 打印输出
	printf("%s\n", str);
	free(str);
	return 0;
}

char* GetString()
{
	char* pTmp = NULL;
	char* pStr = NULL;
	int c = 0;
	int n = 0;         // 当前字符数
	int capacity = 24; // 初始容量

	pStr = (char*)malloc(capacity * sizeof(char));
	if (NULL == pStr)
	{
		printf("malloc error\n");
		return NULL;
	}

	printf("input a string: \n");
	while ((c = getc(stdin)) != '\n' && c != EOF)
	{
		// 容量不足，1位留给尾字符
		if (n == capacity - 1)
		{
			capacity *= 2;
			pTmp = (char*)malloc(capacity * sizeof(char));
			if (NULL == pTmp)
			{
				// 将输入缓存清空，然后重试
				while ((c = getc(stdin)) != '\n' && c != EOF);
				printf("retry:\n");
				free(pStr);
				return GetString();
			}
			memcpy(pTmp, pStr, n);
			free(pStr);
			pStr = pTmp;
		}
		pStr[n++] = c;
	}

	// 优化，将内存最小化
	pTmp = (char*)malloc((n + 1) * sizeof(char));
	if (NULL != pTmp)
	{
		memcpy(pTmp, pStr, n);
		free(pStr);
		pStr = pTmp;
	}
	pStr[n] = '\0';
	return pStr;
}
```

<h2 id="skip_table">跳跃表</h2>

链表解决了数组长度有限的问题，但是查找链表需要O(n)的时间复杂度，对于大数据来说，这是不行的。跳跃表是一种查找**有序链表**的数据结构，它的算法复杂度是O(logn)。

有关跳跃表的原理和图示可以参考[跳跃表原理](https://www.cnblogs.com/thrillerz/p/4505550.html)。

跳跃表的考察方式是实现跳跃表的插入、删除、查找，其要点是**有序链表、节点有最大最小值**：

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>

typedef struct SkipListNode
{
	int m_nValue;
	struct SkipListNode* m_pNext;
	struct SkipListNode* m_pDown;
}SkipListNode;

typedef struct SkipList
{
	struct SkipListNode* m_pHead;
	int m_nLevel; // 层数
}SkipList;

// 初始化链表，该链表含有两个节点，一个最小值节点，一个最大值节点
void InitSkipListNode(SkipListNode** ppSkipListNode);
void CreateSkipList(SkipList** ppSkipList);
void DeleteSkipList(SkipList** ppSkipList);
void AddToSkipList(SkipList* pSkipList, const int value);
void RemoveFromSkipList(SkipList* pSkipList, const int value);
SkipListNode* SearchSkipList(const SkipList* pSkipList, const int value);
void PrintSkipList(const SkipList* pSkipList);

int main(void)
{
	SkipList* pSkipList = NULL;

	// 创建跳跃表
	CreateSkipList(&pSkipList);
	if (NULL == pSkipList)
	{
		printf("create skilplist failed\n");
		return 1;
	}

	// 添加节点
	srand((unsigned)time(NULL));
	for (int i = 0; i < 100; ++i)
	{
		AddToSkipList(pSkipList, rand() % 100);
	}
	printf("level: %d\n", pSkipList->m_nLevel);
	PrintSkipList(pSkipList);

	// 搜索节点
	for (int i = 0; i < 10; ++i)
	{
		if (SearchSkipList(pSkipList, i))
		{
			printf("%d: in the skiplist\n", i);
		}
		else
		{
			printf("%d: not in the skiplist\n", i);
		}
	}

	// 移除节点
	for (int i = 0; i < 10; ++i)
	{
		RemoveFromSkipList(pSkipList, i);
	}
	printf("level: %d\n", pSkipList->m_nLevel);
	PrintSkipList(pSkipList);

	// 删除跳跃表
	DeleteSkipList(&pSkipList);

	return 0;
}

void InitSkipListNode(SkipListNode** ppSkipListNode)
{
	if (NULL == ppSkipListNode)
	{
		return;
	}

	SkipListNode* pHead = (SkipListNode*)malloc(sizeof(SkipListNode));
	SkipListNode* pTail = (SkipListNode*)malloc(sizeof(SkipListNode));
	if (NULL == pHead || NULL == pTail)
	{
		return;
	}

	pHead->m_nValue = INT_MIN;
	pHead->m_pNext = pTail;
	pHead->m_pDown = NULL;
	pTail->m_nValue = INT_MAX;
	pTail->m_pNext = NULL;
	pTail->m_pDown = NULL;
	*ppSkipListNode = pHead;
}

void CreateSkipList(SkipList** ppSkipList)
{
	if (NULL == ppSkipList)
	{
		return;
	}

	SkipList* pSkipList = (SkipList*)malloc(sizeof(SkipList));
	if (NULL == pSkipList)
	{
		printf("malloc error\n");
		return;
	}

	pSkipList->m_nLevel = 1;
	InitSkipListNode(&(pSkipList->m_pHead));
	*ppSkipList = pSkipList;
}

void DeleteSkipList(SkipList** ppSkipList)
{
	if (NULL == ppSkipList || NULL == *ppSkipList)
	{
		return;
	}

	// 按层级从左到右删除节点
	SkipListNode* pHead = (*ppSkipList)->m_pHead;
	SkipListNode* pCurr = NULL;
	SkipListNode* pNext = NULL;
	while (pHead)
	{
		pCurr = pHead;
		pHead = pHead->m_pDown;
		while (pCurr)
		{
			pNext = pCurr->m_pNext;
			free(pCurr);
			pCurr = pNext;
		}
	}

	// 删除跳跃表
	free(*ppSkipList);
	*ppSkipList = NULL;
}

void AddToSkipList(SkipList* pSkipList, const int value)
{
	if (NULL == pSkipList)
	{
		return;
	}

	// 构造栈，保存插入位置前一个节点的指针
	SkipListNode** stack = (SkipListNode**)malloc(pSkipList->m_nLevel*sizeof(SkipListNode*));
	if (NULL == stack)
	{
		printf("malloc error\n");
		return;
	}
	
	// 查找插入位置
	int i = 0;
	SkipListNode* pCurr = pSkipList->m_pHead;
	while (pCurr)
	{
		if (value > pCurr->m_nValue)
		{
			stack[i] = pCurr;
			pCurr = pCurr->m_pNext;
		}
		else if (value < pCurr->m_nValue)
		{
			pCurr = stack[i++]->m_pDown;
		}
		else
		{
			free(stack);
			return;
		}
	}

	// 随机算法，决定插入该节点的层数
	int level = 1;
	while (rand() % 2)
	{
		++level;
	}

	// 添加节点
	SkipListNode* pSkipListNode1 = NULL;
	SkipListNode* pSkipListNode2 = NULL;
	for (int j = 0; i > 0 && j < pSkipList->m_nLevel && j < level; ++j)
	{
		pSkipListNode2 = (SkipListNode*)malloc(sizeof(SkipListNode));
		if (NULL == pSkipListNode2)
		{
			free(stack);
			return;
		}
		pCurr = stack[--i];
		pSkipListNode2->m_nValue = value;
		pSkipListNode2->m_pNext = pCurr->m_pNext;
		pSkipListNode2->m_pDown = pSkipListNode1;
		pSkipListNode1 = pSkipListNode2;
		pCurr->m_pNext = pSkipListNode2;
	}
	free(stack);

	// 添加层数
	for (int j = pSkipList->m_nLevel; j < level; ++j)
	{
		pSkipListNode2 = (SkipListNode*)malloc(sizeof(SkipListNode));
		if (NULL == pSkipListNode2)
		{
			return;
		}

		InitSkipListNode(&pCurr);
		pCurr->m_pDown = pSkipList->m_pHead;
		pSkipList->m_pHead = pCurr;
		pSkipList->m_nLevel = j + 1;
		pSkipListNode2->m_nValue = value;
		pSkipListNode2->m_pNext = pCurr->m_pNext;
		pSkipListNode2->m_pDown = pSkipListNode1;
		pSkipListNode1 = pSkipListNode2;
		pCurr->m_pNext = pSkipListNode2;
	}
}

void RemoveFromSkipList(SkipList* pSkipList, const int value)
{
	if (NULL == pSkipList || NULL == pSkipList->m_pHead || 1 > pSkipList->m_nLevel)
	{
		return;
	}

	// 不能删最值
	if (INT_MAX == value || INT_MIN == value)
	{
		return;
	}

	// 找到最高层需要删除的节点
	SkipListNode* pPre = pSkipList->m_pHead;
	SkipListNode* pRemoveNode = pPre->m_pNext;
	while (pRemoveNode)
	{
		if (value > pRemoveNode->m_nValue)
		{
			pPre = pRemoveNode;
			pRemoveNode = pRemoveNode->m_pNext;
		}
		else if (value < pRemoveNode->m_nValue)
		{
			pRemoveNode = pPre->m_pDown;
		}
		else
		{
			break;
		}
	}

	// 没找到
	if (NULL == pRemoveNode)
	{
		return;
	}

	// 删除节点
	SkipListNode* pNext = NULL;
	SkipListNode* pDown = NULL;
	while (pRemoveNode)
	{
		while (pPre->m_pNext->m_nValue < value)
		{
			pPre = pPre->m_pNext;
		}
		pPre->m_pNext = pRemoveNode->m_pNext;
		pPre = pPre->m_pDown;
		pRemoveNode = pRemoveNode->m_pDown;
	}

	// 删除空层
	while (pRemoveNode = pSkipList->m_pHead)
	{
		// 只有最值节点
		if (NULL != pRemoveNode->m_pNext->m_pNext)
		{
			break;
		}
		pSkipList->m_pHead = pRemoveNode->m_pDown;
		pSkipList->m_nLevel--;
		free(pRemoveNode->m_pNext);
		free(pRemoveNode);
	}
}

SkipListNode* SearchSkipList(const SkipList* pSkipList, const int value)
{
	if (NULL == pSkipList || NULL == pSkipList->m_pHead || pSkipList->m_nLevel < 1)
	{
		return NULL;
	}

	SkipListNode* pPre = pSkipList->m_pHead;
	SkipListNode* pCurr = pPre->m_pNext;
	while (pCurr)
	{
		if (value > pCurr->m_nValue)
		{
			pPre = pCurr;
			pCurr = pCurr->m_pNext;
		}
		else if (value < pCurr->m_nValue)
		{
			pCurr = pPre->m_pDown;
		}
		else
		{
			return pCurr;
		}
	}

	return NULL;
}

void PrintSkipList(const SkipList* pSkipList)
{
	if (NULL == pSkipList || NULL == pSkipList->m_pHead || pSkipList->m_nLevel < 1)
	{
		return;
	}

	SkipListNode* pHead = pSkipList->m_pHead;
	SkipListNode* pCurr = NULL;
	SkipListNode* pDown = NULL;
	while (pHead)
	{
		pCurr = pHead;
		pHead = pHead->m_pDown;
		while (pCurr)
		{
			printf(" %d", pCurr->m_nValue);
			pCurr = pCurr->m_pNext;
		}
		printf("\n");
	}
}
```

<h2 id="stl">标准容器</h2>

C++ 标准容器包含 vector,deque,list,forward_list,array,string,stack,queue,priority_queue,map,set,multimap,multiset,unordered_map,unordered_set,unordered_multimap,unordered_multiset 17种类型。

其考察方式一般是其特性和底层数据结构：

容器 | 特性 | 底层数据结构
--- | --- | ---
vector | 可变大小数组<br>元素保存在连续的内存空间中<br>支持快速随机访问<br>在尾部之外的位置插入或删除元素很慢 | 动态表
deque | 双端队列<br>支持快速随机访问<br>在头尾插入、删除元素很快 | 一个中央控制器和多个缓冲区，链表+数组
list | 在任何位置插入、删除都很快<br>额外内存较其他顺序容器开销很大 | 双向链表
forward_list | 在任何位置插入、删除都很快<br>额外内存较其他顺序容器开销很大 | 单向链表
array | 支持快速随机访问<br>不能添加或删除元素 | 静态数组
string | 元素保存在连续的内存空间中<br>支持快速随机访问<br>在尾部插入、删除元素很快<br>它有自己特有的相关函数，所以与vector分开 | 动态表
stack | 后进先出LIFO<br>不支持随机访问<br>只支持尾部插入、弹出 | 容器适配器<br>默认基于deque实现
queue | 先进先出FIFO<br>不支持随机访问<br>只支持返回首尾元素和删除首元素 | 容器适配器<br>默认基于deque实现
priority_queue | 先进先出FIFO<br>不支持随机访问<br>需要定义优先级函数<br>只支持返回最高优先级元素和删除首元素 | 容器适配器<br>默认基于vector+最大堆实现
map | 键值对<br>元素默认按关键字从小到大排列<br>支持下标 | 红黑树
set | 关键字即值<br>元素默认按关键字从小到大排列<br>不支持下标 | 红黑树
multimap | 关键字可重复出现的map | 红黑树
multiset | 关键字可重复出现的set | 红黑树
unordered_map | 无序<br>关键字不重复 | 哈希表
unordered_set | 无序<br>关键字不重复 | 哈希表
unordered_multimap | 无序<br>关键字可重复 | 哈希表
unordered_multiset | 无序<br>关键字可重复 | 哈希表

<h2 id="search_algorithm">查找</h2>

查找是面试考察的重点，对于常见的查找应信手拈来。

查找考察的方式有很多，下面举出3个例子：

1. 二分查找；
2. 查找数组中第K小的数和最小的K个数；
3. 把一个数组的最开始若干个数搬到数组的末尾，称为旋转。输入一个递增排序的数组的一个旋转，输出该数组中最小的元素。如输入{3,4,5,1,2}，输出1。

```C++
// 由于C++实现了诸多数据结构和算法，所以使用C++来实现算法会比较方便
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <algorithm>

#define MAX_NUM 33

using namespace std;

// 二分查找
int BinarySearch(const int arr[], const int n, const int value);

// 查找旋转数组中最小的元素的下标
int MinInRotateArray(const int arr[], const int n);

// 打印数组，便于观察
void PrintArray(const int arr[], const int n);

int main()
{
	// 创建随机数组
	cout << "random array: " << endl;
	int arr[MAX_NUM] = {};
	srand((unsigned)time(nullptr));
	for (int i = 0; i < MAX_NUM; ++i)
	{
		arr[i] = rand() % 100;
	}
	PrintArray(arr, MAX_NUM);

	// 查找数组中第K小的数，前K个最小数
	cout << "\nsearch kth num" << endl;
	int k = 0;
	int kth = -1;
	for (int i = 0; i < 3; ++i)
	{
		k = rand() % MAX_NUM + 1;
		// 该算法复杂度为0(N)，第K个数为第K小的数，前K个数为最小的K个数
		nth_element(begin(arr), begin(arr) + k - 1, end(arr));
		cout << k << "th: arr[" << k << "]=" << arr[k-1] << endl;
		PrintArray(arr, k);
	}

	// 二分查找
	cout << "\nbinary search" << endl;
	sort(begin(arr), end(arr));
	PrintArray(arr, MAX_NUM);
	int target = 0;
	int index = 0;
	for (int i = 0; i < 3; ++i)
	{
		target = rand() % 100;
		index = BinarySearch(arr, MAX_NUM, target);
		if (-1 != index)
		{
			cout << target << ": arr[" << index << "]" << endl;
		}
		else
		{
			cout << target << ": not found" << endl;
		}
	}

	// 查找旋转数组中最小的值
	cout << "\nsearch smallest num" << endl;
	int rotateArr[MAX_NUM] = {};
	for (int i = 0; i < 3; ++i)
	{
		k = rand() % MAX_NUM;
		for (int j = 0; j < MAX_NUM; ++j)
		{
			rotateArr[(j + k) % MAX_NUM] = arr[j];
		}
		index = MinInRotateArray(rotateArr, MAX_NUM);
		if (-1 != index)
		{
			cout << "arr[" << index << "]=" << rotateArr[index] << endl;
		}
	}

	return 0;
}

int BinarySearch(const int arr[], const int n, const int value)
{
	if (nullptr == arr || n < 0)
	{
		return -1;
	}

	int left = 0;
	int right = n-1;
	int mid = 0;
	while (left <= right)
	{
		mid = (left + right) / 2;
		if (value > arr[mid])
		{
			left = mid + 1;
		}
		else
		{
			right = mid - 1;
		}
	}
	return (value == arr[left]) ? left : -1;
}

// 线性搜索旋转数组中最小的值
int LinearSearch(const int arr[], const int n, const int left, const int right)
{
	if (nullptr == arr || n < 0 || left < 0 || right >= n || right < left)
	{
		return -1;
	}

	int i = 0;
	for (i = left + 1; i <= right; ++i)
	{
		if (arr[i] < arr[i - 1])
		{
			return i;
		}
	}
	return left;
}

int MinInRotateArray(const int arr[], const int n)
{
	if (nullptr == arr || n < 0)
	{
		return -1;
	}

	int left = 0;
	int right = n - 1;
	int mid = 0;
	while (left < right)
	{
		mid = (left + right) / 2;
		if (arr[left] < arr[mid])
		{
			left = mid;
		}
		else if (arr[left] > arr[mid])
		{
			right = mid;
		}
		else
		{
			return LinearSearch(arr, n, left, right);
		}
	}
	return left;
}

void PrintArray(const int arr[], const int n)
{
	if (nullptr == arr || n < 0)
	{
		return;
	}

	for (int i = 0; i < n; ++i)
	{
		cout << "(" << i << ")" << arr[i] << " ";
	}
	cout << endl;
}
```

<h2 id="sort_algorithm">排序</h2>

排序也是面试考察的重点之一，其考察方式一般是考察常用排序的优劣及其复杂度，并能够快速写出快排、归并排序：

算法 | 时间复杂度 | 空间复杂度 | 适用场景
--- | --- | --- | ---
插入排序 | O(n) ~ 0(n^2) | O(1) | 元素较少或大多数元素有序