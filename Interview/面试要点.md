# 面试要点

## 本文结构

*	[常识](#common_sense)
*	[面试流程](#interview_flow)
*	[简历](#resume)
*	[相关技术](#related_technology)
  *	[计算机网络](#computer_networks)
  *	[计算机系统](#computer_systems)
  *	[数据结构](#data_structures)
  *	[常用算法](#common_algorithms)
  *	[shell,bash](#shell_bash)
  *	[git,svn,sql](#git_svn_sql)
  *	[C,C++,Python](#c_python)
  *	[内存管理](#memory_management)
  *	[设计模式](#design_patterns)
  *	[并发编程](#concurrent_program)
*	[薪资谈判](#salary_negotiation)

<h2 id="common_sense">常识</h2>

**该文章为作者准备面试的一些笔记，如果有不对的地方或者和你想法不同的地方，欢迎指正**。

众所周知，**每年2\~4月份和7\~10月份是找工作的最佳时间**，跳槽就像期末考试一样，普通人临时抱佛脚总比裸考来的好点，如果提前一个月准备，也许还能跟学神考的差不多呢。

在你下决心准备跳槽之后，就应该时刻准备跳槽需要的东西，像一些社区不定时刊登的面试记录、常用面试技能等文章，即使你不仔细看，稍微扫一眼，觉得还行就应该收藏起来为跳槽做准备。

在工作中一些你觉得比较好用的技能、或者某个问题非常难解决但是最终解决了，你可以拿个本子记录下来，有时候面试官跟你唠嗑，也可以拿出来说说。

如果有熟悉的同事在某某你觉得还行的公司中有内部招聘信息，这比在求职网站乱投中标的概率要大得多。

IT面试大概需要准备三样东西：**简历、相关技术、薪资谈判**。它们权重的比例大概是1:3:1，所以接下来我们就从这三个方面开始准备。

<h2 id="interview_flow">面试流程</h2>

### 面试选拔

1. 资格审查--工作经历、经验、教育背景等；
2. 业务面试--过往承担的工作、责任与取得的成绩；专业知识；关键技能；
3. 综合面试--价值观、文化适应性；综合能力（洞察力、影响力、合作性、学习能力、开放性、成就导向、坚韧性等）；
4. 录用审核--审核流程规范性、审核 offer；
5. 录用决策--审核是否满足业务战略的诉求、人才对公司的价值、批准 offer、批准录入。

### 面试官的面试流程

#### 面试前规划

1. 阅读应聘者简历、职位申请表，熟悉公司招聘政策、岗位任职要求；理解面试环节的关键考察点；
2. 设计面试考察方式和问题提纲。

#### 面试实施

1. 开场导入，建立良好的面试氛围（暖场、介绍当前面试安排）；
2. 聚焦考察点，请应聘者通过实例（成功和失败的案例）描述自己的能力；
3. 对需要深入了解的信息，要进行追问，挖掘应聘者的真实情况；
4. 确认关键考察点是否全部落实、疑点是否澄清，友好的结束面试。

#### 面试后评估

1. 基于岗位要求、评估标准，客观、全面的评价应聘者（与共同面试的人员无关，因为有特定的评估标准，除非达到要求的人员过多）；
2. 评价意见要聚焦面试环节的考察要点，清晰说明面试结论及评论依据。

### 有效面试的技巧(STAR)

1. Situation 所参与、负责项目启动的背景，其中所涉及的人、以及应聘者角色。如：当时是在什么情况下接受的任务？在项目中承担什么样的责任？汇报关系是怎样的？
2. Task 项目的具体内容、性质、规模，与需求岗位技能要求的匹配度。如：接受的项目内容是什么？项目的规模、性质如何？技能与项目要求匹配度如何？
3. Action 项目实施的过程，是否遇到困难，心理活动如何。如：具体采用了哪些措施？是否遇到困难？如何解决困难？压力如何？
4. Result 项目的结果，应聘者的行为对结果的影响度，应聘者的总结思考。如：项目最终结果如何？对项目的贡献如何？收获是什么？改进点是什么？

### 常问问题

#### 业务问题

面试官：

1. 知识、技能、经验；
2. 亲身经历的项目，其背景、个人承担的任务（**突出个人**）、结果及其环境因素、个人因素；
  1. 你在该项目中碰到的最大的问题是什么？你是怎么解决的？
  2. 从这个项目中学到了什么？
  3. 什么时候会和其它团队成员（开发、测试、设计、项目经理等）有什么样的冲突，你们是怎么解决冲突的？

应聘者：

1. 工作岗位具体的职责和要求？
2. 工作最大的挑战是什么？
3. 面试一共有几轮？

#### 综合面试

面试官：

1. 为什么跳槽？（老板太抠、同事是傻逼、加班遭不住、工资太少，**严禁以上原因**）
2. 你的优缺点？能给工作带来什么影响？

应聘者：

1. 公司如何对人员进行培养和管理？
2. 公司如何对人员进行激励？

<h2 id="resume">简历</h2>

我们都知道，**面试官大多数时候提的问题都是与简历相关的**，所以你一定**要对简历上的所有技术相当熟悉，并且能够加以扩展**，下面是一些简历或面试技巧的相关链接：

* [优秀简历要遵循哪些规则](https://www.zhihu.com/question/20184884/answer/101058842)
* [什么样的简历不会被丢进回收站](https://juejin.im/post/5b7b66556fb9a01a0a4ead9c)
* [我总结出来的一些面试经验和套路](https://mp.weixin.qq.com/s?__biz=MzI3MzExOTEwOA==&mid=2649170103&idx=1&sn=7fcf31975c6d7d94bee43fcec77dcb21&chksm=f33ba25cc44c2b4a1bbdf8e5d2b24e8cc14a49b3d3d2a9c0ebe5c79f9176a70864b603c8f53e&scene=21#wechat_redirect)
* [可能是一份最适合你的后端面试指南](https://juejin.im/post/5ba591386fb9a05cd31eb85f)
* [我面试到底问什么](https://juejin.im/entry/575e2e95165abd005559b707)
* [面试应答有哪些话术和技巧](https://www.zhihu.com/question/35953016/answer/424927405)

总结下来大概有如下几点：

* 个人觉得[博客园](https://job.cnblogs.com/)的简历模板基本满足大多数文章对简历的要求了；
* **写在简历上的东西一定要慎重**；
* **对简历上的东西烂熟于心**；
* **项目经历不在于多，而在于有亮点**；
* **与职位无关的东西不要写在简历上**；
* 内容过多的话，不需要非把内容压缩到一页；
* **发邮件时准备word和PDF两种格式的简历**；
* 简历最后加上”感谢您花时间阅读我的简历，期待能有机会和您共事。"会显得有礼貌；
* 面试时将所有能看的证件复印件与简历一起用一个文件夹加在一起，会显得庄重。

<h2 id="related_technology">相关技术</h2>

根据不同职位的不同要求，需要的技术不甚相同，在准备的时候先要搞清楚自己的技术定位--开发、测试、后端、前端、语言等。

可以先去求职网站上看看，有哪些自己能够应聘的职位，这些职位有哪些要求，再针对性的进行相关准备。

作者是C/C++相关的后端开发工程师，现在需要的基础技能大概有：

* 计算机网络；
* 计算机系统；
* 数据结构；
* 常用算法；
* shell,bash
* git,svn,sql
* C,C++,Python

比较高级一点技能大概有：

* 内存管理；
* 设计模式；
* 并发编程；

有了上面这些技能，然后再去[leetcode](https://leetcode.com/problemset/algorithms/)刷刷算法题，应该差不多了。

<h3 id="computer_networks">计算机网络</h3>

#### 常问问题

##### 什么是 TCP/IP?简述 OSI 模型与 TCP/IP 模型的区别？

1.  TCP/IP 是供已连接 Internet 的计算机进行通信的协议族，如 TCP,UDP,ICMP,SMTP等；
2.  OSI 模型由应用层、表示层、会话层、传输层、网络层、数据链路层、物理层七层组成，而TCP/IP 模型由应用层、传输层、网络互连层、网络接入层四层组成；
3.  TCP/IP 模型中的应用层对应 OSI 模型中的应用层、表示层和会话层，传输层一致，网络互连层对应 OSI 模型中的网络层，网络接入层对应 OSI 模型中的数据链路层和物理层。

##### 简介 TCP 和 UDP 区别，他们位于哪一层？

TCP 和 UDO 位于 OSI 参考模型中的传输层，它们的区别如下：

1.  TCP 面向连接，UDP 面向无连接；
2.  TCP 是可靠的，UDP 是不可靠的；
3.  TCP 只能支持单播，而 UDP 还能支持广播、多播和任播；
4.  TCP 的数据是流模式的，而 UDP 的数据是数据报模式。

流模式：接收端可以控制一次接收数据的大小，因为是已连接的；

数据报模式：发送端写几次接收端就读几次，因为是无连接的。

##### TCP 如何保证可靠性？

TCP 通过差错控制、流量控制、拥塞控制三大特性来保证可靠性。

差错控制：

1.  数据校验和保证数据有效性；
2.  确认应答和超时重传保证数据的完整性。

流量控制：TCP 通过滑动窗口机制来实现流量控制，避免数据溢出丢失

1.  接收方向发送方发送自己能够接收的最大窗口大小；
2.  发送方根据接收方最大窗口值、已确认到达接收方的数据量大小、已发送的数据量大小来动态的设置当前能够发送的窗口大小。

拥塞控制：

1.  网络中的数据量过多会出现网络拥塞，以致数据丢失，所以需要控制发送方发送数据量的大小，该大小称为拥塞窗口；
2.  重用拥塞控制方法：慢开始（指数增大）、拥塞避免（加法增大）

流量控制与拥塞控制的区别：

1.  流量控制考虑接收方能够承受的最大数据量；
2.  拥塞控制考虑网络能够承受的最大数据量；
3.  发送窗口是接收窗口与拥塞窗口的最小值。

##### 描述 TCP 协议三次握手、四次释放的过程？为什么要进行三次握手、四次释放？

TCP的三次握手连接（为了防止延迟的重复数据包重新出现在不恰当的时刻）：

* 客户端发送一个SYN包给服务端作为建立连接的请求；
* 服务端发送回一个SYN包并带有ACK作为建立连接的请求（这里合并的原因是：捎带应答可以使收发的数据量减少）；
* 客户端发送回一个ACK确认连接。

TCP的四次握手释放连接：

* 客户端发送一个FIN包给服务端作为切断连接的请求；
* 服务端发送回一个ACK；
* 服务端继续发送回一个FIN包作为切断连接的请求（这里不与上一个ACK合并的原因是：有时候服务端还需要发送一些数据给客户端）；
* 客户端发送回一个ACK确认断开连接。

##### IPV4 和 IPV6 的区别？

1.  IPV4 长32比特，而 IPV6 长128比特，所以 IPV6 的地址空间比 IPV4 的大得多；
2.  IPV4 地址由网络地址和主机地址组成，而 IPV6 地址由前缀和接口 ID 组成；
3.  IPV4 每8位为一组，用十进制数表示，中间以小圆点隔开；而 IPV6 每16位为一组，用16进制表示，中间以冒号隔开；
4.  IPV6 每组开头的零可以省略，连续的一个或多个全零组可以用 “::” 表示，但双冒号只能出现一次，如 `1:123::ABCD:0:1`；
5.  IPV4 的环回地址是 `127.0.0.1`，而 IPV6 的环回地址是 `::1`；
6.  IPV6 即使没有配置 DHCP 也能制动分配 IP，实现即插即用；
6.  IPV4 使用 ARP 来获取目标节点的 MAC 地址，而 IPV6 使用 TCMPv6 来获取；
7.  IPV6 报文头的结构更加简化，使得路由器处理速度更快，提高了网络吞吐量、并缩短了延时；
8.  IPV6 新增了任意长度的扩展首部，比 IPV4 固定长度的可选项更加灵活；
8.  IPV6 内置 IPSec，会对 IP 数据包进行加密，更具安全性；
8.  IPV6 更好的支持移动特性，将不再需要归属代理服务器对数据进行转发；
8.  IPV6 新增流标签功能，能够支持优先级处理，更好的支持 QOS。

##### IPV6 如何自动分配 IP？

IPV6 根据是否配置 DHCP，分为有状态地址配置和无状态地址配置两种方式自动分配 IP。

有状态地址配置（DHCPv6）：由 DHCPv6 服务器分配 IP，可以更好的对 IP 地址进行管理；

无状态地址配置：

1.  主机发送路由器请求消息 RS；
2.  路由器回应路由器宣告消息 RA；
3.  主机通过 RA 消息获取 IPV6 前缀；
4.  主机将自己的 MAC 地址转换为接口 ID，与前缀相结合，形成 IPV6 地址。

##### 简要描述下 ARP 和 ICMPv6？

ARP：

1.  源节点发送 ARP 请求到同一个链路上的所有主机和路由器；
2.  接收到 ARP 请求的主机若发现 ARP 请求包中的目标 IP 地址与本地地址一致，就将自己的 MAC 地址通过 ARP 响应包返回到源主机。

ICMPv6：

1.  源节点发送邻居请求消息 NS 到一个组播地址（由前缀和接口 ID 的后24位组成）；
2.  接收到 NS 的主机若发现请求消息中的目标 IP 地址与本地地址一致，就将自己的 MAC 地址通过邻居宣告消息 NA 返回到源主机。

ARP 与 ICMPV6 的区别：ARP 请求会被发送到同一链路的所有主机和路由器，而 ICMPv6 不会，减轻了网络负担。

#####  MAC 地址与 IP 地址的区别？

1.  MAC 地址用于标识同一链路上不同的设备，而 IP 地址用于标识同一网络中互连的不同设备；
2.  IP 地址中的网络地址用于标识不同的网段，所以 IP 地址具有层次性；
3.  路由器根据网络地址和路由控制表进行路由，而网桥根据 MAC 地址进行数据的转发。

##### 中继器、交换机、路由器的工作原理大概是什么，位于哪一层？

1.  中继器位于物理层，对信号进行放大和发送，用于网络延长；
2.  交换机位于数据链路层，因为不同链路的帧格式不同，所以需要对数据帧进行重构，同时检查错误，并转发给下一个链路，错误的帧会被直接丢弃；
3.  路由器位于网络层，根据网络地址、路由控制协议进行路由，并转发数据包。

##### 运输层与网络层的区别？

传输层提供不同主机之上运行的进程之间的通信，而网络层提供不同主机之间的通信。

##### HTTP 请求中的 GET 和 POST 的区别，Session 和 Cookie 的区别？

1.  POST 在浏览器回退时会重新提交请求，而 GET 不会；
2.  GET 请求参数通过 URL 进行传递，而 POST 请求参数通过 Request Body 进行传递，所以 POST 更加安全；
3.  Session 和 Cookie 都是用来保存临时消息的，但 Session 位于服务器，而 Cookie 位于客户端。

##### 谈谈你对 HTTP 1.0,，1.1，2.0 和 HTTPS 的理解？

1.  HTTP 1.0 中每个命令和应答都会出发一次 TCP 连接的建立和断开，而 HTTP 1.1 和 2.0 允许一个 TCP 连接上发送多个命令和应答；
2.  HTTPS 是使用 TLS/SSL 对数据进行加密的 HTTP 通信，更具安全性。

#### 常用术语

设备 | 功能
---- | ----
网卡NIC(Network Interface Card) | 物理层，又称网络接口卡，用于计算机连接网络
中继器 | 物理层，用于网络延长，对减弱的信号进行放大和发送，无法改变传输速度；多个端口的中继器被称为集线器(Hub)
网桥（又称交换机） | 数据链路层，根据数据帧的内容，丢弃错误的数据帧或重构数据帧转发数据给相邻的其它网络，**网桥根据MAC地址进行处理**，具有网桥功能的集线器叫做交换集线器
路由器 | 网络层，连接两个网络、判断网络路径，并对分组报文进行转发，**路由器根据IP地址进行处理**
网关 | 负责将从传输层到应用层的数据进行转换和转发。传输网关可以通过转换协议来连接使用不同协议的主机；应用网关如邮件网关，可以通过转换数据格式以使手机能够接收到Internet的邮件。

简写 | 全拼 | 含义
---- | ---- | ----
ARPANET | Advanced Research Projects Agency Network | 采用分组交换连接的网络
ISP | Internet Service Provider | 网络服务提供者，如移动、电信
SNS | Social Network Service | 社交网络服务，如Facebook
PPP | Point-to-Point Protocol | 1对1连接计算机的协议
TCP | Transfer Control Protocol | 传输控制协议
UDP | User Datagram Protocol | 用户数据报协议
ICMP | Internet Control Messages Protocol | 网间控制报文协议，用于诊断网络健康，如ping,traceroute
HTTP | HyperText Transfer Protocol | 超文本传输协议，用于浏览器与服务器间的通信，80端口
SMTP | Simple Mail Transfer Protocol | 简单邮件传输协议，用于电子邮件的传输，25端口
FTP | File Transfer Protocol | 文件传输协议，该协议会建立两个TCP连接，一个用于控制连接（21端口），一个用于传输数据（**默认20端口**）
TELNET | TELetypewriter NETwork | 远程登录协议，不安全（数据未加密），23端口
SSH | Secure Shell | 远程登录协议，安全，22端口
SNMP | Simple Network Management Protocol | 简单网络管理协议
DNS | Domain Name System | 域名系统，用于将域名转换为IP地址
ACK | Positive Acknowledgement | 确认应答
NACK | Negative Acknowledgement | 否定确认应答
VPN | Virtual Private Network | 虚拟专用网络，根据不同方法对数据进行区分以形成一个封闭的私有网络，用于连接距离较远的地域
VLAN | Virtual Local Area Network | 虚拟局域网，一种使用软件来修改网络拓扑的技术，可以省去大量物理布线时间
DHCP | Dynamic Host Configuration Protocol | 动态主机配置协议，用于自动设置IP地址、同一管理IP地址分配
Firewalls | Firewalls | 防火墙，一种应用网关，只接收特定的数据包并转发，用于网络安全

#### OSI七层模型

##### 物理层

**将比特流转换为信号，通过调制解调技术加载到不同的传输介质上进行传输**。同一传输介质上的设备可以使用MAC地址进行识别。

##### 数据链路层

**比特流与数据帧之间的转换，通过差错控制和流量控制来提供可靠性**。

**数据链路是让互联计算机之间相互通信的一种协议，又指通信手段**，如以太网、无线局域网、蓝牙等，**不同链路的帧的格式不同**。

**不同数据链路的最大区别就是它们的最大传输单位（MTU: Maximum Transmission Unit）不同，所以在网络层需要对数据包进行分割或重组**。

MAC地址用于识别数据链路中互连的节点，其长48比特，第一位用于标识单播或多播（0或1），第二位用于标识全局或本地（0或1），第3-24位用于标识厂商，第25-48位用于标识对应厂商的产品。

**MAC地址和IP地址虽然都具有唯一性，但只有IP地址具有层次性**。

##### 网络层

**地址管理与路由选择，将源端数据发送到接收端**

**网络层与数据链路层的区别**：数据链路层是在互连同一种数据链路的节点之间进行包传递，而网络层可以跨越不同的数据链路。

**MAC地址用于识别同一链路上不同的计算机，而IP地址用于识别TCP/IP网络中互连的主机和路由器**。

###### IPV4

**IPV4长32比特，分为网络地址和主机地址两部分**。同一网段的主机拥有相同的网络地址、不同的主机地址。

IP地址最初以分类进行区别：

* A类地址：首位以0开头，前八位用作网络地址，后24位用作主机地址；
* B类地址：首位以10开头，前16位用作网络地址，后16位用作主机地址；
* C类地址：首位以110开头，前24位用作网络地址，后8位用作主机地址；
* D类地址：首位以1110开头，所有位都被用作网络地址，常用于多播。

**私有IP地址是一段保留的IP地址，只是使用在局域网中，在Internet上是不使用的**：

* 10.0.0.0-10.255.255.255
* 172.16.0.0—172.31.255.255
* 192.168.0.0-192.168.255.255

**当IP地址所有比特位为0时，表示对应的网络地址或IP地址不可获知**，**当主机比特位全为1时，表示这是一个广播地址**。

**子网掩码对应IP地址网络地址的部分全为1，对应主机地址的部分全为0**。

由于IP地址分类会造成地址分配不均衡的问题，后来采用任意长度分隔IP地址的网络地址和主机地址，这种方式叫做CIDR(Classless inter-Domain Routing)，无类型域间选路；

后来为了更加有效利用IP地址，又出现了VLSM(Variable Length Subnet Mask)，可变长子网掩码；

后来IP地址还是不够用了，又出现了NAT(Network Address Translation)，网络地址转换器，一种在本地网络使用私有地址，而在连接互联网时使用全局IP地址的技术。

**IP地址中的网络地址用于路由控制，路由器根据网络地址和路由控制表进行路由**。

###### IPV6

**IPV6长128比特，也分为网络地址与主机地址两部分**。

**IPV6与IPV4的主要区别**：

* **IPV6的地址长度更长，使得地址空间变得更大**；
* **IPV6包首部的结构更加简化，使得路由器处理数据更快，从而提高了吞吐量，并缩短了延时**；
* **IPV6新增了任意长度的扩展首部，比IPV4固定长度的可选项更加灵活**；
* **IPV6即使没有DHCP也能实现自动分配IP**；

###### ARP(Address Resolution Protocol)

以目标IP地址为线索，定位下一个应该接收数据包的网络设备对应的MAC地址；如果目标主机不在同一个链路上，则查找下一跳路由器的MAC地址。**只适用于IPV4，IPV6使用ICMPv6发送邻居探索消息**。

ARP的请求包会被同一个链路上的所有主机和路由器解析，若ARP请求包中的目标IP地址与本地地址一致，则该节点就将自己的MAC地址通过ARP响应包返回到ARP源主机。

###### NAT-PT NAPT-PT

在NAT私有地址转换为全局地址时，将IPV6的首部与IPV4首部互换的一种技术，用于IPV6主机与IPV4主机进行通信。

###### IP隧道

在网络层的首部后面继续追加网络层首部的通信方法叫做IP隧道，用于当两个IPV4(IPV6)网络必须经过一个IPV6(IPV4)网络才能进行通信的场景。

##### 传输层

**传输层提供不同主机之上运行的进程之间的通信，而网络层提供不同主机之间的通信**。

**传输层通过端口号来识别目标应用程序**。

TCP/IP或UDP/IP通过五个信息来识别一个通信：源IP地址、目标IP地址、协议号、源端口号、目标端口号，质押其中一项不相同，则不是同一个通信。

###### 传输方式分类

根据是否建立连接分类：

* **面向有连接型**：在发送数据前，需要在收发主机之间连接一条通信线路；
* **面向无连接型**：不要求建立和断开连接，发送端可以在任何时候自由发送数据，接收端也永远不知道会在何时从哪里收到数据。

根据连接方式分类：

* **电路交换**：交换机主要负责数据的中转处理。计算机首先被连接到交换机上，而交换机与交换机之间则由众多通信线路再继续连接。计算机在发送数据时，需要通过交换机与目标主机建立通信电路，之后一直使用这条电路直到连接断开为止。这个方法不能有效利用资源；
* **分组交换**：将计算机所有发送的数据分成多个数据包，按照一定的顺序分别发送，由于每个分组数据的首部写入了收发端的地址，所以多个用户可以使用同一条线路，使资源利用率最大化，但是当路由器的缓存饱和或溢出时，可能发生分组数据丢失、无法发送到对端的情况；
* **报文交换**：整个报文传递到临近节点，全部存储下来后在查找转发表，然后转发到下一个节点。

根据接收端数量分类：

* **单播**：将消息发送给特定的一台主机（**TCP只能支持点对点通信**）；
* **多播**：将消息发送给特定的一组主机；
* **广播**：将消息发送给与之连接的所有其它主机；
* **任播**：在特定的多台主机中选出一台作为接收端。

###### TCP与UDP

传输层最具代表性的协议是TCP和UDP。TCP是面向连接的、可靠的流协议；UDP是不具有可靠性的数据报协议，其常用于包总量较少的通信（DNS、SNMP等）、即时通信（音视频）、广播、多播等。

TCP与UDP的区别：

* TCP是面向连接的，而UDP是面向无连接的；
* TCP是可靠的（通过校验和、序列号、确认应答、重发控制、连接管理、窗口控制等实现），而UDP是不可靠的；
* TCP可以有丢包重发和对次序乱掉的分包进行顺序控制的功能，而UDP没有；

TCP的三次握手连接（为了防止延迟的重复数据包重新出现在不恰当的时刻）：

* 客户端发送一个SYN包给服务端作为建立连接的请求；
* 服务端发送回一个SYN包并带有ACK作为建立连接的请求（这里合并的原因是：捎带应答可以使收发的数据量减少）；
* 客户端发送回一个ACK确认连接。

TCP的四次握手释放连接：

* 客户端发送一个FIN包给服务端作为切断连接的请求；
* 服务端发送回一个ACK；
* 服务端继续发送回一个FIN包作为切断连接的请求（这里不与上一个ACK合并的原因是：有时候服务端还需要发送一些数据给客户端）；
* 客户端发送回一个ACK确认断开连接。

##### 会话层

**何时建立连接、断开连接、保持多久的连接、数据分割等数据传输相关的管理**。

##### 表示层

**设备固有数据格式和网络标准数据格式的转换**，接受不同表现形式的信息，如文字、图像、声音等。

##### 应用层

**针对特定应用的协议，如HTTP,SMTP,SSH,FTP等**。

###### HTTP

**HTTP1.0中每个命令和应答都会触发一次TCP连接的建立和断开，从HTTP1.1开始，允许一个TCP连接上发送多个命令和应答，提高效率**。

**HTTPS：使用TLS/SSL的HTTP通信，提高了安全性**。

HTTP常用返回码 | 含义
-------------- | -----------
200 | OK
400 | Bad Request
403 | Forbidden
404 | Not Found
405 | Method Not Allowed
409 | Conflict
500 | Internal Server Error

#### 网络安全

密码算法可以分为：

* **对称密钥算法：加密和解密使用同一个密钥**；
* **公开密钥算法：加密和解密使用不同的密钥，而且不能通过加密密钥推导出解密密钥**。

常用加密算法 | 算法分类 | 密钥长度 | 安全性
----------- | ------- | ------------ | -----
DES | 对称密钥 | 56 | 太脆弱
AES | 对称密钥 | 128-256 | 很强大
RSA | 公开密钥 | 至少1024 | 非常强大，但运算速度太慢，被广泛用于对称密钥的分发

<h3 id="computer_systems">计算机系统</h3>

计算机系统的硬件组成部分：**中央处理器、存储器、输入输出控制系统和各种外部设备**。

**操作系统内核是应用程序和硬件之间的媒介**，它提供三个基本的抽象：

* **文件是对 I/O 设备的抽象**；
* **虚拟内存是对主存和磁盘的抽象**；
* **进程是处理器、主存和 I/O 设备的抽象**。

**优化程序性能的基本策略**：

* **高级设计**--选择适当的算法和数据结构；
* **基本编码原则**--尽可能将计算移动到循环外；引入临时变量保存中间结果，只将结果存放在数组或全局变量中；多变量、展开循环、条件传送以利用硬件并发；
* **局部性**--空间局部性（引用存储位置相近的变量）、时间局部性（同一个变量在一段时间内被多次引用）。

**静态库与动态库的区别**：

* 将所有相关的目标模块打包成为一个单独的文件，称为静态库。静态库被链接时，应用程序会复制其需要的目标模块到其可执行文件中，所以**静态库的优点就是执行程序时不需要其存在，缺点就是每个可执行文件都包含相同的公共代码，造成磁盘空间浪费，并且修改代码时每次都需要全部重新编译，浪费时间**；
* 只包含一个目标模块，并且在应用程序运行时才被载入内存的库叫做动态库。动态库中的代码和数据被引用它的所有应用程序共享，即多个程序运行时，如果引用同一个动态库，那么内存中只需要一份该共享库的实例即可。所以动态库的优点是**减小了可执行文件的空间占用、修改目标模块代码时也不用全量编译、应用程序还能支持热更新；缺点就是运行程序时必需对应动态库的存在才能运行，当存在多个版本的相同动态库时可能会找错导致程序不可运行或运行出错**。

[软硬链接的异同](https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html)：

* 软链接以路径形式存在，类似于 windows 的快捷方式，但硬链接以文件别名形式存在、与源文件拥有相同的 inode；
* 软链接可以跨文件系统，硬链接只能在同一个文件系统中才能创建；
* 软链接可以对一个不存在的文件进行链接，硬链接不行；
* 软链接可以对目录进行链接，硬链接不可以；
* 不管软链接还是硬链接，都不会复制源文件。

**异常**：

* **中断**--来自处理器外部的 I/O 设备的信号，异步；
* **陷阱**--有意的异常，其最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用，同步（**用户程序必须通过系统调用接口间接地访问内核代码和数据**）；
* **故障**--由错误情况引起，当其发生时，处理器将控制程序转移给故障处理程序，根据故障是否能够被修复，要么重新执行错误指令要么终止程序，同步；
* **终止**--不可恢复的致命错误，交由终止处理程序执行abort终止程序，同步。

[字节序](https://songlee24.github.io/2015/05/02/endianess/)

[原码, 反码, 补码](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)

[ASCII 码表之大小写转换](https://blog.csdn.net/dd864140130/article/details/41578501)

[按位异或运算交换两个变量的值](https://blog.csdn.net/eastlhu/article/details/49865313)

[当表达式很容易计算时，使用条件传送](https://blog.csdn.net/nestler/article/details/37593519)

[数据对齐](https://github.com/Chorior/groceries/blob/master/C%2B%2B/read%20sizeof%20struct.md)

<h3 id="data_structures">数据结构</h3>

数组、栈、队列、链表、图、树、前缀树、哈希表

<h3 id="common_algorithms">常用算法</h3>

排序：选择、插入、希尔、归并、快速、堆等

查找：二分、二叉树、红黑二叉、散列表

图：路径搜索

字符串：字符串查找

动态规划：思想

<h3 id="shell_bash">shell,bash</h3>

[shell 常用技能](https://github.com/Chorior/groceries/blob/master/shell/shell%20%E5%B8%B8%E7%94%A8%E6%8A%80%E8%83%BD.md)

<h3 id="git_svn_sql">git,svn,sql</h3>

1.  [git](https://chorior.github.io/2019/02/16/git-work-flow/)
2.  [sql](https://www.w3cschool.cn/sql/8zragfoj.html)

<h3 id="c_python">C,C++,Python</h3>

1. [C++](https://chorior.github.io/tags/#C++)
2. [Python](https://chorior.github.io/2017/02/25/python-basis/)
3. [gdb](https://www.ibm.com/developerworks/cn/linux/sdk/gdb/index.html)

    * 调试现有进程：`gdb -p $pid`
    * 打断点：b
    * 下一步：n
    * 打印变量：p
    * 继续执行：c
    * 删除断点: d
    * 查看信息：info b,info t
    * 线程切换：`t $thread_num`
    * 调用栈：bt

**sizeof**:

* sizeof 是个运算符，不能重载；
* sizeof 结构体：数据对齐；
* sizeof 类：空类型为1，虚函数表占一个指针类型长度，其它函数不占空间。
* sizeof(NULL): 内部实现为整形或(void*)0，所以长度为4或指针长度。

**typedef 与 #define 的区别**：

* `typedef` 仅限于为类型定义符号名称，但 `#define` 不仅可以为类型定义别名，也能为数值定义别名；
* `typedef` 是由编译器执行解释的，`#define` 是由预编译器处理、进行简单的替换。

**vector 与 list 的区别**：

* vector 的内存空间是连续的，而 list 不是；
* vector 的尾后插入、删除很快，但 list 任意位置插入、删除都很快；
* vector 随机读写很方便，但 list 的随机读写不方便；
* vector 分配内存时，实际分配的大小一般要比需要的大小要大，这是为连续插入的场景做的优化；
* list 需要额外的内存空间存储指针。

**存储类型**：

* `auto`--自动变量，C/C++ 默认类型变量，拥有自动存储时期，即离开作用域会被释放内存；
* `register`--寄存器变量，存放在寄存器而非内存中，因此操作、访问比自动变量更快，但无法获取其地址，拥有自动存储时期；
* `static`--静态变量，具有静态存储时期的变量，只要程序在运行就不会释放其内存，不管其代码块是否运行；
* `extern`--外部变量，外部定义的变量。

**类型限定词**：

* `const`--常量限定词；
* `volatile`--该变量不可优化；
* `restrict`--只能用于指针，表示该指针是访问某个对象的唯一且初始的方式，目的是便于编译器做优化。

**cout 与 printf**:

* cout 有缓冲区，是实际向标准输出打印时才加锁；
* printf 无缓冲区，在对标准输出做任何处理前先加锁；
* 多线程环境下 cout 与 printf 不能混用。

**安全编码**：

* 机密性--确保数据不被非法访问与窃取；
* 完整性--确保数据是完整的、未被篡改的；
* 可用性--要求保护资源在需要时可访问；
* 程序在处理外部数据时必须经过严格的合法性校验，尽量减少代码的攻击面，通过防御性的编码策略来弥补潜在的编码人员的疏忽；
* 变量都需要进行初始化；
* 内存释放后不能再使用，最好置为空；
* 不能重复释放内存；
* 不对内容进行修改的指针型参数，需要指定为const；
* 谨慎使用不可重入函数；
* 检查入参时的空指针；
* 构造函数不能有任何可能失败的操作，因为构造函数中抛出异常将导致对象的析构函数不被执行；
* 使用文件前，需要将文件路径标准化并校验，防止路径中出现..，被黑客利用用于遍历目录；
* rand 是伪随机数，是可以被预测的，可以使用 Linux 的 /dev/random、Windows 的 CryptGenRandom 等；
* C++ 的 string 类不能用于保存敏感信息，因为数据赋值是重新分配内存，然后拷贝，对 string 类中数据的操作隐藏了内存重新分配的过程，所以无法显式清理历史内存（C++17有变化）；
* system 函数不安全，能够运行多个命令，execve 只能执行单个命令，可以防止命令注入；
* 在信号处理函数中，只能调用异步安全函数；
* 虚函数不要使用默认参数，因为虚函数为动态绑定，而默认参数是静态绑定，派生类不生效。

<h3 id="memory_management">内存管理</h3>

虚拟内存是对内存的一个抽象，其提供三个重要的功能：

1. 虚拟内存将主存看做是一个存储在磁盘上的地址空间的高速缓存，在主存中自动缓存最近使用的存放磁盘上的虚拟地址空间的内容。**虚拟内存缓存中的块叫做页**；
2. 虚拟内存为每个进程提供了一致的地址空间，从而简化了内存管理，进而又简化了链接、在进程间共享数据、进程的内存分配以及程序加载；
3. 虚拟内存通过在每条页表条目中加入保护位，保护了每个进程的地址空间不被其它进程破坏。

内存管理主要指业务模块内存的申请和释放管理，框架对操作系统提供的内存申请、释放接口进行封装、扩展，业务使用框架封装后的接口申请、释放内存，这样做的好处有：

* 框架可以有效了解和控制各个业务模块内存的使用情况，便于统一管理；
* 当业务模块出现踩踏、泄露等内存问题时，框架可以对这些问题进行有效的定位；
* 框架可以有效应对内存碎片化的问题；
* 当前业务模块使用的内存主要有三种类型--静态内存、格式化链、内存池。

动态分区配制策略：最先匹配，最佳匹配，最差匹配

1. 最先匹配：简单，在高地址空间有大块的空闲分区；分配大块时较慢。
2. 最佳匹配：大部分分配的尺寸较小时，效果很好，可减少外部碎片的大小；容易产生很多无用的小碎片
3. 最差匹配：中等大小的分配较多时，效果最好，容易破坏大的空闲分区，因此后续难以分配大的分区。

内部碎片：所需容量小于分配容量；
外部碎片：所需容量大于可用容量。

[C++内存池介绍与经典内存池的实现](https://blog.csdn.net/K346K346/article/details/49538975)

<h3 id="design_patterns">设计模式</h3>

[设计模式](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)

**设计原则（良好的 OO 设计具备可复用、可扩充、可维护三个特性）**：

* 找出应用中可能变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起；
* 针对接口编程，而不是针对实现编程；
* 多用组合，少用继承；
* 为了交互对象之间的松耦合而努力；
* 类应该对扩展开放，对修改关闭；
* 要依赖抽象，不要依赖具体类；
* 最少知识原则：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立；
* 别调用我们，我们会调用你；
* 一个类应该只有一个引起变化的原因。

常用考题：**单例模式的实现**。

<h3 id="concurrent_program">并发编程</h3>

**并发**：一个流在另一个流开始之后、结束之前开始，或者后一个流在前一个流开始之后、结束之前开始，则称这两个流互相并发；
**并行**：两个流并发的运行在不同的处理器或计算机上。

**程序是一堆代码和数据**，进程的经典定义就是**一个执行中程序的实例**。系统中每个程序都运行在某个进程的上下文中，**上下文是由程序正确运行所需的状态组成的，这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合**。

进程的三种状态：**运行、停止（挂起）、终止**。

三种构造并发程序的方法--进程（IPC）、I/O 多路复用（select,epoll）、线程（锁、信号量、原子操作、线程池、线程无关函数）。

**进程是操作系统进行资源分配和调度的一个独立单元，而线程只是CPU调度和分派的基本单位**。

**fork**: 新创建的子进程得到与父进程用户级虚拟地址空间相同的一份副本（非共享），包括代码、数据段、堆、共享库及用户栈，子进程还获得与父进程任何打开文件描述符相同的副本。**子进程与父进程最大的区别在于PID不同，fork返回零表示在子进程中**；
**execve**: execve加载并运行可执行目标文件，且带参数argv和环境变量envp，**execve调用一次并从不返回**。

**fork与execve的区别**：fork创建一个新的与父进程相同的子进程，该子进程与父进程运行相同的程序；execve不创建新进程，而是在当前进程的上下文中加载并运行一个新的程序。**fork和execve都会继承调用前已打开的所有文件描述符**。

[一个FORK的面试题](https://coolshell.cn/articles/7965.html)

**僵死进程**：一个终止了但是还未被回收的进程，**僵死进程虽然没有运行，但是仍然消耗系统的内存资源**。最简单的构造方式是使用fork产生一个很快终止的子进程，然后让父进程一直挂起，可以使用waitpid来等待子进程终止或停止。

Linux 下经常使用 select/epoll 来实现 I/O 多路复用，有关 [select 和 epoll](https://www.cnblogs.com/Anker/p/3265058.html) 的问题，面试大多数都会有涉及。

[unlink](https://www.cnblogs.com/jacklikedogs/p/4672650.html): 从文件系统中删除一个名字，若这个名字是指向这个文件的最后一个链接，并且没有进程处于打开这个文件的状态，则删除这个文件，释放这个文件占用的空间。

IPC(Interprocess Communication)，进程间通信，指的是所有允许进程和同一台主机上其它进程进行通信的技术，其中包含共享内存(shmget)、映射内存(mmap)、管道(pipe)、FIFO(mkfifo)、信号量(Semaphore)、文件锁(fcntl,flock)、套接字(socket)等方式(futex?)。

#### 共享内存

**共享内存在各种进程间通信方式中具有最高的效率**，因为系统内核没有对访问共享内存进行同步，所以必须提供自己的同步措施，常用方法是通过使用信号量进行同步。

一个进程如需使用这个共享内存块，则首先需要将它绑定到自己的地址空间中，这样会创建一个从进程本身虚拟地址到共享页面的映射关系，当对共享内存的使用结束之后，这个映射关系将被删除。当再也没有进程需要使用这个共享概念股内存块的时候，**必须有一个（且只能有一个）进程负责释放这个被共享的内存页面**。

进程通过调用shmget(shared memory get)来分配一个共享内存块；调用shmat(shared memory attach)来获取对一块共享内存的访问；调用shmdt(shared memory detach)来脱离对一块共享内存的访问；调用shmctl(shared memory control)来获取一块共享内存的相关信息，同时允许对该共享内存进行修改，如删除。

#### 映射内存

映射内存提供了一种使多个进程通过一个共享文件（与共享内存的区别）进行通信的机制。映射内存既可以用于进程间通信，也可以作为一种访问文件内容的简单方法。

**映射内存在一个文件和一块进程地址空间之间建立了联系**。Linux 将文件分割成内存分页大小的块并复制到虚拟内存中，因此进程可以在自己的地址空间中直接访问文件内容。这样，，进程就可以读取普通内存空间的方法来访问文件的内容，也可以通过写入内存地址来修改文件的内容，这是一种方便的访问文件的方法。

你可以将映射内存想象成这样的操作：分配一个足够容纳整个文件内容的缓存，将全部文件内容读入缓存，并且（当缓存内容被修改过后）最后将缓存写回文件。

两种映射内存的方式：

* 使用普通文件提供的内存映射--适用于任何进程之间，此时需要打开或创建一个文件，再调用 mmap：

  ```c
  fd = open(filename,flag,mode);
  if(fd<0) ...
  ptr=mmap(NULL, len, PROT_READ|PORT_WRITE, MAP_SHARED, fd, 0)；
  ```

* 使用特殊文件提供内名内存映射--适用于具有亲缘关系的进程之间。由于父子进程特殊的亲缘关系，在父进程中先调用mmap，再调用fork，那么子进程会继承父进程匿名映射后的地址空间，同样也继承mmap返回的地址，这样，父子进程就可以通过映射区域进行通信了。**对于具有亲缘关系的进程事项共享内存最好的方式应该是采用匿名内存映射的方式**。

在 mmap 中指定 MAP_PRIVATE 可以创建一个写时复制区域，所有对映射区域内存内容的修改都仅反映在当前程序的地址空间中，其它进程即使映射了同一个文件也不会看到这些变化。与普通情况下直接写入所有进程共享的页面中的行为不同，**指定 MAP_PRIVATE 进行映射的进程只将改变写入一份私有副本中，该进程随后执行的所有读写操作都针对这个副本进行**。

/dev/zero 将自己表现为一个无限长且内容全部为零的文件，对 /dev/zero 执行的写入操作将被丢弃，因此**由它映射的内存区域可以用作任何用途**，自定义的内存分配过程经常通过映射 /dev/zero 以获取整块经过初始化的内存。

#### 管道

一个管道实际上就是一个只存在于内存中的文件，对这个文件的操作要通过两个已经打开的文件进行，它们分别代表管道的两端。

##### 无名管道(pipe)

**主要用于父进程与子进程之间，或两个兄弟进程之间**。在 Linux 系统中可以通过系统调用建立起一个单向的通信管道，且这种关系只能由父进程来建立。因此，**每个管道都是单向的，当需要双向通信时，就需要建立起两个管道**。管道两端的进程均将管道看做一个文件，一个进程负责往管道中写内容，而另一个从管道中读取。这种传输遵循先入先出(fifo)规则。**管道的数据容量是有限的**，如果写入的进程写入数据的速度比读取进程消耗数据的速度更快，且管道无法容纳更多数据的时候，写入端的进程将被阻塞，直到管道中出现更多的空间为止。换言之，**管道可以自动同步两个进程**。

##### 命名管道(mkfifo)

命名管道是为了解决无名管道只能用于近亲进程之间通信的缺陷而设计的。**命名管道是建立在实际的磁盘介质或文件系统上有自己名字的文件，任何进程可以在任何时间通过文件名或路径名与该文件建立联系**。为了实现命名管道，引入了一种新的文件类型--FIFO文件。**实现一个命名管道实际上就是实现一个FIFO文件。命名管道一旦建立，之后它的读、写、关闭操作都与普通管道完全相同。虽然FIFO文件的inode在磁盘上，但是文件的数据还是存在于内存缓冲页面中，与普通管道相同**。

在向管道写入数据时，至少应该存在某个进程，其中管道读端没有被关闭，否则会出现错误--管道断裂，进程收到了SIGPIPE信号，默认动作是进程终止。

**当要写入的数据量大于PIPE_BUF时，Linux 将不再保证写入的原子性**。

#### 信号量

**信号与信号量是两个不同的东西**，信号是一个发送到进程的特殊信息，而信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待(P)和发送(V)操作。

**信号是一个发送到进程的特殊信息，信号机制是异步的。当一个进程接收到一个信号时，它会立刻处理这个信号，而不会等待当前函数甚至当前一行代码结束运行**。

当一个进程接收到信号，基于不同的处理方式，该进程可能执行几种不同操作中的一种。每个信号都有一个默认处理方式，当进程没有指定自己对于某个信号的处理方式时，将使用默认处理方式。对于多数种类的信号，程序都可以自由指定一个处理方式--程序可以选择忽略这个信号，或者调用一个特定的信号处理函数。当前程序会暂停当前的执行过程，同时开始执行信号处理函数，并且当信号处理函数返回之后再从被暂停出继续执行。

可以使用函数signal注册一个信号捕捉函数，sigaction时signal的扩展。

常用信号：SIGPIPE、SIGCHLD 常被设置为忽略，前者用于socket，后者用于子进程回收。

信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进程等待(P)和发送(V)操作：

* P(sv)--如果sv的值大于零，就给他减一；如果它的值为零，就挂起该进程的执行；
* V(sv)--如果有其它进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加一。

信号量有两种--Posix 信号量、System V 信号量。

##### Posix 信号量

无名信号量(sem_init)，可与 pipe 相类比，其值保存在内存中，可用于进程和线程同步；

有名信号量(sem_open)，可与 fifo 相类比，其值保存在文件中，可用于进程和线程同步。

##### System V 信号量

semget--创建爱你和打开信号量；

semop--设置信号量的值；

semctl--对信号量实行控制操作。

#### 消息队列

##### Posix 消息队列

mq_open,mq_send,mq_receive,mq_close

##### System V 消息队列

msgget,msgsnd,msgrcv,msgctl

[Concurrency In Action](https://chorior.github.io/tags/#thread)

[三个经典同步问题](https://songlee24.github.io/2015/04/30/linux-three-syn-problems/)

[关于 linux 进程间的 close-on-exec 机制](https://cloud.tencent.com/developer/article/1177094)

<h2 id="salary_negotiation">薪资谈判</h2>

[如何回答你的期望薪资是多少？](https://zhuanlan.zhihu.com/p/32698287)

[面试谈工资的时候，对方问你的期望薪资，如果反问对方「根据自己的能力能给多少」，合适吗](https://www.zhihu.com/question/20890139/answer/16526665)

**对于你不怎么想去的公司，就大胆的要**。

**对于你非常想去的公司，就结合市场价再加上你的期望，给个上限，但是千万不能太离谱**。
