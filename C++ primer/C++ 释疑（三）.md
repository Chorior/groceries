---
title:      "C++ 释疑（三）"
subtitle:   "拷贝控制、运算符重载与模板编程"
date:       2017-04-04 14:28:00 +0800
header-img: "img/sunset_beach.jpg"
tags:
    - C++
    - C++ primer
---

本文是我重温《C++ Primer 5》第三部分类设计者的工具时，摘录的一些要点，适合初级程序员食用。

#   本文结构

*   [拷贝控制](#copy_control)
	*	[拷贝构造函数](#copy_constructor)
	*	[拷贝赋值运算符](#copy_assignment_operator)
	*	[析构函数](#destructor)

<h2 id="copy_control">拷贝控制</h2>

拷贝控制操作包括：

*	拷贝构造函数
*	拷贝赋值运算符
*	移动构造函数
*	移动赋值运算符
*	异构函数

**如果一个类没有定义所有这些拷贝控制成员，编译器将自动为它定义缺失的操作，可以通过使用`=default`显式的使用合成的版本，也可以使用`=delete`来阻止生成相应函数**。

**只能对默认构造函数和拷贝控制操作使用`=default`，但`=delete`可以对除析构函数外的任意函数使用（`=delete`必须出现在函数第一次声明的时候）**。

**如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则合成的对应函数被定义为删除的**。

老式C++通过将拷贝构造函数和拷贝赋值运算符定义为private，且不定义它们来阻止拷贝。**声明但不定义一个成员函数是合法的**。

<h3 id="copy_constructor">拷贝构造函数</h3>

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外的参数都有默认值，则此构造函数是拷贝构造函数。

拷贝构造函数通常不应该是explicit的；编译器生成的合成拷贝构造函数会使用成员的拷贝构造函数从给定对象中依次将每个非static成员拷贝到正在创建的对象中（数组成员会逐元素拷贝）。

**如果类的某个成员的拷贝构造函数是删除的或不可访问的（如private），则合成的拷贝构造函数被定义为删除的**。

```c++
class FOO
{
public:
	FOO();            // 默认构造函数
	FOO(const FOO&);  // 拷贝构造函数
}
```

<h3 id="copy_assignment_operator">拷贝赋值运算符</h3>

标准库通常要求保存在容器中的类型要具有拷贝赋值运算符，且其返回值是左侧运算对象的引用。

编译器生成的合成拷贝赋值运算符会通过成员类型的拷贝赋值运算符将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，并且返回一个指向其左侧运算对象的引用。

**如果类的某个成员的拷贝赋值运算符是删除的或不可访问的（如private），或是类有一个const的或引用成员，则合成的拷贝赋值运算符被定义为删除的**。

**需要拷贝赋值运算符的类也需要拷贝构造函数，反之亦然**。

```c++
class FOO
{
public:
	FOO& operator=(const FOO&); // 拷贝赋值运算符
}
```

<h3 id="destructor">析构函数</h3>

析构函数**首先执行函数体**，然后通过成员自己的析构函数（内置类型什么也不做）销毁成员。成员按初始化顺序的逆序销毁。

析构函数名字由波浪号接类名构成，没有返回值，也不接受参数。一个类只会有一个析构函数。

当一个对象被销毁时，就会自动调用其析构函数。

**如果类的某个成员的析构函数是删除的或不可访问的（如private)，则合成的析构函数和拷贝构造函数被定义为删除的**。

```c++
class FOO
{
public:
	~FOO(); // 析构函数
}
```

**如果一个类需要定义析构函数，那么你需要删除或重定义拷贝构造函数和拷贝赋值运算符**，因为如果该类有一个指针成员，默认的拷贝构造函数和拷贝赋值运算符会直接拷贝该指针成员，当拷贝的对象被销毁时，原对象的指针成员也被销毁了

```c++
class FOO
{
private:
	int *pi;
public:
	FOO() : pi(nullptr) {}
	FOO(int *p) : pi(P) {}
	~FOO() { delete pi; } 
}

FOO func(FOO foo)
{
	FOO ret = foo;
	return ret;    // ret和foo中的pi都被delete了，返回的pi指向无效内存！
}
```