---
title:      "C++ 释疑（三）"
subtitle:   "拷贝控制、运算符重载与模板编程"
date:       2017-04-04 14:28:00 +0800
header-img: "img/sunset_beach.jpg"
tags:
    - C++
    - C++ primer
---

本文是我重温《C++ Primer 5》第三部分类设计者的工具时，摘录的一些要点，适合初级程序员食用。

#   本文结构

*   [拷贝控制](#copy_control)
	*	[拷贝构造函数](#copy_constructor)
	*	[拷贝赋值运算符](#copy_assignment_operator)
	*	[析构函数](#destructor)
	*	[右值引用](#rvalue_reference)
	*	[移动操作](#move_operation)
	*	[swap 操作](#swap_operation)
	*	[移动和拷贝重载、引用限定符](#move_copy_override_and_ref_qualifier)
*	[重载运算与类型转换](#operator_override)

<h2 id="copy_control">拷贝控制</h2>

拷贝控制操作包括：

*	拷贝构造函数
*	拷贝赋值运算符
*	移动构造函数
*	移动赋值运算符
*	析构函数

**如果一个类没有定义所有这些拷贝控制成员，编译器将自动为它定义缺失的操作，可以通过使用`=default`显式的使用合成的版本，也可以使用`=delete`来阻止生成相应函数**。

**只能对默认构造函数和拷贝控制操作使用`=default`，但`=delete`可以对除析构函数外的任意函数使用（`=delete`必须出现在函数第一次声明的时候）**。

**如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的合成函数被定义为删除的**。

老式C++通过将拷贝构造函数和拷贝赋值运算符定义为private，且不定义它们来阻止拷贝。**声明但不定义一个成员函数是合法的**。

*	**使用等号定义变量**时，如果右侧对象是右值引用，那么会使用移动构造函数，否则使用拷贝构造函数；
*	**将一个对象作为实参传递给一个非引用类型的形参**时，如果对象是右值引用，那么会使用移动构造函数，否则使用拷贝构造函数；
*	**从一个返回类型为非引用类型的函数返回一个对象**时，如果对象是右值引用，那么会使用移动构造函数，否则使用拷贝构造函数；
*	**用花括号列表初始化一个数组中的元素或一个聚合类中的成员**时，如果列表值是右值引用，那么会使用移动构造函数，否则使用拷贝构造函数；

**通常一个类时不需要移动操作和拷贝操作的**，可以通过继承如下类或[noncopyable.hpp](http://www.boost.org/doc/libs/1_63_0/boost/core/noncopyable.hpp)来达到这个需求

```c++
class noncopyable
{
protected:
	noncopyable() = default;   // 默认构造函数不可访问
	~noncopyable() = default;  // 析构函数不可访问，移动构造函数被定义为删除的

	noncopyable(const noncopyable&) = delete;
	noncopyable& operator=(const noncopyable&) = delete;
};
```

<h3 id="copy_constructor">拷贝构造函数</h3>

**如果一个构造函数的第一个参数是自身类类型的左值引用，且任何额外的参数都有默认值，则此构造函数是拷贝构造函数**。

**拷贝构造函数通常不应该是explicit的**；编译器生成的合成拷贝构造函数会使用成员的拷贝构造函数从给定对象中依次将每个非static成员拷贝到正在创建的对象中（数组成员会逐元素拷贝）。

**如果类的某个成员的拷贝构造函数是删除的或不可访问的（如private），则合成的拷贝构造函数被定义为删除的**。

```c++
class FOO
{
public:
	FOO();            // 默认构造函数
	FOO(const FOO&);  // 拷贝构造函数
}
```

<h3 id="copy_assignment_operator">拷贝赋值运算符</h3>

标准库通常要求保存在容器中的类型要具有拷贝赋值运算符，且其返回值是左侧运算对象的引用。

编译器生成的合成拷贝赋值运算符会通过成员类型的拷贝赋值运算符将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，并且返回一个指向其左侧运算对象的引用。

**如果类的某个成员的拷贝赋值运算符是删除的或不可访问的（如private），或是类有一个const的或引用成员，则合成的拷贝赋值运算符被定义为删除的**。

**需要拷贝赋值运算符的类也需要拷贝构造函数，反之亦然**。

**通过先拷贝右侧运算对象，可以处理自赋值情况，且能在异常发生时将左侧运算对象置于一个有意义的状态**。

```c++
class FOO
{
public:
	FOO& operator=(const FOO&); // 拷贝赋值运算符
	FOO& operator=(const FOO);  // 异常安全，且能正确处理自赋值
}
```

<h3 id="destructor">析构函数</h3>

析构函数**首先执行函数体**，然后通过成员自己的析构函数（内置类型什么也不做）销毁成员。成员按初始化顺序的逆序销毁。

析构函数名字由波浪号接类名构成，没有返回值，也不接受参数。一个类只会有一个析构函数。

当一个对象被销毁时，就会自动调用其析构函数。

**如果类的某个成员的析构函数是删除的或不可访问的（如private)，则合成的析构函数和拷贝构造函数被定义为删除的**。

```c++
class FOO
{
public:
	~FOO(); // 析构函数
}
```

**如果一个类需要定义析构函数，那么你需要删除或重定义拷贝构造函数和拷贝赋值运算符**，因为如果该类有一个指针成员，默认的拷贝构造函数和拷贝赋值运算符会直接拷贝该指针成员，当拷贝的对象被销毁时，原对象的指针成员也被销毁了

```c++
class FOO
{
private:
	int *pi;
public:
	FOO() : pi(nullptr) {}
	FOO(int *p) : pi(P) {}
	~FOO() { delete pi; } 
}

FOO func(FOO foo)
{
	FOO ret = foo;
	return ret;    // ret和foo中的pi都被delete了，返回的pi指向无效内存！
}
```

<h3 id="rvalue_reference">右值引用</h3>

`std::move`定义于头文件`<utility>`中。

必须绑定到右值的引用，称为右值引用。

*	使用`&&`来获得右值引用；
*	**右值引用只能绑定到一个即将销毁的对象**；
*	不能将右值引用绑定到一个左值上；
*	字面常量是右值，可以绑定到右值引用；
*	不能将一个右值引用绑定到一个右值引用类型的变量上；
*	可以使用`std::move`来显式的将一个左值转换为相应的右值引用，但**移后源对象只能进行赋值和销毁操作**。

<h3 id="move_operation">移动操作</h3>

**当对象在拷贝后就立即被销毁时，使用移动而非拷贝会大幅度提升性能**。

**标准库容器、string、`shared_ptr`既支持移动也支持拷贝；IO 类和`unique_ptr`只支持移动**。

**如果一个构造函数的第一个参数是自身类类型的右值引用，且任何额外的参数都有默认值，则此构造函数是移动构造函数**。

**一旦资源完成移动，源对象必须不再指向被移动的资源，且销毁源对象时无害的（通常将指针赋值为nullptr来实现）**。

移动操作通常不会抛出任何异常，因为它不分配任何资源，所以移动构造函数和移动赋值运算符通常标记为`noexcept`。

*	`noexcept`出现在参数列表和初始化列表开始的冒号之间；
*	声明和定义都需要指定`noexcept`。

```c++
class FOO
{
	FOO(FOO &&) noexcept;            // 移动构造函数
	FOO& operator=(FOO &&) noexcept; // 移动赋值运算符，需要考虑自赋值
}
```

*	如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了，**此时对应的移动操作会被转换为相应的拷贝操作**；
*	**只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值（内置类型可以移动）时，编译器才会合成移动构造函数或移动赋值运算符**；
*	**定义了移动构造函数或移动赋值运算符的类也必须定义自己的拷贝操作，否则拷贝操作默认被定义为删除的**。

<h3 id="swap_operation">swap 操作</h3>

如果一个类需要与重排元素顺序的算法一起使用，因为这类算法会在交换两个元素时调用`swap`，若该类自定义了自己的swap，那么算法将使用类自定义版本，否则使用`std::swap`。

```c++
template<class _Ty,
	class> inline
	void swap(_Ty& _Left, _Ty& _Right)
		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
			&& is_nothrow_move_assignable<_Ty>::value)
	{	// exchange values stored at _Left and _Right
	_Ty _Tmp = _STD move(_Left);
	_Left = _STD move(_Right);
	_Right = _STD move(_Tmp);
	}
```

如果成员m有自定义的swap函数，那么使用方式是

```c++
using std::swap;
swap(m, other.m);
```

因为对于一个调用，**如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本**。

<h3 id="move_copy_override_and_ref_qualifier">移动和拷贝重载、引用限定符</h3>

区分移动和拷贝的重载函数通常有一个版本接受一个`const T&`，而另一个版本接受一个`T&&`。

```c++
void example(const int&); // 拷贝元素
void example(int&&);      // 移动元素
```

引用限定符类似const限定符，分为`&`和`&&`，分别指出this可以指向一个左值或右值

*	引用限定符只能用于非static成员函数，因为static成员函数没有this指针；
*	引用限定符必须同时出现在函数的声明与定义之中；
*	`&`限定的函数只能用于左值；
*	`&&`限定的函数只能用于右值；
*	引用限定符和const限定符一起使用时，引用限定符必须跟随在const限定符之后；
*	**如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符**；
*	**没什么特别要求的话，不要使用引用限定符**。

```c++
FOO &retFOO(); // 返回一个引用，retFOO调用是一个左值
FOO retVal();  // 返回一个值，retval调用是一个右值
FOO i, j;      // i, j是左值
i = j;         // 正确
retFOO() = j;  // 正确
retVal() = j;  // 错误，retval()返回一个右值
i = retVal();  // 正确
```

<h2 id="operator_override">重载运算与类型转换</h2>

当运算符作用于类类型的运算对象时，可以通过运算符重载定义该运算符的含义。

*	**重载运算符的优先级和结合律与内置运算符保持一致**；
*	重载运算符函数的名字由关键字operator和其后要定义的运算符号共同组成；
*	重载运算符函数也包含返回类型、参数列表以及函数体；
*	**对于一个重载的运算符函数，它要么是类的成员，要么至少含有一个类类型的参数**；
*	**重载运算符函数的参数数量与该运算符作用的运算对象数量一样多，但对于成员重载运算符函数，左侧运算对象绑定到隐式的this指针，所以成员运算符函数的显式参数数量比运算符的运算对象总数少一个**；
*	**对于成员重载运算符，左侧运算对象必须是所属类的一个对象**；
*	**对于二元运算符，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数**；
*	**除重载的函数调用运算符`operator()`外，其它重载运算符均不能含有默认实参**。

可以被重载的运算符

```text
+ 		-		*		/		%		^
&		|		~		!		,		=
<		>		<=		>=		++		--
<<		>>		==		!=		&&		||
+=		-=		/=		%=		^=		&=
|=		*=		<<=		>>=		[]		()
->		->*		new		new[]		delete		delete[]
```

不能被重载的运算符

```c++
::		.*		.		?:
```

运算符重载抉择：

*	**如果需要定义`operator==`，那么通常也应该定义`operator!=`**；
*	**如果需要定义`operator<`，那么通常也应该包含`>`、`>=`、`<=`操作**；
*	**如果需要定义算数运算符或位运算符，那么最好也定义复合赋值运算符**；
*	**逻辑运算符和关系运算符应该返回bool**；
*	**算数运算符（如+）应该返回一个类类型的值**；
*	**赋值运算符和复合赋值运算符（如+=）应该返回左侧运算对象的一个引用**；
*	**赋值(=)、下标([])、调用(())、成员访问箭头(->)必须定义为成员函数**；
*	**输入输出运算符必须是非成员函数，因为左侧运算符对象是一个iostream对象而非类对象**。

```c++
bool operator==(const CLASS_NAME &a, const CLASS_NAME &b);
// == 和 != 实际只有一个在工作
bool operator!=(const CLASS_NAME &a, const CLASS_NAME &b) { return !(a == b); }
CLASS_NAME operator+(const CLASS_NAME &a, const CLASS_NAME &b);
CLASS_NAME& operator+=(CLASS_NAME &a, const CLASS_NAME &b);
// 输出运算符应尽可能减少格式化操作（如换行）
std::ostream& operator<<(std::ostream& out, const CLASS_NAME &item);
// 输入运算符必须处理输入可能失败的情况
std::istream& operator>>(std::istream& in, CLASS_NAME &item);
```

可以像调用普通函数一样调用运算符函数

```c++
data1 + data2;           // 普通表达式
operator+(data1, data2); // 等价的函数调用
```

**重载的逻辑与运算符`&&`、逻辑或运算符`||`和逗号运算符`,`无法保留运算对象的求值顺序，重载的`&&`和`||`还无法保留内置运算符的短路求值属性，因此不建议重载它们，另外取地址运算符`&`也不建议重载**。

