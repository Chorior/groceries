---
title:      "Qt5 基础"
subtitle:   "Hello Qt5"
date:       2017-07-14 20:20:00 +0800
header-img: "img/stock-photo-8.jpg"
tags:
    - C++
    - Qt5
---

本文知识来自[zetcode](http://zetcode.com/gui/qt5/)，介绍有关 Qt5 的基础知识。**在开始学习前，你应该能够熟练使用C++**，如果不是，建议看看[C++ 释疑篇](https://chorior.github.io/2017/03/01/C++-%E9%87%8A%E7%96%91-%E4%B8%80/)。

#   本文结构

*   [Qt 概述](#overview)
*	[Hello World](#hello_world)
*	[QString](#qstring)
*	[QDate, QTime and QDateTime](#qdate_qtime_and_qdatetime)
	*	[QDate](#qdate)
	*	[QTime](#qtime)
	*	[QDateTime](#qdatetime)
*	[Qt 容器](#qt_containers)
	*	[QVector](#qvector)
	*	[QList](#qlist)
	*	[QStringList](#qstringlist)
	*	[QSet](#qset)
	*	[QMap](#qmao)

<h2 id="overview">Qt 概述</h2>

Qt 是一个跨平台的应用开发框架，它被广泛用于开发GUI应用，一些著名的软件，如Opera、Google Earth 和 Skype都是基于它进行开发的，你可以用它创建开源应用程序以及商业应用程序。相对于只支持Windows的MFC来说，虽然MFC更为强大，但是MFC的封装不是很好，很多地方很乱很杂(来自网络)，Qt除了跨平台之外，各个组件也封装得非常好，这意味着使用Qt你将更容易的编写程序。

Qt 一般使用C++进行开发，通过语言绑定，也可以使用其它语言。

Qt开放源代码，你可以在[Qt github](https://github.com/qt)上获取；其提供三种授权方式：

*	商业版：可以任意的修改源代码而不必公开，适用于开发专属或商业软件；
*	GNU LGPL：可以被专属软件作为类库引用、发布和销售；
*	GNU GPL：可以自由运行，学习，共享和修改。

<h2 id="hello_world">Hello World</h2>

在安装 Qt 并设置好Path之后，我们来做一个Hello World。

首先，我们创建一个文件夹，例如`E:\qt_project`，然后创建一个main.cpp:

```c++
#include <QApplication>
#include <QWidget>

int main(int argc, char *argv[]) {
    
    QApplication app(argc, argv);

    QWidget window;

    window.resize(250, 150);
    window.setWindowTitle("Hello World");
    window.show();

    return app.exec();
}
```

然后打开qt命令行：

```bash
$ cd E:\qt_project
$ qmake -project
```

这时会生成一个`.pro`文件：

```text
######################################################################
# Automatically generated by qmake (3.1) Fri Jul 14 15:19:47 2017
######################################################################

TEMPLATE = app
TARGET = qt_project
INCLUDEPATH += .

# Input
SOURCES += main.cpp
```

由于默认情况下并不会包含Qt Widgets，所以手动在最后面加上`QT += widgets`，然后执行：

```bash
$ qmake
$ mingw32-make
```

这里默认执行的是`mingw32-make -f Makefile.Release`，你也可以手动执行`mingw32-make -f Makefile.Debug`，然后你会在相应文件夹下看到可运行的exe，运行之后可以看到一个标题为Hello World的空白窗口。

<h2 id="qstring">QString</h2>

QString类是Qt自行封装的专门用于处理字符串的类，**其实例保存一个Unicode字符串，该字符串由16bit QChar组成，每个QChar对应一个Unicode4.0字符**。Unicode是US-ASCII(ANSI X3.4-1986)和Latin-1(ISO 8859-1)的超集。

除QString外，Qt还提供了QByteArray来存储原始字节（包括"\0"）和传统的8位"\0"端接字符串，**使用QByteArray比使用`const char *`更方便**，它确保数据后跟"\0"终止符。当你需要存储原始二进制数据，或者当内存保护至关重要时（例如，使用嵌入式Linux的Qt），使用QByteArray会比较适合。

下载[qt base](https://github.com/qt/qtbase)源代码，你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qstring.h`和`qstring.cpp`。

### QString 构造

```c++
// main.cpp
#include <QTextStream>
#include <string>

int main(void)
{
	QTextStream out(stdout);

	const char* ch = "hahaha";
	std::string std_str("adfa");

	QString s1;
	QString s2(ch);
	QString s3(QString::fromStdString(std_str));

	out << (NULL == s1) << "\n"
		<< s2 << "\n"
		<< s3 << endl;

	return 0;
}
```

由于我们不需要gui，也不需要widgets，所以在生成`.pro`文件之后，在最后加上`QT -= gui`，因为需要在控制台上进行输出，所以再加上`CONFIG += console`，编译之后运行：

```text
1
hahaha
adfa
```

### 添加、访问、删除

```c++
// main.cpp
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);

	QString s1;

	Q_ASSERT(s1.isEmpty());
	Q_ASSERT(s1.isNull());

	s1.append("34");
	out << "append: " << s1 << "\n";

	s1.prepend("12");
	out << "prepend: " << s1 << "\n";

	s1 += "56";
	out << "+=: " << s1 << "\n";

	s1.insert(2, "333");
	out << "insert: " << s1 << "\n";

	s1.replace(2, 3, "777");
	out << "replace: " << s1 << "\n";

	s1.remove(2, 3);
	out << "remove: " << s1 << "\n";

	s1.push_back("789");
	out << "push_back: " << s1 << "\n";

	s1.push_front("0");
	out << "push_front: " << s1 << endl;

	out << s1 << "\n"
		<< "size: " << s1.size() << "\n"
		<< "length: " << s1.length() << "\n"
		<< "count: " << s1.count() << endl;

	for (int i = 0; i < s1.size(); ++i)
	{
		out << s1.at(i) << " ";
	}
	out << endl;

	QString s2;
	s2.swap(s1);
	for (auto it = s2.begin(); it != s2.end(); ++it)
	{
		out << *it << " ";
	}
	out << endl;

	return 0;
}
```

结果：

```text
append: 34
prepend: 1234
+=: 123456
insert: 123333456
replace: 127773456
remove: 123456
push_back: 123456789
push_front: 0123456789
0123456789
size: 10
length: 10
count: 10
0 1 2 3 4 5 6 7 8 9
0 1 2 3 4 5 6 7 8 9
```

### 动态创建、获取子串

QString 有一个非常牛逼的成员函数split，该成员函数可以通过传递的分隔符将字符串分解为多个子串，并且支持正则表达式，其将在[QStringList](#qstringlist)中演示。

```c++
// main.cpp
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);

	QString s1 = "file name is %1, function name is %2.";
	QString s2 = s1.arg(__FILE__);
	QString s3 = s2.arg(__func__);

	out << "s1: " << s1 << "\n"
		<< "s2: " << s2 << "\n"
		<< "s3: " << s3 << "\n";

	QString sub1 = s1.right(3);
	QString sub2 = s1.mid(5, 4);
	QString sub3 = s1.left(4);

	out << "sub1: " << sub1 << "\n"
		<< "sub2: " << sub2 << "\n"
		<< "sub3: " << sub3 << "\n";

	QStringRef subRef1 = s1.rightRef(3);
	QStringRef subRef2 = s1.midRef(5, 4);
	QStringRef subRef3 = s1.leftRef(4);

	out << "subRef1: " << subRef1 << "\n"
		<< "subRef2: " << subRef2 << "\n"
		<< "subRef3: " << subRef3.toString() << "\n";

	QString s4("Rain");
	QString s5 = s4.toLower();
	QString s6 = s4.toUpper();

	out << "sensitive: " << "\n"
		<< s4 << " < " << s5 << " is "
		<< s4.compare(s5) << "\n"
		<< s4 << " < " << s6 << " is "
		<< QString::compare(s4, s6) << "\n"
		<< "insensitive: " << "\n"
		<< s4 << " < " << s5 << " is "
		<< s4.compare(s5, Qt::CaseInsensitive) << "\n"
		<< s4 << " < " << s6 << " is "
		<< QString::compare(s4, s6, Qt::CaseInsensitive) << "\n";

	return 0;
}
```

结果：

```text
s1: file name is %1, function name is %2.
s2: file name is main.cpp, function name is %2.
s3: file name is main.cpp, function name is main.
sub1: %2.
sub2: name
sub3: file
subRef1: %2.
subRef2: name
subRef3: file
sensitive:
Rain < rain is -32
Rain < RAIN is 32
insensitive:
Rain < rain is 0
Rain < RAIN is 0
```

### 数值转换、字符分类、输出排版

我们知道标准库`<string>`里面有`to_string`、`stoi`、`stof`等数值转换操作，标准库`<cctype>`里面也有`tolower`、`isdigit`、`ispunct`等字符操作，相应的，QString也有对应的数值转换操作，QChar也有相应的字符操作。

```c++
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);

	QString s1;

	s1 = QString::number(123);
	out << s1 << " "
		<< "toInt: " << s1.toInt()
		<< endl;

	s1.setNum(1.234);
	out << s1 << " "
		<< "toDouble: " << s1.toDouble()
		<< endl;

	s1 = "7 white, 3 red roses.";
	int digits = 0, letters = 0;
	int spaces = 0, puncts = 0;
	foreach(auto &s, s1)
	{
		if (s.isDigit()) {
			digits++;
		}
		else if (s.isLetter()) {
			letters++;
		}
		else if (s.isSpace()) {
			spaces++;
		}
		else if (s.isPunct()) {
			puncts++;
		}
	}

	out << QString("There are %1 characters").arg(s1.count()) << endl;
	out << QString("There are %1 letters").arg(letters) << endl;
	out << QString("There are %1 digits").arg(digits) << endl;
	out << QString("There are %1 spaces").arg(spaces) << endl;
	out << QString("There are %1 punctuation characters").arg(puncts) << endl;

	QString field1 = "Name: ";
	QString field2 = "Occupation: ";
	QString field3 = "Residence: ";
	QString field4 = "Marital status: ";

	int width = field4.size();

	out << field1.rightJustified(width, ' ') << "Robert\n";
	out << field2.rightJustified(width, ' ') << "programmer\n";
	out << field3.rightJustified(width, ' ') << "New York\n";
	out << field4.rightJustified(width, ' ') << "single\n";

	return 0;
}
```

结果：

```text
123 toInt: 123
1.234 toDouble: 1.234
There are 21 characters
There are 13 letters
There are 2 digits
There are 4 spaces
There are 2 punctuation characters
          Name: Robert
    Occupation: programmer
     Residence: New York
Marital status: single
```

<h2 id="qdate_qtime_and_qdatetime">QDate, QTime and QDateTime</h2>

我们知道标准库处理日期、时间的方式是使用`<chrono>`或`<ctime>`，如果你想在Qt中处理日期的话，你可以使用 QDate，如果你想处理时间的话，你可以使用 QTime，如果你想日期、时间一起处理的话，你可以使用 QDateTime。

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qdatetime.h`和`qdatetime.cpp`。

<h3 id="qdate">QDate</h3>

```c++
#include <QTextStream>
#include <QDate>

/*
enum DateFormat {
TextDate,      // default Qt
ISODate,       // ISO 8601
SystemLocaleDate, // deprecated
LocalDate = SystemLocaleDate, // deprecated
LocaleDate,     // deprecated
SystemLocaleShortDate,
SystemLocaleLongDate,
DefaultLocaleShortDate,
DefaultLocaleLongDate,
RFC2822Date,        // RFC 2822 (+ 850 and 1036 during parsing)
ISODateWithMs
};
*/

int main(void)
{
	QTextStream out(stdout);

	QDate d1(2017, 7, 18);
	out << d1.toString(Qt::TextDate) << "\n"
		<< d1.toString(Qt::ISODate) << "\n"
		<< d1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< d1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< d1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< d1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< d1.toString(Qt::RFC2822Date) << "\n"
		<< d1.toString(Qt::ISODateWithMs) << "\n"
		<< d1.year() << " " << d1.month() << " " << d1.day() << "\n"
		<< d1.dayOfWeek() << " " << d1.dayOfYear() << "\n"
		<< d1.daysInMonth() << " " << d1.daysInYear() << "\n"
		<< d1.weekNumber() << endl;

	QString str("2017-07-29");
	d1 = QDate::fromString(str, Qt::ISODate);
	out << d1.toString(Qt::ISODate) << endl;

	d1.setDate(2017, 7, 20);
	out << d1.daysTo(QDate::currentDate()) << "\n"
		<< d1.addDays(2).toString(Qt::ISODate) << "\n"
		<< d1.addMonths(2).toString(Qt::ISODate) << "\n"
		<< d1.addYears(2).toString(Qt::ISODate) << "\n"
		<< d1.toString(Qt::ISODate) << " > "
		<< QDate::currentDate().toString(Qt::ISODate)
		<< " is " << (d1 > QDate::currentDate())
		<< endl;

	return 0;
}
```

结果：

```text
周二 七月 18 2017
2017-07-18
2017/7/18
2017年7月18日
2017/7/18
2017年7月18日
18 Jul 2017
2017-07-18
2017 7 18
2 199
31 365
29
2017-07-29
-2
2017-07-22
2017-09-20
2019-07-20
2017-07-20 > 2017-07-18 is 1
```

上面没有演示以下两个函数，因为它们需要自定义日期格式：

```c++
QString toString(const QString &format) const;
static QDate fromString(const QString &s, const QString &format);
```

自定义日期格式：

Expression | Output
------------ | ---------------------------------
yy | 两位数年份(00~99)
yyyy | 四位数年份
M | 不带前置零的月份数(1 ~ 12)
MM | 带有前置零的月份数(01 ~ 12)
MMM | 短的本地化月份名(如 Jan ~ Dec)
MMMM | 长的本地化月份名(如 January ~ December)
d | 不带前置零的天数(1 ~ 31)
dd | 带有前置零的天数(01 ~ 31)
ddd | 短的本地化天名(如 Mon ~ Sun)
dddd | 长的本地化天名(如 Monday ~ Sunday)

```c++
#include <QTextStream>
#include <QDate>

int main(void)
{
	QTextStream out(stdout);

	QDate cd = QDate::currentDate();

	out << "Today is " << cd.toString("yyyy-MM-dd") << endl;
	out << "Today is " << cd.toString("yy/M/dd") << endl;
	out << "Today is " << cd.toString("d. M. yyyy") << endl;
	out << "Today is " << cd.toString("d-MMMM-yyyy") << endl;

	QString fmt("yyyy-MM-dd");
	QString str("2017-07-18");
	out << QDate::fromString(str, fmt).toString("yy/M/dd") << endl;

	return 0;
}
```

结果：

```text
Today is 2017-07-18
Today is 17/7/18
Today is 18. 7. 2017
Today is 18-七月-2017
17/7/18
```

<h3 id="qtime">QTime</h3>

```c++
#include <QTextStream>
#include <QTime>

int main(void)
{
	QTextStream out(stdout);

	QTime t1(20, 01, 18, 50);
	out << t1.toString(Qt::TextDate) << "\n"
		<< t1.toString(Qt::ISODate) << "\n"
		<< t1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< t1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< t1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< t1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< t1.toString(Qt::RFC2822Date) << "\n"
		<< t1.toString(Qt::ISODateWithMs) << "\n"
		<< t1.hour() << " " << t1.minute() << " "
		<< t1.second() << " " << t1.msec()
		<< endl;

	QString str("20:02:20.22");
	QTime t2 = QTime::fromString(str, Qt::ISODate);
	out << t2.toString(Qt::ISODate) << endl;

	t2 = QTime::currentTime();
	t2.setHMS(21, 01, 18, 50);
	out << t2.secsTo(t1) << "\n"
		<< t2.msecsTo(t1) << "\n"
		<< t2.addSecs(2).toString(Qt::ISODate) << "\n"
		<< t2.addMSecs(950).toString(Qt::ISODate) << "\n"
		<< t2.toString(Qt::ISODate) << " > " << t1.toString(Qt::ISODate)
		<< " is " << (t2 > t1)
		<< endl;

	return 0;
}
```

结果：

```text
20:01:18
20:01:18
20:01
20:01:18
20:01
20:01:18
20:01:18
20:01:18.050
20 1 18 50
20:02:20
-3600
-3600000
21:01:20
21:01:19
21:01:18 > 20:01:18 is 1
```

自定义时间格式：

Expression | Output
------------ | ---------------------------------
AP <br> A | AM/PM
ap <br> a | am/pm
t | 时区
h | 0 ~ 23 或 1 ~ 12
hh | 00 ~ 23 或 01 ~ 12
H | 0 ~ 23
HH | 00 ~ 23
m | 0 ~ 59
mm | 00 ~ 59
s | 0 ~ 59
ss | 00 ~ 59
z | 0 ~ 999
zzz | 000 ~ 999

```c++
#include <QTextStream>
#include <QTime>

int main(void)
{
	QTextStream out(stdout);

	QTime cd = QTime::currentTime();

	out << "The time is " << cd.toString("hh:mm:ss.zzz") << endl;
	out << "The time is " << cd.toString("h:m:s a") << endl;
	out << "The time is " << cd.toString("H:m:s A") << endl;
	out << "The time is " << cd.toString("h:m AP") << endl;

	QString fmt("hh:mm:ss.zzz");
	QString str("20:20:20.200");
	out << QTime::fromString(str, fmt).toString("h:m:s a") << endl;

	return 0;
}
```

结果：

```text
Today is 13:40:26.653
Today is 1:40:26 下午
Today is 13:40:26 下午
Today is 1:40 下午
8:20:20 下午
```

仔细查看 QTime 的成员函数，发现还有三个特别的函数：

```c++
// 一天86400秒
void QTime::start()
{
    *this = currentTime();
}

int QTime::restart()
{
    QTime t = currentTime();
    int n = msecsTo(t);
    if (n < 0)                                // passed midnight
        n += 86400*1000;
    *this = t;
    return n;
}

int QTime::elapsed() const
{
    int n = msecsTo(currentTime());
    if (n < 0)                                // passed midnight
        n += 86400 * 1000;
    return n;
}
```

这三个函数时干什么的呢，从名字上很容易猜出来，它们是用来计时的。根据源代码，当时间超过24小时后，`restart`和`elapsed`将会从零重新开始计时。

```c++
#include <QTextStream>
#include <QTime>
#include <thread>
#include <chrono>

int main(void)
{
	QTextStream out(stdout);

	QTime t;
	t.start();
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(100));
	out << "took " << t.restart() << " ms" << "\n";
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(200));
	out << "took " << t.elapsed() << " ms" << "\n";

	return 0;
}
```

结果：

```text
took 100 ms
took 200 ms
```

<h3 id="qdatetime">QDateTime</h3>

你可以把 QDateTime 当做 QDate 和 QTime 的并集，使用时可以使用成员函数`date()`和`time()`来获取对应的 QDate 和 QTime，修改之后再通过成员函数`setDate`和`setTime`将修改合并到原 QDateTime 实例中；剩余比较独立的函数是`toUTC`和`toTime_t`，其中UTC时间是世界标准时间，不随地区、季节的改变而改变，`time_t`是Unix时间。

```c++
#include <QTextStream>
#include <QDateTime>

int main(void)
{
	QTextStream out(stdout);

	QDate d = QDate::currentDate();
	QTime t = QTime::currentTime();
	QDateTime dt1(d, t);
	QDateTime dt2 = QDateTime::currentDateTime();
	QDateTime dt3 = QDateTime::currentDateTimeUtc();

	out << dt1.toString(Qt::ISODate) << "\n"
		<< dt2.toString(Qt::ISODate) << "\n"
		<< dt3.toString(Qt::ISODate) << "\n"
		<< dt2.date().toString(Qt::ISODate) << "\n"
		<< dt2.time().toString(Qt::ISODate) << "\n"
		<< dt1.toUTC().toString(Qt::ISODate) << "\n"
		<< dt2.toTime_t()
		<< endl;

	return 0;
}
```

结果：

```text
2017-07-18T14:56:57
2017-07-18T14:56:57
2017-07-18T06:56:57Z
2017-07-18
14:56:57
2017-07-18T06:56:57Z
1500361017
```

<h2 id="qt_containers">Qt 容器</h2>

容器分为顺序容器与关联容器。顺序容器中元素的顺序由其加入容器时的位置决定；关联容器中元素的顺序由其相关联的关键字值决定。

Qt中的顺序容器包含QVector、QList、QStringList，关联容器包含QSet、QMap。

<h3 id="qvector">QVector</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qvector.h`。

仔细看其实现，你可以简单的把它当标准vector来用：

```c++
#include <QTextStream>
#include <QVector>

template <typename T>
QTextStream& operator<<(QTextStream& out, QVector<T> &v);

int main(void)
{
	QTextStream out(stdout);

	QVector<int> v1{ 1,2,3,4,5 };
	QVector<int> v2(5, 1);

	v1.swap(v2);
	v2.push_back(7);
	v2.push_front(0);
	v2.insert(v2.end() - 1, 6);
	v2.pop_back();
	v2.pop_front();

	out << "v1: " << v1 << "\n"
		<< "v2: " << v2 << "\n"
		<< "v1.size = " << v1.size() << "\n"
		<< "v1[1] = " << v1[1] << "\n"
		<< "v2[2] = " << v2.at(2) << "\n"
		<< "v2.front = " << v2.front() << "\n"
		<< "v2.back = " << v2.back()
		<< endl;

	return 0;
}

template <typename T>
QTextStream& operator<<(QTextStream& out, QVector<T> &v)
{
	if (!v.empty())
	{
		for (auto &i : v)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
v1: 1 1 1 1 1
v2: 1 2 3 4 5 6
v1.size = 5
v1[1] = 1
v2[2] = 3
v2.front = 1
v2.back = 6
```

<h3 id="qlist">QList</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qlist.h`和`qlist.cpp`。

QList 的使用跟 QVector 差不多。

```c++
#include <QTextStream>
#include <QVector>
#include <QList>

template <typename T>
QTextStream& operator<<(QTextStream& out, QList<T> &l);

int main(void)
{
	QTextStream out(stdout);

	QList<int> l1{ 1,2,3,4,5 };
	QList<int> l2 = QVector<int>(5, 1).toList();

	l1.swap(l2);
	l2.push_back(7);
	l2.push_front(0);
	l2.insert(l2.end() - 1, 6);
	l2.pop_back();
	l2.pop_front();

	out << "l1: " << l1 << "\n"
		<< "l2: " << l2 << "\n"
		<< "l1.size = " << l1.size() << "\n"
		<< "l1[1] = " << l1[1] << "\n"
		<< "l2[2] = " << l2.at(2) << "\n"
		<< "l2.front = " << l2.front() << "\n"
		<< "l2.back = " << l2.back()
		<< endl;


	return 0;
}

template <typename T>
QTextStream& operator<<(QTextStream& out, QList<T> &l)
{
	if (!l.empty())
	{
		for (auto &i : l)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
l1: 1 1 1 1 1
l2: 1 2 3 4 5 6
l1.size = 5
l1[1] = 1
l2[2] = 3
l2.front = 1
l2.back = 6
```

<h3 id="qstringlist">QStringList</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qstringlist.h`和`qstringlist.cpp`。

QStringList 继承自`QList<QString>`，它比较有用的函数是`filter`，该函数返回当前list中包含传入子串的字符串组成的list，其它使用与QList没什么区别，相当于一个特例化版本，有时候与 QString 的 split 配合使用。

```c++
#include <QTextStream>
#include <QStringList>
#include <QVector>

QTextStream& operator<<(QTextStream& out, QStringList &sl);

int main(void)
{
	QTextStream out(stdout);

	QList<QString> l1{ "1","2","3","4","5" };
	QList<QString> l2 = QVector<QString>(5, "1").toList();

	QStringList sl1(l1);
	QStringList sl2(l2);

	sl1.swap(sl2);
	sl2.push_back("7");
	sl2.push_front("0");
	sl2.insert(sl2.end() - 1, "6");
	sl2.pop_back();
	sl2.pop_front();

	out << "sl1: " << sl1 << "\n"
		<< "sl2: " << sl2 << "\n"
		<< "sl1.size = " << sl1.size() << "\n"
		<< "sl1[1] = " << sl1[1] << "\n"
		<< "sl2[2] = " << sl2.at(2) << "\n"
		<< "sl2.front = " << sl2.front() << "\n"
		<< "sl2.back = " << sl2.back()
		<< endl;

	QStringList sl3{ "Bill Murray","John Doe","Bill Clinton" };
	sl3 = sl3.filter("Bill");

	out << "sl3: " << sl3 << endl;

	QString str = "a,,b,c";
	QStringList sl4 = str.split(',');
	QStringList sl5 = str.split(',', QString::SkipEmptyParts);

	out << "sl4: " << sl4 << "\n"
		<< "sl5: " << sl5
		<< endl;

	return 0;
}

QTextStream& operator<<(QTextStream& out, QStringList &sl)
{
	if (!sl.empty())
	{
		for (auto &i : sl)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
sl1: 1 1 1 1 1
sl2: 1 2 3 4 5 6
sl1.size = 5
sl1[1] = 1
sl2[2] = 3
sl2.front = 1
sl2.back = 6
sl3: Bill Murray Bill Clinton
sl4: a  b c
sl5: a b c
```

<h3 id="qset">QSet</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qset.h`。

