---
title:      "Qt5 基础"
subtitle:   "Hello Qt5"
date:       2017-07-14 20:20:00 +0800
header-img: "img/stock-photo-8.jpg"
tags:
    - C++
    - Qt5
---

本文知识来自[zetcode](http://zetcode.com/gui/qt5/)，介绍有关 Qt5 的基础知识。**在开始学习前，你应该能够熟练使用C++**，如果不是，建议看看[C++ 释疑篇](https://chorior.github.io/2017/03/01/C++-%E9%87%8A%E7%96%91-%E4%B8%80/)。

#   本文结构

*   [Qt 概述](#overview)
*	[Hello World](#hello_world)
*	[QString](#qstring)
*	[QDate, QTime and QDateTime](#qdate_qtime_and_qdatetime)
	*	[QDate](#qdate)
	*	[QTime](#qtime)
	*	[QDateTime](#qdatetime)
*	[Qt 容器](#qt_containers)
	*	[QVector](#qvector)
	*	[QList](#qlist)
	*	[QStringList](#qstringlist)
	*	[QSet](#qset)
	*	[QMap](#qmap)
*	[IO](#io)
	*	[QFile](#qfile)
	*	[QDir](#qdir)
	*	[QFileInfo](#qfileinfo)
	*	[QTextStream](#qtextstream)
	*	[QDataStream](#qdatastream)
	*	[QDebug](#qdebug)
*	[Qt 部件](#qt_widget)
	*	[QApplication](#qapplication)
	*	[QWidget](#qwidget)

<h2 id="overview">Qt 概述</h2>

Qt 是一个跨平台的应用开发框架，它被广泛用于开发GUI应用，一些著名的软件，如Opera、Google Earth 和 Skype都是基于它进行开发的，你可以用它创建开源应用程序以及商业应用程序。相对于只支持Windows的MFC来说，虽然MFC更为强大，但是MFC的封装不是很好，很多地方很乱很杂(来自网络)，Qt除了跨平台之外，各个组件也封装得非常好，这意味着使用Qt你将更容易的编写程序。

Qt 一般使用C++进行开发，通过语言绑定，也可以使用其它语言。

Qt开放源代码，你可以在[Qt github](https://github.com/qt)上获取；其提供三种授权方式：

*	商业版：可以任意的修改源代码而不必公开，适用于开发专属或商业软件；
*	GNU LGPL：可以被专属软件作为类库引用、发布和销售；
*	GNU GPL：可以自由运行，学习，共享和修改。

<h2 id="hello_world">Hello World</h2>

在安装 Qt 并设置好Path之后，我们来做一个Hello World。

首先，我们创建一个文件夹，例如`E:\qt_project`，然后创建一个main.cpp:

```c++
#include <QApplication>
#include <QWidget>

int main(int argc, char *argv[]) {
    
    QApplication app(argc, argv);

    QWidget window;

    window.resize(250, 150);
    window.setWindowTitle("Hello World");
    window.show();

    return app.exec();
}
```

然后打开qt命令行：

```bash
$ cd E:\qt_project
$ qmake -project
```

这时会生成一个`.pro`文件：

```text
######################################################################
# Automatically generated by qmake (3.1) Fri Jul 14 15:19:47 2017
######################################################################

TEMPLATE = app
TARGET = qt_project
INCLUDEPATH += .

# Input
SOURCES += main.cpp
```

由于默认情况下并不会包含Qt Widgets，所以手动在最后面加上`QT += widgets`，然后执行：

```bash
$ qmake
$ mingw32-make
```

这里默认执行的是`mingw32-make -f Makefile.Release`，你也可以手动执行`mingw32-make -f Makefile.Debug`，然后你会在相应文件夹下看到可运行的exe，运行之后可以看到一个标题为Hello World的空白窗口。

<h2 id="qstring">QString</h2>

QString类是Qt自行封装的专门用于处理字符串的类，**其实例保存一个Unicode字符串，该字符串由16bit QChar组成，每个QChar对应一个Unicode4.0字符**。Unicode是US-ASCII(ANSI X3.4-1986)和Latin-1(ISO 8859-1)的超集。

除QString外，Qt还提供了QByteArray来存储原始字节（包括"\0"）和传统的8位"\0"端接字符串，**使用QByteArray比使用`const char *`更方便**，它确保数据后跟"\0"终止符。当你需要存储原始二进制数据，或者当内存保护至关重要时（例如，使用嵌入式Linux的Qt），使用QByteArray会比较适合。

下载[qt base](https://github.com/qt/qtbase)源代码，你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qstring.h`和`qstring.cpp`。

### QString 构造

```c++
// main.cpp
#include <QTextStream>
#include <string>

int main(void)
{
	QTextStream out(stdout);

	const char* ch = "hahaha";
	std::string std_str("adfa");

	QString s1;
	QString s2(ch);
	QString s3(QString::fromStdString(std_str));

	out << (NULL == s1) << "\n"
		<< s2 << "\n"
		<< s3 << endl;

	return 0;
}
```

由于我们不需要gui，也不需要widgets，所以在生成`.pro`文件之后，在最后加上`QT -= gui`，因为需要在控制台上进行输出，所以再加上`CONFIG += console`，编译之后运行：

```text
1
hahaha
adfa
```

### 添加、访问、删除

```c++
// main.cpp
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);

	QString s1;

	Q_ASSERT(s1.isEmpty());
	Q_ASSERT(s1.isNull());

	s1.append("34");
	out << "append: " << s1 << "\n";

	s1.prepend("12");
	out << "prepend: " << s1 << "\n";

	s1 += "56";
	out << "+=: " << s1 << "\n";

	s1.insert(2, "333");
	out << "insert: " << s1 << "\n";

	s1.replace(2, 3, "777");
	out << "replace: " << s1 << "\n";

	s1.remove(2, 3);
	out << "remove: " << s1 << "\n";

	s1.push_back("789");
	out << "push_back: " << s1 << "\n";

	s1.push_front("0");
	out << "push_front: " << s1 << endl;

	out << s1 << "\n"
		<< "size: " << s1.size() << "\n"
		<< "length: " << s1.length() << "\n"
		<< "count: " << s1.count() << endl;

	for (int i = 0; i < s1.size(); ++i)
	{
		out << s1.at(i) << " ";
	}
	out << endl;

	QString s2;
	s2.swap(s1);
	for (auto it = s2.begin(); it != s2.end(); ++it)
	{
		out << *it << " ";
	}
	out << endl;

	return 0;
}
```

结果：

```text
append: 34
prepend: 1234
+=: 123456
insert: 123333456
replace: 127773456
remove: 123456
push_back: 123456789
push_front: 0123456789
0123456789
size: 10
length: 10
count: 10
0 1 2 3 4 5 6 7 8 9
0 1 2 3 4 5 6 7 8 9
```

### 动态创建、获取子串

QString 有一个非常牛逼的成员函数split，该成员函数可以通过传递的分隔符将字符串分解为多个子串，并且支持正则表达式，其将在[QStringList](#qstringlist)中演示。

```c++
// main.cpp
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);

	QString s1 = "file name is %1, function name is %2.";
	QString s2 = s1.arg(__FILE__);
	QString s3 = s2.arg(__func__);

	out << "s1: " << s1 << "\n"
		<< "s2: " << s2 << "\n"
		<< "s3: " << s3 << "\n";

	QString sub1 = s1.right(3);
	QString sub2 = s1.mid(5, 4);
	QString sub3 = s1.left(4);

	out << "sub1: " << sub1 << "\n"
		<< "sub2: " << sub2 << "\n"
		<< "sub3: " << sub3 << "\n";

	QStringRef subRef1 = s1.rightRef(3);
	QStringRef subRef2 = s1.midRef(5, 4);
	QStringRef subRef3 = s1.leftRef(4);

	out << "subRef1: " << subRef1 << "\n"
		<< "subRef2: " << subRef2 << "\n"
		<< "subRef3: " << subRef3.toString() << "\n";

	QString s4("Rain");
	QString s5 = s4.toLower();
	QString s6 = s4.toUpper();

	out << "sensitive: " << "\n"
		<< s4 << " < " << s5 << " is "
		<< s4.compare(s5) << "\n"
		<< s4 << " < " << s6 << " is "
		<< QString::compare(s4, s6) << "\n"
		<< "insensitive: " << "\n"
		<< s4 << " < " << s5 << " is "
		<< s4.compare(s5, Qt::CaseInsensitive) << "\n"
		<< s4 << " < " << s6 << " is "
		<< QString::compare(s4, s6, Qt::CaseInsensitive) << "\n";

	return 0;
}
```

结果：

```text
s1: file name is %1, function name is %2.
s2: file name is main.cpp, function name is %2.
s3: file name is main.cpp, function name is main.
sub1: %2.
sub2: name
sub3: file
subRef1: %2.
subRef2: name
subRef3: file
sensitive:
Rain < rain is -32
Rain < RAIN is 32
insensitive:
Rain < rain is 0
Rain < RAIN is 0
```

### 数值转换、字符分类、输出排版

我们知道标准库`<string>`里面有`to_string`、`stoi`、`stof`等数值转换操作，标准库`<cctype>`里面也有`tolower`、`isdigit`、`ispunct`等字符操作，相应的，QString也有对应的数值转换操作，QChar也有相应的字符操作。

```c++
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);

	QString s1;

	s1 = QString::number(123);
	out << s1 << " "
		<< "toInt: " << s1.toInt()
		<< endl;

	s1.setNum(1.234);
	out << s1 << " "
		<< "toDouble: " << s1.toDouble()
		<< endl;

	s1 = "7 white, 3 red roses.";
	int digits = 0, letters = 0;
	int spaces = 0, puncts = 0;
	foreach(auto &s, s1)
	{
		if (s.isDigit()) {
			digits++;
		}
		else if (s.isLetter()) {
			letters++;
		}
		else if (s.isSpace()) {
			spaces++;
		}
		else if (s.isPunct()) {
			puncts++;
		}
	}

	out << QString("There are %1 characters").arg(s1.count()) << endl;
	out << QString("There are %1 letters").arg(letters) << endl;
	out << QString("There are %1 digits").arg(digits) << endl;
	out << QString("There are %1 spaces").arg(spaces) << endl;
	out << QString("There are %1 punctuation characters").arg(puncts) << endl;

	QString field1 = "Name: ";
	QString field2 = "Occupation: ";
	QString field3 = "Residence: ";
	QString field4 = "Marital status: ";

	int width = field4.size();

	out << field1.rightJustified(width, ' ') << "Robert\n";
	out << field2.rightJustified(width, ' ') << "programmer\n";
	out << field3.rightJustified(width, ' ') << "New York\n";
	out << field4.rightJustified(width, ' ') << "single\n";

	return 0;
}
```

结果：

```text
123 toInt: 123
1.234 toDouble: 1.234
There are 21 characters
There are 13 letters
There are 2 digits
There are 4 spaces
There are 2 punctuation characters
          Name: Robert
    Occupation: programmer
     Residence: New York
Marital status: single
```

<h2 id="qdate_qtime_and_qdatetime">QDate, QTime and QDateTime</h2>

我们知道标准库处理日期、时间的方式是使用`<chrono>`或`<ctime>`，如果你想在Qt中处理日期的话，你可以使用 QDate，如果你想处理时间的话，你可以使用 QTime，如果你想日期、时间一起处理的话，你可以使用 QDateTime。

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qdatetime.h`和`qdatetime.cpp`。

<h3 id="qdate">QDate</h3>

```c++
#include <QTextStream>
#include <QDate>

/*
enum DateFormat {
TextDate,      // default Qt
ISODate,       // ISO 8601
SystemLocaleDate, // deprecated
LocalDate = SystemLocaleDate, // deprecated
LocaleDate,     // deprecated
SystemLocaleShortDate,
SystemLocaleLongDate,
DefaultLocaleShortDate,
DefaultLocaleLongDate,
RFC2822Date,        // RFC 2822 (+ 850 and 1036 during parsing)
ISODateWithMs
};
*/

int main(void)
{
	QTextStream out(stdout);

	QDate d1(2017, 7, 18);
	out << d1.toString(Qt::TextDate) << "\n"
		<< d1.toString(Qt::ISODate) << "\n"
		<< d1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< d1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< d1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< d1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< d1.toString(Qt::RFC2822Date) << "\n"
		<< d1.toString(Qt::ISODateWithMs) << "\n"
		<< d1.year() << " " << d1.month() << " " << d1.day() << "\n"
		<< d1.dayOfWeek() << " " << d1.dayOfYear() << "\n"
		<< d1.daysInMonth() << " " << d1.daysInYear() << "\n"
		<< d1.weekNumber() << endl;

	QString str("2017-07-29");
	d1 = QDate::fromString(str, Qt::ISODate);
	out << d1.toString(Qt::ISODate) << endl;

	d1.setDate(2017, 7, 20);
	out << d1.daysTo(QDate::currentDate()) << "\n"
		<< d1.addDays(2).toString(Qt::ISODate) << "\n"
		<< d1.addMonths(2).toString(Qt::ISODate) << "\n"
		<< d1.addYears(2).toString(Qt::ISODate) << "\n"
		<< d1.toString(Qt::ISODate) << " > "
		<< QDate::currentDate().toString(Qt::ISODate)
		<< " is " << (d1 > QDate::currentDate())
		<< endl;

	return 0;
}
```

结果：

```text
周二 七月 18 2017
2017-07-18
2017/7/18
2017年7月18日
2017/7/18
2017年7月18日
18 Jul 2017
2017-07-18
2017 7 18
2 199
31 365
29
2017-07-29
-2
2017-07-22
2017-09-20
2019-07-20
2017-07-20 > 2017-07-18 is 1
```

上面没有演示以下两个函数，因为它们需要自定义日期格式：

```c++
QString toString(const QString &format) const;
static QDate fromString(const QString &s, const QString &format);
```

自定义日期格式：

Expression | Output
------------ | ---------------------------------
yy | 两位数年份(00~99)
yyyy | 四位数年份
M | 不带前置零的月份数(1 ~ 12)
MM | 带有前置零的月份数(01 ~ 12)
MMM | 短的本地化月份名(如 Jan ~ Dec)
MMMM | 长的本地化月份名(如 January ~ December)
d | 不带前置零的天数(1 ~ 31)
dd | 带有前置零的天数(01 ~ 31)
ddd | 短的本地化天名(如 Mon ~ Sun)
dddd | 长的本地化天名(如 Monday ~ Sunday)

```c++
#include <QTextStream>
#include <QDate>

int main(void)
{
	QTextStream out(stdout);

	QDate cd = QDate::currentDate();

	out << "Today is " << cd.toString("yyyy-MM-dd") << endl;
	out << "Today is " << cd.toString("yy/M/dd") << endl;
	out << "Today is " << cd.toString("d. M. yyyy") << endl;
	out << "Today is " << cd.toString("d-MMMM-yyyy") << endl;

	QString fmt("yyyy-MM-dd");
	QString str("2017-07-18");
	out << QDate::fromString(str, fmt).toString("yy/M/dd") << endl;

	return 0;
}
```

结果：

```text
Today is 2017-07-18
Today is 17/7/18
Today is 18. 7. 2017
Today is 18-七月-2017
17/7/18
```

<h3 id="qtime">QTime</h3>

```c++
#include <QTextStream>
#include <QTime>

int main(void)
{
	QTextStream out(stdout);

	QTime t1(20, 01, 18, 50);
	out << t1.toString(Qt::TextDate) << "\n"
		<< t1.toString(Qt::ISODate) << "\n"
		<< t1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< t1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< t1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< t1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< t1.toString(Qt::RFC2822Date) << "\n"
		<< t1.toString(Qt::ISODateWithMs) << "\n"
		<< t1.hour() << " " << t1.minute() << " "
		<< t1.second() << " " << t1.msec()
		<< endl;

	QString str("20:02:20.22");
	QTime t2 = QTime::fromString(str, Qt::ISODate);
	out << t2.toString(Qt::ISODate) << endl;

	t2 = QTime::currentTime();
	t2.setHMS(21, 01, 18, 50);
	out << t2.secsTo(t1) << "\n"
		<< t2.msecsTo(t1) << "\n"
		<< t2.addSecs(2).toString(Qt::ISODate) << "\n"
		<< t2.addMSecs(950).toString(Qt::ISODate) << "\n"
		<< t2.toString(Qt::ISODate) << " > " << t1.toString(Qt::ISODate)
		<< " is " << (t2 > t1)
		<< endl;

	return 0;
}
```

结果：

```text
20:01:18
20:01:18
20:01
20:01:18
20:01
20:01:18
20:01:18
20:01:18.050
20 1 18 50
20:02:20
-3600
-3600000
21:01:20
21:01:19
21:01:18 > 20:01:18 is 1
```

自定义时间格式：

Expression | Output
------------ | ---------------------------------
AP <br> A | AM/PM
ap <br> a | am/pm
t | 时区
h | 0 ~ 23 或 1 ~ 12
hh | 00 ~ 23 或 01 ~ 12
H | 0 ~ 23
HH | 00 ~ 23
m | 0 ~ 59
mm | 00 ~ 59
s | 0 ~ 59
ss | 00 ~ 59
z | 0 ~ 999
zzz | 000 ~ 999

```c++
#include <QTextStream>
#include <QTime>

int main(void)
{
	QTextStream out(stdout);

	QTime cd = QTime::currentTime();

	out << "The time is " << cd.toString("hh:mm:ss.zzz") << endl;
	out << "The time is " << cd.toString("h:m:s a") << endl;
	out << "The time is " << cd.toString("H:m:s A") << endl;
	out << "The time is " << cd.toString("h:m AP") << endl;

	QString fmt("hh:mm:ss.zzz");
	QString str("20:20:20.200");
	out << QTime::fromString(str, fmt).toString("h:m:s a") << endl;

	return 0;
}
```

结果：

```text
Today is 13:40:26.653
Today is 1:40:26 下午
Today is 13:40:26 下午
Today is 1:40 下午
8:20:20 下午
```

仔细查看 QTime 的成员函数，发现还有三个特别的函数：

```c++
// 一天86400秒
void QTime::start()
{
    *this = currentTime();
}

int QTime::restart()
{
    QTime t = currentTime();
    int n = msecsTo(t);
    if (n < 0)                                // passed midnight
        n += 86400*1000;
    *this = t;
    return n;
}

int QTime::elapsed() const
{
    int n = msecsTo(currentTime());
    if (n < 0)                                // passed midnight
        n += 86400 * 1000;
    return n;
}
```

这三个函数时干什么的呢，从名字上很容易猜出来，它们是用来计时的。根据源代码，当时间超过24小时后，`restart`和`elapsed`将会从零重新开始计时。

```c++
#include <QTextStream>
#include <QTime>
#include <thread>
#include <chrono>

int main(void)
{
	QTextStream out(stdout);

	QTime t;
	t.start();
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(100));
	out << "took " << t.restart() << " ms" << "\n";
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(200));
	out << "took " << t.elapsed() << " ms" << "\n";

	return 0;
}
```

结果：

```text
took 100 ms
took 200 ms
```

<h3 id="qdatetime">QDateTime</h3>

你可以把 QDateTime 当做 QDate 和 QTime 的并集，使用时可以使用成员函数`date()`和`time()`来获取对应的 QDate 和 QTime，修改之后再通过成员函数`setDate`和`setTime`将修改合并到原 QDateTime 实例中；剩余比较独立的函数是`toUTC`和`toTime_t`，其中UTC时间是世界标准时间，不随地区、季节的改变而改变，`time_t`是Unix时间。

```c++
#include <QTextStream>
#include <QDateTime>

int main(void)
{
	QTextStream out(stdout);

	QDate d = QDate::currentDate();
	QTime t = QTime::currentTime();
	QDateTime dt1(d, t);
	QDateTime dt2 = QDateTime::currentDateTime();
	QDateTime dt3 = QDateTime::currentDateTimeUtc();

	out << dt1.toString(Qt::ISODate) << "\n"
		<< dt2.toString(Qt::ISODate) << "\n"
		<< dt3.toString(Qt::ISODate) << "\n"
		<< dt2.date().toString(Qt::ISODate) << "\n"
		<< dt2.time().toString(Qt::ISODate) << "\n"
		<< dt1.toUTC().toString(Qt::ISODate) << "\n"
		<< dt2.toTime_t()
		<< endl;

	return 0;
}
```

结果：

```text
2017-07-18T14:56:57
2017-07-18T14:56:57
2017-07-18T06:56:57Z
2017-07-18
14:56:57
2017-07-18T06:56:57Z
1500361017
```

<h2 id="qt_containers">Qt 容器</h2>

容器分为顺序容器与关联容器。顺序容器中元素的顺序由其加入容器时的位置决定；关联容器中元素的顺序由其相关联的关键字值决定。

Qt中的顺序容器包含QVector、QList、QStringList，关联容器包含QSet、QMap。

<h3 id="qvector">QVector</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qvector.h`。

仔细看其实现，你可以简单的把它当标准vector来用：

```c++
#include <QTextStream>
#include <QVector>

template <typename T>
QTextStream& operator<<(QTextStream& out, const QVector<T> &v);

int main(void)
{
	QTextStream out(stdout);

	QVector<int> v1{ 1,2,3,4,5 };
	QVector<int> v2(5, 1);

	v1.swap(v2);
	v2.push_back(7);
	v2.push_front(0);
	v2.insert(v2.end() - 1, 6);
	v2.pop_back();
	v2.pop_front();

	out << "v1: " << v1 << "\n"
		<< "v2: " << v2 << "\n"
		<< "v1.size = " << v1.size() << "\n"
		<< "v1[1] = " << v1[1] << "\n"
		<< "v2[2] = " << v2.at(2) << "\n"
		<< "v2.front = " << v2.front() << "\n"
		<< "v2.back = " << v2.back()
		<< endl;

	return 0;
}

template <typename T>
QTextStream& operator<<(QTextStream& out, const QVector<T> &v)
{
	if (!v.empty())
	{
		for (auto &i : v)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
v1: 1 1 1 1 1
v2: 1 2 3 4 5 6
v1.size = 5
v1[1] = 1
v2[2] = 3
v2.front = 1
v2.back = 6
```

<h3 id="qlist">QList</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qlist.h`和`qlist.cpp`。

QList 的使用跟 QVector 差不多。

```c++
#include <QTextStream>
#include <QVector>
#include <QList>

template <typename T>
QTextStream& operator<<(QTextStream& out, const QList<T> &l);

int main(void)
{
	QTextStream out(stdout);

	QList<int> l1{ 1,2,3,4,5 };
	QList<int> l2 = QVector<int>(5, 1).toList();

	l1.swap(l2);
	l2.push_back(7);
	l2.push_front(0);
	l2.insert(l2.end() - 1, 6);
	l2.pop_back();
	l2.pop_front();

	out << "l1: " << l1 << "\n"
		<< "l2: " << l2 << "\n"
		<< "l1.size = " << l1.size() << "\n"
		<< "l1[1] = " << l1[1] << "\n"
		<< "l2[2] = " << l2.at(2) << "\n"
		<< "l2.front = " << l2.front() << "\n"
		<< "l2.back = " << l2.back()
		<< endl;


	return 0;
}

template <typename T>
QTextStream& operator<<(QTextStream& out, const QList<T> &l)
{
	if (!l.empty())
	{
		for (auto &i : l)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
l1: 1 1 1 1 1
l2: 1 2 3 4 5 6
l1.size = 5
l1[1] = 1
l2[2] = 3
l2.front = 1
l2.back = 6
```

<h3 id="qstringlist">QStringList</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qstringlist.h`和`qstringlist.cpp`。

QStringList 继承自`QList<QString>`，它比较有用的函数是`filter`，该函数返回当前list中包含传入子串的字符串组成的list，其它使用与QList没什么区别，相当于一个特例化版本，有时候与 QString 的 split 配合使用。

```c++
#include <QTextStream>
#include <QStringList>
#include <QVector>

QTextStream& operator<<(QTextStream& out, const QStringList &sl);

int main(void)
{
	QTextStream out(stdout);

	QList<QString> l1{ "1","2","3","4","5" };
	QList<QString> l2 = QVector<QString>(5, "1").toList();

	QStringList sl1(l1);
	QStringList sl2(l2);

	sl1.swap(sl2);
	sl2.push_back("7");
	sl2.push_front("0");
	sl2.insert(sl2.end() - 1, "6");
	sl2.pop_back();
	sl2.pop_front();

	out << "sl1: " << sl1 << "\n"
		<< "sl2: " << sl2 << "\n"
		<< "sl1.size = " << sl1.size() << "\n"
		<< "sl1[1] = " << sl1[1] << "\n"
		<< "sl2[2] = " << sl2.at(2) << "\n"
		<< "sl2.front = " << sl2.front() << "\n"
		<< "sl2.back = " << sl2.back()
		<< endl;

	QStringList sl3{ "Bill Murray","John Doe","Bill Clinton" };
	sl3 = sl3.filter("Bill");

	out << "sl3: " << sl3 << endl;

	QString str = "a,,b,c";
	QStringList sl4 = str.split(',');
	QStringList sl5 = str.split(',', QString::SkipEmptyParts);

	out << "sl4: " << sl4 << "\n"
		<< "sl5: " << sl5
		<< endl;

	return 0;
}

QTextStream& operator<<(QTextStream& out, const QStringList &sl)
{
	if (!sl.empty())
	{
		for (auto &i : sl)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
sl1: 1 1 1 1 1
sl2: 1 2 3 4 5 6
sl1.size = 5
sl1[1] = 1
sl2[2] = 3
sl2.front = 1
sl2.back = 6
sl3: Bill Murray Bill Clinton
sl4: a  b c
sl5: a b c
```

<h3 id="qset">QSet</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qset.h`。

众所周知，关联容器的查找速度相当快，所以在很多查找算法中都使用了关联容器。相比于`std::set`，**QSet 不对元素进行默认排序**，如果你一定要排序的话，可以使用`std::sort`。

QSet 的实现基于 QHash。**一个type要想使用 QSet，它必须提供一个默认构造函数、复制构造函数、一个赋值运算符、以及一个全局的qHash函数**，该函数返回一个传入type值的hash值。

**默认 QSet 可以使用的类型包含基础类型如int、double、指针等，以及 Qt 数据类型QString、QDate、QTime等，QObject 以及 任何其派生类(QWidget、QDialog、QTimer等)都不能使用 QSet**。如果你想对一种类型使用 QSet，你可以编译试验或者查看其实现是否满足条件，直接编译或许更快一点。

**在实现qHash函数时，对于一个给定值，任何时候调用此函数都应该返回相同的结果，对于不等的对象几乎总是产生不同的结果**。在`qtbase-5.9\src\corelib\tools`目录下的`qhashfunctions.h`和`qhash.cpp`中，你能看到相当多的qHash函数定义及实现，所有类型最终都转成了uint，uint的qHash实现如下：

```c++
inline uint qHash(uint key, uint seed = 0) Q_DECL_NOTHROW { return key ^ seed; }
```

qHash函数可以是以下四种签名的任何一种：

```c++
uint qHash(K key);
uint qHash(const K &key);

uint qHash(K key, uint seed);
uint qHash(const K &key, uint seed);
```

如果你每种都实现了，那么QHsh会使用两个参数的实现。仔细看源码，你会发现所有的qHash实现都没有使用单参数的签名方式，相对的，它们对第二个参数设置了默认值，这就相当于同时实现了单参数与双参数的qHash函数。再查看官方说明，**要想自定义一个qHash函数，还需要定义`operator==()`**。

下面我们就来实现一个自定义的类型，并使它满足 QSet 的使用条件：

```c++
#ifndef MYQSETTYPE_HPP
#define MYQSETTYPE_HPP

#include <QString>
#include <QDate>
#include <QHash>
#include <QTextStream>

class myQSetType
{
	QString name;
	QDate birth;
	int height;

public:
	myQSetType() = default;
	~myQSetType() = default;

	myQSetType(QString name_, QDate birth_, int height_)
		: name(name_), birth(birth_), height(height_)
	{}

	myQSetType(const myQSetType &other)
	{
		operator=(other);
	}

	myQSetType& operator=(const myQSetType &other)
	{
		if (this != &other)
		{
			name = other.name;
			birth = other.birth;
			height = other.height;
		}
		return *this;
	}

	inline QString getName() const
	{
		return name;
	}

	inline QDate getBirth() const
	{
		return birth;
	}

	inline int getHeight() const
	{
		return height;
	}
};

inline bool operator==(const myQSetType &t1, const myQSetType &t2)
{
	return t1.getName() == t2.getName() &&
		t1.getBirth() == t2.getBirth() &&
		t1.getHeight() == t2.getHeight();
}

inline uint qHash(const myQSetType &key, uint seed = 0)
{
	return qHash(key.getName(), seed) ^
		qHash(key.getBirth().toString("yyyyMMdd"), seed) ^
		key.getHeight();
}

QTextStream& operator<<(QTextStream& out, const myQSetType& t)
{
	out << "name: " << t.getName() << " "
		<< "borth: " << t.getBirth().toString("yyyyMMdd") << " "
		<< "height: " << t.getHeight();
	return out;
}

#endif // MYQSETTYPE_HPP
```

QSet 的使用方式也可以参照`std::set`来使用：

```c++
#include <QTextStream>
#include <QSet>

#include "myQSetType.hpp"

template <typename T>
QTextStream& operator<<(QTextStream& out, const QSet<T> &s);

int main(void)
{
	QTextStream out(stdout);

	QSet<myQSetType> qset;

	myQSetType s1("Bill Murray", QDate(1970, 1, 1), 180);
	myQSetType s2("John Doe", QDate(1993, 12, 5), 170);
	myQSetType s3("Bill Clinton", QDate(1993, 8, 18), 210);

	qset.insert(s1);
	qset.insert(s2);
	qset.insert(s3);

	out << qset
		<< qset.size() << "\n"
		<< *(qset.find(s1)) << "\n";

	qset.erase(qset.begin());
	out << qset
		<< qset.size() << "\n"
		<< (qset.end() == qset.find(s1)) << "\n";

	return 0;
}

template <typename T>
QTextStream& operator<<(QTextStream& out, const QSet<T> &s)
{
	if (!s.empty())
	{
		for (auto &i : s)
		{
			out << i << "\n";
		}
	}
	return out;
}
```

结果1：

```text
name: Bill Murray borth: 19700101 height: 180
name: Bill Clinton borth: 19930818 height: 210
name: John Doe borth: 19931205 height: 170
3
name: Bill Murray borth: 19700101 height: 180
name: Bill Clinton borth: 19930818 height: 210
name: John Doe borth: 19931205 height: 170
2
1
```

结果2：

```text
name: Bill Clinton borth: 19930818 height: 210
name: John Doe borth: 19931205 height: 170
name: Bill Murray borth: 19700101 height: 180
3
name: Bill Murray borth: 19700101 height: 180
name: John Doe borth: 19931205 height: 170
name: Bill Murray borth: 19700101 height: 180
2
0
```

从结果来看，**QSet 的元素是无序的**。

<h3 id="qmap">QMap</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qmap.h`和`qmap.cpp`。

QMap 是一个基于红黑树的词典，相对于 QHash 来说，**QMap 的平均查找速度略低于 QHash 的查找速度，QMap 的元素总是按其键值进行排序**，这意味着键类型必须提供一个比较运算符，根据官方说明，**这个运算符是小于符号**，比较运算符的要求是：对于两个值x、y，如果`x < y`和`y < x`都为假，那么`x == y`。

QMap 默认一个键只能对应一个值，当你在添加已存在的键值对时，原来的键值对会被移除。但是 QMap 提供了一个成员函数`insertMulti`使得你可以为一个键提供多个值，然后你可以通过成员函数`values`来获取该键对应的值的 QList，你也可以使用 QMap 的继承类 QMultiMap，该类只是将`insert`的实现移交到了`insertMulti`，仅此而已。

通过上面的了解，我们应当注意到 QMultiMap 与 `std::multimap`的不同，前者是一个键对多个值，后者是可以拥有多个键，但是每个键只能对应一个值。

**要想一个type能够作为 QMap 的键，该type必须提供一个默认构造函数、复制构造函数、赋值运算符、和一个非成员小于运算符**。

将上面的 myQSetType 重构为支持 QMap 的自定义类型：

```c++
#ifndef MYQSETTYPE_HPP
#define MYQSETTYPE_HPP

#include <QString>
#include <QDate>
#include <QHash>
#include <QTextStream>

class myQSetType
{
	QString name;
	QDate birth;
	int height;

public:
	myQSetType() = default;
	~myQSetType() = default;

	myQSetType(QString name_, QDate birth_, int height_)
		: name(name_), birth(birth_), height(height_)
	{}

	myQSetType(const myQSetType &other)
	{
		operator=(other);
	}

	myQSetType& operator=(const myQSetType &other)
	{
		if (this != &other)
		{
			name = other.name;
			birth = other.birth;
			height = other.height;
		}
		return *this;
	}

	inline QString getName() const
	{
		return name;
	}

	inline QDate getBirth() const
	{
		return birth;
	}

	inline int getHeight() const
	{
		return height;
	}
};

inline bool operator<(const myQSetType &t1, const myQSetType &t2)
{
	return t1.getBirth() < t2.getBirth() ||
		(t1.getBirth() == t2.getBirth() && t1.getName() < t2.getName()) ||
		(t1.getBirth() == t2.getBirth() && t1.getName() == t2.getName() && t1.getHeight() < t2.getHeight());
}

QTextStream& operator<<(QTextStream& out, const myQSetType& t)
{
	out << "name: " << t.getName() << " "
		<< "borth: " << t.getBirth().toString("yyyyMMdd") << " "
		<< "height: " << t.getHeight();
	return out;
}

#endif // MYQSETTYPE_HPP
```

QMap 的使用方式也可以参照`std::map`来使用：

```c++
#include <QTextStream>
#include <QMap>

#include "myQSetType.hpp"

template <typename KEY, typename VALUE>
QTextStream& operator<<(QTextStream& out, const QMap<KEY, VALUE> &m);

int main(void)
{
	QTextStream out(stdout);

	myQSetType s1("Bill Murray", QDate(1970, 1, 1), 180);
	myQSetType s2("John Doe", QDate(1993, 12, 5), 170);
	myQSetType s3("Bill Clinton", QDate(1993, 12, 5), 210);

	QMap<myQSetType, QString> qmap
	{
		{ s1,"Bill Murray" },
		{ s2,"John Doe" },
		{ s3,"Bill Clinton" }
	};
	qmap.clear();
	qmap.insert(s1, "Bill Murray");
	qmap[s2] = "John Doe";
	qmap.insertMulti(s3, "Bill Clinton");

	out << qmap
		<< qmap.size() << "\n"
		<< *(qmap.find(s1)) << "\n"
		<< endl;

	qmap.erase(qmap.begin());
	out << qmap
		<< qmap.size() << "\n"
		<< (qmap.end() == qmap.find(s1)) << "\n"
		<< endl;

	QList<QString> s3Values = qmap.values(s3);
	out << s3Values.size() << endl;

	return 0;
}

template <typename KEY, typename VALUE>
QTextStream& operator<<(QTextStream& out, const QMap<KEY, VALUE> &m)
{
	if (!m.empty())
	{
		QList<KEY> keys = m.keys();
		QList<VALUE> values = m.values();

		out << "keys: \n";
		for (auto &i : keys)
		{
			out << i << "\n";
		}

		out << "values: \n";
		for (auto &i : values)
		{
			out << i << "\n";
		}
	}
	return out;
}
```

结果：

```text
keys:
name: Bill Murray borth: 19700101 height: 180
name: Bill Clinton borth: 19931205 height: 210
name: John Doe borth: 19931205 height: 170
values:
Bill Murray
Bill Clinton
John Doe
3
Bill Murray

keys:
name: Bill Clinton borth: 19931205 height: 210
name: John Doe borth: 19931205 height: 170
values:
Bill Clinton
John Doe
2
1

1
```

<h2 id="io">IO</h2>

Qt5 中处理文件的基本类是 QFile、QDir 和 QFileInfo。其中 QFile 用来读写文件，QDir 用来访问文件夹，QFileInfo 用来获取文件的相关信息(如路径、文件名、修改时间、权限等)。

Qt5 的输出流一般使用 QDebug，你也可以使用 QTextStream 或 QDataStream 同时处理输入输出。

<h3 id="qfile">QFile</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qfile.h`和`qfile.cpp`。

我们先回想一下`std::fstream`是如何对文件进行读写的，然后顺着这个思路去看 QFile 是如何对应的：

*	首先，`std::fstream`由默认构造函数，QFile 也有；
*	`std::fstream`可以传递一个文件名构造并打开该文件，QFile 也有，但是 **QFile 只支持带正斜杠`/`的文件名**；
*	`std::fstream`可以使用成员函数`open`打开一个文件并设置打开模式，QFile 没有，但可以组合其成员函数`setFileName`和`open`来达到这一效果；
*	`std::fstream`可以使用成员函数`is_open`来检验文件是否成功打开，QFile 有`isOpen`；
*	`std::fstream`可以使用成员函数`close`来关闭打开的文件，QFile 也有；
*	`std::fstream`的析构函数会自动调用`close`，QFile 也是；
*	`std::fstream`可以使用非成员函数`getline`来从流中获取一行数据，QFile 有成员函数`readLine`；
*	`std::fstream`可以使用运算符`>>`和`<<`进行读写，QFile 可以使用`read`和`write`，另外你还可以绑定 QFile 到[QDataStream](#qdatastream)或[QTextStream](#qtextstream)来获得使用`>>`和`<<`读写的功能；
*	`std::fstream`可以使用成员函数`eof`来检测是否到达文件结尾，QFile 有`atEnd`；

我们知道`std::fstream`是没有直接获取文件大小的函数的，但 QFile 的成员函数`size`实现了这个功能，**在Unix下一些特别的系统文件(如`/proc`)的`size`总是返回0，`atEnd`也会一直返回true，但是你却可以从中读取到数据**，这时候你就需要这么做：

```c++
QFile file("/proc/modules");
if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
	return;

QTextStream in(&file);
QString line = in.readLine();
while (!line.isNull()) {
	process_line(line);
	line = in.readLine();
}
```

上面的代码来自官方文档，通过该代码，我们知道 QFile 的文件打开模式在 QIODevice 中定义，所以我们查看`qiodevice.h`：

```c++
enum OpenModeFlag {
	NotOpen = 0x0000,
	ReadOnly = 0x0001,
	WriteOnly = 0x0002,
	ReadWrite = ReadOnly | WriteOnly,
	Append = 0x0004,
	Truncate = 0x0008,
	Text = 0x0010,
	Unbuffered = 0x0020
};
```

通过上面的对比学习，我们来做一个演示：

```c++
#include <QTextStream>
#include <QFile>
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);
	QString filename("test.txt");

	QFile file;
	file.setFileName(filename);
	file.open(QIODevice::ReadWrite);
	if (!file.isOpen())
	{
		out << "open " << filename << "failed.\n";
		return 1;
	}

	file.write("line1 line1 line1\n");
	file.write("line2 line2 line2\n");
	file.write("line3 line3 line3\n");
	file.seek(0);

	QString str1 = file.read(11);
	QString str2 = file.read(12);
	QString str3 = file.readLine();
	QString str4 = file.readAll();
	bool isEnd = file.atEnd();
	qint64 size = file.size();

	file.close();

	out << "str1: " << str1 << "\n"
		<< "str2: " << str2 << "\n"
		<< "str3: " << str3 << "\n"
		<< "str4: " << str4 << "\n"
		<< isEnd << "\n"
		<< size << endl;

	return 0;
}
```

结果：

```text
str1: line1 line1
str2:  line1
line2
str3:  line2 line2

str4: line3 line3 line3

1
54
```

<h3 id="qdir">QDir</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qdir.h`和`qdir.cpp`。

标准库没有处理文件夹的类，但是网上有很多自己实现的类，你可以在[这里](https://stackoverflow.com/questions/612097/how-can-i-get-the-list-of-files-in-a-directory-using-c-or-c)得到相当多的建议。

QDir 也使用正斜杠`/`作为其目录分隔符，并且支持相对路径，你可以使用其成员函数`isRelative()`或`isAbsolute()`来判断使用的路径的是相对的还是绝对的，你甚至可以使用成员函数`makeAbsolute`从一个相对路径得到一个绝对路径。

QDir 有一些相似shell命令行的函数，如`mkdir`、`rmdir`、`cd`；一些有用的非静态成员函数：

*	`exists`；
*	`isReadable`；
*	`count`：获取当前目录下的文件夹和文件总数；
*	`entryList`：获取当前目录下的文件夹和文件名列表；
*	`entryInfoList`：获取当前目录下的文件夹和文件信息列表；
*	`remove`：删除文件；
*	`setFilter`：文件类型过滤器，影响`entryList`和`entryInfoList`；
*	`setNameFilters`：文件名过滤器，影响`entryList`和`entryInfoList`；
*	`setSorting`：设置文件排序顺序，如按大小排列、按修改时间排列等，影响`entryList`和`entryInfoList`；
*	`filePath`：返回当前目录下的指定文件名的路径，不检查其是否存在，如果当前目录是相对的，返回的路径也是相对的；
*	`absoluteFilePath`：返回当前目录下的指定文件名的绝对路径，不检查其是否存在。

一些静态成员函数：

QDir | QString | 返回值
--------------- | -------------- | ------------------------
current() | currentPath() | 当前工作目录 <br>你可以使用`setCurrent`来设置当前工作目录
home() | homePath() | 当前用户目录
root() | rootPath() | 根目录
temp() | tempPath() | 系统临时文件夹

演示：

```c++
#include <QTextStream>
#include <QDir>
#include <QFile>

QTextStream& operator<<(QTextStream& out, const QStringList &sl);

int main(void)
{
	QTextStream out(stdout);
	QString dir_name("directory");

	out << "current: " << QDir::currentPath() << "\n"
		<< "home: " << QDir::homePath() << "\n"
		<< "root: " << QDir::rootPath() << "\n"
		<< "temp: " << QDir::tempPath() << endl;

	QDir temp(QDir::temp());
	if (!temp.exists())
	{
		out << QDir::tempPath()
			<< "is not exist.\n";
		return 1;
	}
	if (!temp.isReadable())
	{
		out << QDir::tempPath()
			<< "is not readable.\n";
		return 1;
	}
	if (!temp.exists(dir_name))
	{
		temp.mkdir(dir_name);
	}

	temp.cd(dir_name);
	QString dir_path = temp.absolutePath();
	out << "after cd(\"directory\"): "
		<< dir_path << endl;
	temp.cd("..");
	out << "after cd(\"..\"): "
		<< temp.absolutePath() << endl;
	temp.setPath(dir_path);

	QString subDir("dir%1");
	QString subFile("file%1");
	for (int i = 1; i <= 3; ++i)
	{
		QString tmp_dir = subDir.arg(i);
		temp.mkdir(tmp_dir);

		QString tmp_file = subFile.arg(i);
		QFile file(temp.filePath(tmp_file));
		file.open(QIODevice::WriteOnly);
	}
	out << "after created: \n"
		<< temp.entryList()
		<< endl;

	temp.rmdir("dir2");
	temp.remove("file2");

	out << "after removed: \n";
	out << "dirs: ";
	temp.setFilter(QDir::Dirs);
	temp.setSorting(QDir::Name | QDir::Reversed);
	out << temp.entryList() << "\n";
	out << "files: ";
	temp.setFilter(QDir::Files);
	temp.setSorting(QDir::Name | QDir::Reversed);
	out << temp.entryList() << "\n";

	return 0;
}

QTextStream& operator<<(QTextStream& out, const QStringList &sl)
{
	if (!sl.empty())
	{
		for (auto &i : sl)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
current: E:/qt_project
home: C:/Users/pengzhen
root: C:/
temp: C:/Users/pengzhen/AppData/Local/Temp
after cd("directory"): C:/Users/pengzhen/AppData/Local/Temp/directory
after cd(".."): C:/Users/pengzhen/AppData/Local/Temp
after created:
. .. dir1 dir2 dir3 file1 file2 file3
after removed:
dirs: dir3 dir1 .. .
files: file3 file1
```

<h3 id="qfileinfo">QFileInfo</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qfileinfo.h`和`qfileinfo.cpp`。

前面我们说过，QFileInfo 提供关于文件或文件夹的相关信息，它可以使用绝对路径，又可以使用相对路径，你可以使用成员函数`isRelative`进行确认，也可以使用成员函数`makeAbsolute`从一个相对路径得到一个绝对路径。

查看其头文件，你会发现其实它能用的函数并不多：

```c++
QFileInfo(const QString &file);
QFileInfo(const QFile &file);
QFileInfo(const QDir &dir, const QString &file);
void setFile(const QString &file);
void setFile(const QFile &file);
void setFile(const QDir &dir, const QString &file);
bool exists() const;
static bool exists(const QString &file);
void refresh(); // 刷新文件信息
QString fileName() const;
QString filePath() const;
QString absoluteFilePath() const;
QString suffix() const; // 返回文件名最后一个.后所有字符
QString completeSuffix() const; // 返回文件名第一个.后所有字符
bool isReadable() const;
bool isWritable() const;
bool isExecutable() const;
bool isHidden() const;
bool isFile() const;
bool isDir() const;
bool isSymLink() const;
QString readLink() const;
qint64 size() const;
QDateTime created() const;
QDateTime lastModified() const;
QDateTime lastRead() const;
QString owner() const;
QString group() const;
bool permission(QFile::Permissions permissions) const;
QFile::Permissions permissions() const;
```

其中`owner`、`group`、`permissions`在NTFS文件系统上的返回值是不准确的，因为NTFS系统默认禁用了所有权的权限的检查，要想启用它，你需要：

```c++
extern Q_CORE_EXPORT int qt_ntfs_permission_lookup;
qt_ntfs_permission_lookup++; // turn checking on
qt_ntfs_permission_lookup--; // turn it off again
```

查看`qfile.h`，再转到`qfiledevice.h`：

```c++
enum Permission {
	ReadOwner = 0x4000, WriteOwner = 0x2000, ExeOwner = 0x1000,
	ReadUser  = 0x0400, WriteUser  = 0x0200, ExeUser  = 0x0100,
	ReadGroup = 0x0040, WriteGroup = 0x0020, ExeGroup = 0x0010,
	ReadOther = 0x0004, WriteOther = 0x0002, ExeOther = 0x0001
};
```

演示：

```c++
#include <QTextStream>
#include <QFileInfo>
#include <QDir>
#include <QFile>
#include <QDateTime>

extern Q_CORE_EXPORT int qt_ntfs_permission_lookup;

int main(void)
{
	qt_ntfs_permission_lookup++; // turn checking on
	QTextStream out(stdout);

	QFileInfo fileinfo1("release/qt_project.exe");
	QFileInfo fileinfo2(QDir::current(), "main.cpp");

	out << "path: "
		<< fileinfo1.filePath() << "\n"
		<< fileinfo2.filePath() << "\n"
		<< "name: "
		<< fileinfo1.fileName() << " "
		<< fileinfo2.fileName() << "\n"
		<< "exists: "
		<< fileinfo1.exists() << " "
		<< fileinfo2.exists() << "\n"
		<< "suffix: "
		<< fileinfo1.suffix() << " "
		<< fileinfo2.suffix() << "\n"
		<< "created: "
		<< fileinfo1.created().toString(Qt::ISODate) << " "
		<< fileinfo2.created().toString(Qt::ISODate) << "\n"
		<< "owner: "
		<< fileinfo1.owner() << " "
		<< fileinfo2.owner() << "\n"
		<< "permissions: "
		<< fileinfo1.permission(QFile::ExeUser) << " "
		<< fileinfo2.permission(QFile::ExeUser)
		<< endl;

	return 0;
}
```

结果：

```text
path: release/qt_project.exe
E:/qt_project/main.cpp
name: qt_project.exe main.cpp
exists: 1 1
suffix: exe cpp
created: 2017-07-21T12:24:37 2017-07-14T15:16:35
owner: pengzhen pengzhen
permissions: 1 1
```

<h3 id="qtextstream">QTextStream</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qtextstream.h`和`qtextstream.cpp`。

QTextStream 是 Qt 用来读写文本的流，查看其头文件，QTextStream 可以对 QIODevice、`FILE*`、QString 和 QByteArray进行操作。我们知道 QFile 继承自 QIODevice，所以 QTextStream 可以在 QFile 上进行操作；我们之前一直在使用`stdout`，它到底是个什么类型呢，在`C:\Program Files (x86)\Windows Kits\10\Include\10.0.15063.0\ucrt\corecrt_wstdio.h`中我们找到：

```c++
_ACRTIMP_ALT FILE* __cdecl __acrt_iob_func(unsigned _Ix);

#define stdin  (__acrt_iob_func(0))
#define stdout (__acrt_iob_func(1))
#define stderr (__acrt_iob_func(2))
```

所以`stdin`、`stdout`、`stderr`都是`FILE*`类型，所以可以使用 QTextStream 进行操作。

我们知道`std::iostream`有很多格式化控制符，如`hex`、`boolalpha`、`flush`、`ends`、`endl`等等，QTextStream 也有很多这样的控制符：

控制符(*前缀代表默认) | 说明
------------------------ | -----------------------------------
bin | 整型值设置为二进制
oct | 整型值设置为八进制
*dec | 整型值设置为十进制
hex | 整型值设置为十六进制
showbase | 对整型值输出表示进制的前缀 <br> 二进制：0b，八进制：0，十六进制：0x
*noshowbase | 不输出表示进制的前缀
forcesign | 总是显示正负号
*noforcesign | 需要时显示负号
forcepoint | 总是显示小数分隔符
*noforcepoint | 需要时显示小数分隔符
uppercasebase | 使用大写的进制前缀 <br> 二进制：0B，八进制：0，十六进制：0X
*lowercasebase | 使用小写的进制前缀 <br> 二进制：0b，八进制：0，十六进制：0x
uppercasedigits | 使用大写字母表示10~35
lowercasedigits | 使用小写字母表示10~35
fixed | 浮点值显示为定点十进制，e小写
scientific | 科学计数法，e小写
left | 左对齐
right | 右对齐
center | 中对齐
endl | 输出换行，并刷新缓冲区
flush | 刷新缓冲区
reset | 重置格式选项，返回到原始状态
ws | 按字符读取时丢弃空白字符
bom | 如果使用UTF解码器，那么每次写入数据时会插入BOM

除了上面的控制符外，QTextStream 还提供了`setFieldWidth`来设定每次输出宽度、`setPadChar`来设定填充字符、`setRealNumberPrecision`来设定输出数字的精度，默认是6。

QTextStream 默认使用unicode编码，你也可以使用成员函数`setCodec`手动设置(**操作QString时无效**)。在输入输出时，你可以使用流运算符`<<`和`>>`，你也可以使用成员函数`read`、`readLine`和`readAll`。

仿照[QFile 中的演示](#qfile)，最后再加一些格式控制：

```c++
#include <QTextStream>
#include <QFile>

int main(void)
{
	QTextStream out(stdout);
	QString filename("test.txt");

	QFile file(filename);
	file.open(QIODevice::ReadWrite);
	if (!file.isOpen())
	{
		out << "open " << filename << "failed.\n";
		return 1;
	}

	QTextStream fStream(&file);
	fStream << "line1 line1 line1\n"
		<< "line2 line2 line2\n"
		<< "line3 line3 line3\n";
	fStream.seek(0);

	QString str1 = fStream.read(11);
	QString str2 = fStream.read(12);
	QString str3 = fStream.readLine();
	QString str4 = fStream.readAll();
	bool isEnd = file.atEnd();
	qint64 size = file.size();

	fStream.flush();
	file.close();

	out << "str1: " << str1 << "\n"
		<< "str2: " << str2 << "\n"
		<< "str3: " << str3 << "\n"
		<< "str4: " << str4 << "\n"
		<< isEnd << "\n"
		<< size << endl;

	QTextStream sStream("0x50 0x20");
	int num1, num2, num3;
	char ch;
	sStream >> num1
		>> dec >> num2
		>> ch >> num3;

	out.setFieldWidth(10);
	out.setPadChar('*');
	out << left << hex << showbase << num1;
	out.setPadChar('-');
	out.setFieldWidth(5);
	out << "\n"
		<< dec << num2 << "\n"
		<< right
		<< ch << "\n"
		<< num3 << endl;

	return 0;
}
```

结果：

```text
str1: line1 line1
str2:  line1
line2
str3:  line2 line2
str4: line3 line3 line3

1
54
0x50******
----0----
--------x----
---20----
```

通过与 QFile 中的结果对比，我们发现 **QTextStream 的`readLine`会丢弃换行符**，而 QFile 的不会；QTextStream 的`size`与其流的位置无关；**QTextStream 会根据流中的数据自动检测基数**；**如果设定输出宽度大于1，那么输出换行符会输出输出宽度减1个填充字符**。

<h3 id="qdatastream">QDataStream</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qdatastream.h`和`qdatastream.cpp`。

QDataStream 支持 QIODevice 和 QByteArray，它提供二进制数据的序列化。查看[这篇文章](http://blog.csdn.net/feiyinzilgd/article/details/6107587)，大概了解了**QDataStream 与 QTextStream 唯一的不同就是它提供了数据的序列化，这样在传输数据和解析数据时会更加方便**。

<h3 id="qdebug">QDebug</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qdebug.h`和`qdebug.cpp`。

QDebug 提供调试信息的输出流，其有五个全局的默认实例定义：

```c++
#define qDebug QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).debug
#define qInfo QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).info
#define qWarning QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).warning
#define qCritical QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).critical
#define qFatal QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).fatal
```

你可以简单的像printf一样使用，也可以像流一样使用：

```c++
#include <QDebug>

int main(void)
{
	qInfo() << "C++ Style Info Message";
	qInfo("C Style Info Message");

	qDebug() << "C++ Style Debug Message";
	qDebug("C Style Debug Message");

	qWarning() << "C++ Style Warning Message";
	qWarning("C Style Warning Message");

	qCritical() << "C++ Style Critical Error Message";
	qCritical("C Style Critical Error Message");

	// qFatal does not have a C++ style method.
	qFatal("C Style Fatal Error Message");

	return 0;
}
```

**定义`QT_NO_WARNING_OUTPUT`或`QT_NO_DEBUG_OUTPUT`会屏蔽掉qWarning或qDebug的输出**。

**一般在Qt中打印输出信息时，都会使用 QDebug**。

<h2 id="qt_widget">Qt 部件</h2>

<h3 id="qapplication">QApplication</h3>

你可以在`qtbase-5.9\src\widgets\kernel`目录下找到`qapplication.h`和`qapplication.cpp`。

QApplication 管理GUI应用的控制流和主要设置，它继承自 QGUIApplication，实现了一些基于 QWidget 的应用程序所需要的功能。**使用Qt的任何GUI应用，都需要一个 QApplication 对象，不管该应用有多少个窗口**。**对于非基于 QWidget 的Qt应用，可以使用 QGUIApplication 代替**，因为 QGUIApplication 不依赖于 QtWidget 库。

一些GUI应用提供特殊的批处理模式，如根据提供的命令行参数执行相关任务而不能人工干预，在这种非GUI模式下，**只需要实例化一个简单的 QCoreApplication 就足够了**，这避免了不必要的图形用户界面所需资源的初始化，官方示例如下：

```c++
QCoreApplication* createApplication(int &argc, char *argv[])
{
	for (int i = 1; i < argc; ++i)
		if (!qstrcmp(argv[i], "-no-gui"))
			return new QCoreApplication(argc, argv);
	return new QApplication(argc, argv);
}

int main(int argc, char* argv[])
{
	QScopedPointer<QCoreApplication> app(createApplication(argc, argv));

	if (qobject_cast<QApplication *>(app.data())) {
		// start GUI version...
	}
	else {
		// start non-GUI version...
	}

	return app->exec();
}
```

查看 QCoreApplication、QGUIApplication、QApplication 源码，你会发现一个名为`qApp`的预定义变量：

```c++
// QCoreApplication.h
#define qApp QCoreApplication::instance()
static QCoreApplication *instance() { return self; }
static QCoreApplication *self;

// QGUIApplication.h
#if defined(qApp)
#undef qApp
#endif
#define qApp (static_cast<QGuiApplication *>(QCoreApplication::instance()))

// QApplication.h
#if defined(qApp)
#undef qApp
#endif
#define qApp (static_cast<QApplication *>(QCoreApplication::instance()))
```

通过上面的源码我们知道，该qApp指向当前 QCoreApplication 系列实例。

QApplication 的主要责任有：

*	使用用户的桌面设置初始化应用；
*	执行事件处理；
*	解析常见的命令行参数，从而设置相应的内部状态；
*	定义应用的外观和感觉；
*	指定应用如何分配颜色；
*	字符串的本地化；
*	提供了一些神奇的实例，如`desktop()`和`clipboard()`
*	掌控所有窗口的部件位置；
*	管理应用的鼠标光标处理；

由于 QApplication 做了这么多初始化，所以**它必须在创建与用户界面相关的任何其他对象之前被创建**。

<h3 id="qwidget">QWidget</h3>

你可以在`qtbase-5.9\src\widgets\kernel`目录下找到`qwidget.h`和`qwidget.cpp`。

QWidget 是所有用户界面对象的基类，QDialog、QMainWindow、QLabel、QPushButton、QListWidget等都是它的子类。查看其公有构造函数：

```c++
explicit QWidget(QWidget* parent = Q_NULLPTR, Qt::WindowFlags f = Qt::WindowFlags());
```

当不传入参数或传入的第一个参数为空时，表示该部件是一个窗口，也被称为顶层部件(top-level widget)，你可以使用成员函数`setWindowTitle`来设置标题栏，`setWindowIcon`来设置窗口图标。**QMainWindow 和 QDialog 的各种子类是Qt中最常用的窗口类型**。

当传入的第一个参数不为空时，表示该部件是传入参数的一个子部件，**当父部件被删除时，所有该父部件的子部件都将被删除**。**当你为一个可视部件添加一个子部件时，要想子部件变得可见，你必须显式调用成员函数`show()`**。

关于第二个参数，你可以在`qtbase-5.9\src\corelib\global\qnamespace.h`中找到`enum WindowType`，它随后被声明为`WindowFlags`；该参数被用来指定部件的各种窗口系统属性，它们通常不怎么被使用，你可以查看[官方文档](http://doc.qt.io/qt-5/qt.html#WindowType-enum)了解各种标志的意义。

QWidget 包含[相当多的功能和属性](http://doc.qt.io/qt-5/qwidget.html#groups-of-functions-and-properties)，其中最常用的就是事件处理。**要想进行事件处理，你必须继承 QWidget，然后重新定义相关的事件处理函数**，下面就来做一些演示：

我们首先继承 QWidget，定义一个 myWidget 新类，该类重定义了相当多的事件：

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDebug>
#include <QWidget>
#include <QString>
#include <QMouseEvent>

class myWidget :public QWidget
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QWidget(parent)
	{}

private:
#define eventOccured qDebug() << __func__ << " called."

protected:
	// 鼠标按下、移动、释放、双击、滚轮滚动事件
	void mousePressEvent(QMouseEvent* event) override;
	void mouseMoveEvent(QMouseEvent*) override { eventOccured; };
	void mouseReleaseEvent(QMouseEvent*) override { eventOccured; };
	void mouseDoubleClickEvent(QMouseEvent*) override { eventOccured; };
	void wheelEvent(QWheelEvent*) override { eventOccured; };

	// 键盘按下、释放事件
	void keyPressEvent(QKeyEvent*) override { eventOccured; };
	void keyReleaseEvent(QKeyEvent*) override { eventOccured; };

	// 鼠标光标进入部件区域、离开部件区域事件
	void enterEvent(QEvent*) override { eventOccured; };
	void leaveEvent(QEvent*) override { eventOccured; };

	// 部件移动事件
	void moveEvent(QMoveEvent*) override { eventOccured; };

	// 绘制事件，当update()或repaint()被调用或组件需要被绘制时发生
	void paintEvent(QPaintEvent*) override { eventOccured; };

	// 组件大小发生了变化
	void resizeEvent(QResizeEvent*) override { eventOccured; };

	// 组件被关闭了
	void closeEvent(QCloseEvent*) override { eventOccured; };
};

// ！！！注意：不加inline会报错，这与Q_OBJECT有关
inline void myWidget::mousePressEvent(QMouseEvent* event)
{
	QString button;
	switch (event->button())
	{
	case Qt::LeftButton:
		button = "LeftButton"; break;
	case Qt::RightButton:
		button = "RightButton"; break;
	case Qt::MidButton:
		button = "MidButton"; break;
	default:
		return;
	}
	qDebug() << button << " clicked.";
}

#endif // MYWIDGET_HPP
```

然后在main.cpp中使用它：

```c++
#include <QApplication>
#include "myWidget.hpp"

int main(int argc, char *argv[]) 
{
	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("event handlers");
	window.show();

	return app.exec();
}
```

重新构建工程`qmake -project`，在生成的`.pro`文件后添加：

```text
QT += widgets
CONFIG += console
```

其中widgets用来显示部件、console用来在命令行下输出打印信息。

触发相应事件，得到打印输出如下：

```text
moveEvent  called.
resizeEvent  called.
paintEvent  called.
enterEvent  called.
leaveEvent  called.
moveEvent  called.
moveEvent  called.
moveEvent  called.
enterEvent  called.
"LeftButton"  clicked.
mouseReleaseEvent  called.
mouseDoubleClickEvent  called.
mouseReleaseEvent  called.
wheelEvent  called.
"MidButton"  clicked.
mouseReleaseEvent  called.
"RightButton"  clicked.
mouseReleaseEvent  called.
leaveEvent  called.
resizeEvent  called.
paintEvent  called.
resizeEvent  called.
paintEvent  called.
resizeEvent  called.
paintEvent  called.
keyPressEvent  called.
keyReleaseEvent  called.
keyPressEvent  called.
keyReleaseEvent  called.
enterEvent  called.
"LeftButton"  clicked.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseReleaseEvent  called.
leaveEvent  called.
closeEvent  called.
```
