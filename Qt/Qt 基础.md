---
title:      "Qt5 基础"
subtitle:   "Hello Qt5"
date:       2017-07-14 20:20:00 +0800
header-img: "img/stock-photo-8.jpg"
tags:
    - C++
    - Qt5
---

本文知识来自[zetcode](http://zetcode.com/gui/qt5/)，介绍有关 Qt5 的基础知识。**在开始学习前，你应该能够熟练使用C++**，如果不是，建议看看[C++ 释疑篇](https://chorior.github.io/2017/03/01/C++-%E9%87%8A%E7%96%91-%E4%B8%80/)。

#   本文结构

*   [Qt 概述](#overview)
*	[Hello World](#hello_world)
*	[QString](#qstring)
*	[QDate, QTime and QDateTime](#qdate_qtime_and_qdatetime)
	*	[QDate](#qdate)
	*	[QTime](#qtime)
	*	[QDateTime](#qdatetime)
*	[Qt 容器](#qt_containers)
	*	[QVector](#qvector)
	*	[QList](#qlist)
	*	[QStringList](#qstringlist)
	*	[QSet](#qset)
	*	[QMap](#qmap)
*	[IO](#io)
	*	[QFile](#qfile)
	*	[QDir](#qdir)
	*	[QFileInfo](#qfileinfo)
	*	[QTextStream](#qtextstream)
	*	[QDataStream](#qdatastream)
	*	[QDebug](#qdebug)
*	[Qt 部件](#qt_widget)
	*	[QApplication](#qapplication)
	*	[QWidget](#qwidget)
	*	[QMenu](#qmenu)
	*	[QToolBar](#qtoolbar)
	*	[常用小部件](#qt_common_widgets)
	*	[QSplitter](#qsplitter)
	*	[QProgressBar](#progressbar)
	*	[QPainter](#qpainter)
	*	[QGraphicsScene、QGraphicsView、QGraphicsItem](#qgraphicsscene_qgraphicsview_qgraphicsitem)
*	[部件容器](#widget_containers)
	*	[QGroupBox](#qgroupbox)
	*	[QScrollArea](#qscrollarea)
	*	[QToolBox](#qtoolbox)
	*	[QTabWidget](#qtabwidget)
	*	[QStackedWidget](#qstackedwidget)
	*	[QFrame](#qframe)
	*	[QMdiArea](#qmdiarea)
	*	[QDockWidget](#qdockwidget)
*	[各种 layout](#layout)
	*	[QVBoxLayout、QHBoxLayout](#qvboxlayout_qhboxlayout)
	*	[QGridLayout](#qgridlayout)
	*	[QFormLayout](#qformlayout)
*	[各种 view](#view)
	*	[模型与模型索引](#model_and_model_index)
	*	[QListView、QTreeView、QTableView、QColumnView](#qlistview_qtreeview_qtableview_qcolumnview)
	*	[QListWidget、QTreeWidget、QTableWidget](#qlistwidget_qtreewidget_qtablewidget)

<h2 id="overview">Qt 概述</h2>

Qt 是一个跨平台的应用开发框架，它被广泛用于开发GUI应用，一些著名的软件，如Opera、Google Earth 和 Skype都是基于它进行开发的，你可以用它创建开源应用程序以及商业应用程序。相对于只支持Windows的MFC来说，虽然MFC更为强大，但是MFC的封装不是很好，很多地方很乱很杂(来自网络)，Qt除了跨平台之外，各个组件也封装得非常好，这意味着使用Qt你将更容易的编写程序。

Qt 一般使用C++进行开发，通过语言绑定，也可以使用其它语言。

Qt开放源代码，你可以在[Qt github](https://github.com/qt)上获取；其提供三种授权方式：

*	商业版：可以任意的修改源代码而不必公开，适用于开发专属或商业软件；
*	GNU LGPL：可以被专属软件作为类库引用、发布和销售；
*	GNU GPL：可以自由运行，学习，共享和修改。

<h2 id="hello_world">Hello World</h2>

在安装 Qt 并设置好Path之后，我们来做一个Hello World。

首先，我们创建一个文件夹，例如`E:\qt_project`，然后创建一个main.cpp:

```c++
#include <QApplication>
#include <QWidget>

int main(int argc, char *argv[]) {
    
    QApplication app(argc, argv);

    QWidget window;

    window.resize(250, 150);
    window.setWindowTitle("Hello World");
    window.show();

    return app.exec();
}
```

然后打开qt命令行：

```bash
$ cd E:\qt_project
$ qmake -project
```

这时会生成一个`.pro`文件：

```text
######################################################################
# Automatically generated by qmake (3.1) Fri Jul 14 15:19:47 2017
######################################################################

TEMPLATE = app
TARGET = qt_project
INCLUDEPATH += .

# Input
SOURCES += main.cpp
```

由于默认情况下并不会包含Qt Widgets，所以手动在最后面加上`QT += widgets`，然后执行：

```bash
$ qmake
$ mingw32-make
```

这里默认执行的是`mingw32-make -f Makefile.Release`，你也可以手动执行`mingw32-make -f Makefile.Debug`，然后你会在相应文件夹下看到可运行的exe，运行之后可以看到一个标题为Hello World的空白窗口。

<h2 id="qstring">QString</h2>

QString类是Qt自行封装的专门用于处理字符串的类，**其实例保存一个Unicode字符串，该字符串由16bit QChar组成，每个QChar对应一个Unicode4.0字符**。Unicode是US-ASCII(ANSI X3.4-1986)和Latin-1(ISO 8859-1)的超集。

除QString外，Qt还提供了QByteArray来存储原始字节（包括"\0"）和传统的8位"\0"端接字符串，**使用QByteArray比使用`const char *`更方便**，它确保数据后跟"\0"终止符。当你需要存储原始二进制数据，或者当内存保护至关重要时（例如，使用嵌入式Linux的Qt），使用QByteArray会比较适合。

下载[qt base](https://github.com/qt/qtbase)源代码，你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qstring.h`和`qstring.cpp`。

### QString 构造

```c++
// main.cpp
#include <QTextStream>
#include <string>

int main(void)
{
	QTextStream out(stdout);

	const char* ch = "hahaha";
	std::string std_str("adfa");

	QString s1;
	QString s2(ch);
	QString s3(QString::fromStdString(std_str));

	out << (NULL == s1) << "\n"
		<< s2 << "\n"
		<< s3 << endl;

	return 0;
}
```

由于我们不需要gui，也不需要widgets，所以在生成`.pro`文件之后，在最后加上`QT -= gui`，因为需要在控制台上进行输出，所以再加上`CONFIG += console`，编译之后运行：

```text
1
hahaha
adfa
```

### 添加、访问、删除

```c++
// main.cpp
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);

	QString s1;

	Q_ASSERT(s1.isEmpty());
	Q_ASSERT(s1.isNull());

	s1.append("34");
	out << "append: " << s1 << "\n";

	s1.prepend("12");
	out << "prepend: " << s1 << "\n";

	s1 += "56";
	out << "+=: " << s1 << "\n";

	s1.insert(2, "333");
	out << "insert: " << s1 << "\n";

	s1.replace(2, 3, "777");
	out << "replace: " << s1 << "\n";

	s1.remove(2, 3);
	out << "remove: " << s1 << "\n";

	s1.push_back("789");
	out << "push_back: " << s1 << "\n";

	s1.push_front("0");
	out << "push_front: " << s1 << endl;

	out << s1 << "\n"
		<< "size: " << s1.size() << "\n"
		<< "length: " << s1.length() << "\n"
		<< "count: " << s1.count() << endl;

	for (int i = 0; i < s1.size(); ++i)
	{
		out << s1.at(i) << " ";
	}
	out << endl;

	QString s2;
	s2.swap(s1);
	for (auto it = s2.begin(); it != s2.end(); ++it)
	{
		out << *it << " ";
	}
	out << endl;

	return 0;
}
```

结果：

```text
append: 34
prepend: 1234
+=: 123456
insert: 123333456
replace: 127773456
remove: 123456
push_back: 123456789
push_front: 0123456789
0123456789
size: 10
length: 10
count: 10
0 1 2 3 4 5 6 7 8 9
0 1 2 3 4 5 6 7 8 9
```

### 动态创建、获取子串

QString 有一个非常牛逼的成员函数split，该成员函数可以通过传递的分隔符将字符串分解为多个子串，并且支持正则表达式，其将在[QStringList](#qstringlist)中演示。

```c++
// main.cpp
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);

	QString s1 = "file name is %1, function name is %2.";
	QString s2 = s1.arg(__FILE__);
	QString s3 = s2.arg(__func__);

	out << "s1: " << s1 << "\n"
		<< "s2: " << s2 << "\n"
		<< "s3: " << s3 << "\n";

	QString sub1 = s1.right(3);
	QString sub2 = s1.mid(5, 4);
	QString sub3 = s1.left(4);

	out << "sub1: " << sub1 << "\n"
		<< "sub2: " << sub2 << "\n"
		<< "sub3: " << sub3 << "\n";

	QStringRef subRef1 = s1.rightRef(3);
	QStringRef subRef2 = s1.midRef(5, 4);
	QStringRef subRef3 = s1.leftRef(4);

	out << "subRef1: " << subRef1 << "\n"
		<< "subRef2: " << subRef2 << "\n"
		<< "subRef3: " << subRef3.toString() << "\n";

	QString s4("Rain");
	QString s5 = s4.toLower();
	QString s6 = s4.toUpper();

	out << "sensitive: " << "\n"
		<< s4 << " < " << s5 << " is "
		<< s4.compare(s5) << "\n"
		<< s4 << " < " << s6 << " is "
		<< QString::compare(s4, s6) << "\n"
		<< "insensitive: " << "\n"
		<< s4 << " < " << s5 << " is "
		<< s4.compare(s5, Qt::CaseInsensitive) << "\n"
		<< s4 << " < " << s6 << " is "
		<< QString::compare(s4, s6, Qt::CaseInsensitive) << "\n";

	return 0;
}
```

结果：

```text
s1: file name is %1, function name is %2.
s2: file name is main.cpp, function name is %2.
s3: file name is main.cpp, function name is main.
sub1: %2.
sub2: name
sub3: file
subRef1: %2.
subRef2: name
subRef3: file
sensitive:
Rain < rain is -32
Rain < RAIN is 32
insensitive:
Rain < rain is 0
Rain < RAIN is 0
```

### 数值转换、字符分类、输出排版

我们知道标准库`<string>`里面有`to_string`、`stoi`、`stof`等数值转换操作，标准库`<cctype>`里面也有`tolower`、`isdigit`、`ispunct`等字符操作，相应的，QString也有对应的数值转换操作，QChar也有相应的字符操作。

```c++
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);

	QString s1;

	s1 = QString::number(123);
	out << s1 << " "
		<< "toInt: " << s1.toInt()
		<< endl;

	s1.setNum(1.234);
	out << s1 << " "
		<< "toDouble: " << s1.toDouble()
		<< endl;

	s1 = "7 white, 3 red roses.";
	int digits = 0, letters = 0;
	int spaces = 0, puncts = 0;
	foreach(auto &s, s1)
	{
		if (s.isDigit()) {
			digits++;
		}
		else if (s.isLetter()) {
			letters++;
		}
		else if (s.isSpace()) {
			spaces++;
		}
		else if (s.isPunct()) {
			puncts++;
		}
	}

	out << QString("There are %1 characters").arg(s1.count()) << endl;
	out << QString("There are %1 letters").arg(letters) << endl;
	out << QString("There are %1 digits").arg(digits) << endl;
	out << QString("There are %1 spaces").arg(spaces) << endl;
	out << QString("There are %1 punctuation characters").arg(puncts) << endl;

	QString field1 = "Name: ";
	QString field2 = "Occupation: ";
	QString field3 = "Residence: ";
	QString field4 = "Marital status: ";

	int width = field4.size();

	out << field1.rightJustified(width, ' ') << "Robert\n";
	out << field2.rightJustified(width, ' ') << "programmer\n";
	out << field3.rightJustified(width, ' ') << "New York\n";
	out << field4.rightJustified(width, ' ') << "single\n";

	return 0;
}
```

结果：

```text
123 toInt: 123
1.234 toDouble: 1.234
There are 21 characters
There are 13 letters
There are 2 digits
There are 4 spaces
There are 2 punctuation characters
          Name: Robert
    Occupation: programmer
     Residence: New York
Marital status: single
```

<h2 id="qdate_qtime_and_qdatetime">QDate, QTime and QDateTime</h2>

我们知道标准库处理日期、时间的方式是使用`<chrono>`或`<ctime>`，如果你想在Qt中处理日期的话，你可以使用 QDate，如果你想处理时间的话，你可以使用 QTime，如果你想日期、时间一起处理的话，你可以使用 QDateTime。

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qdatetime.h`和`qdatetime.cpp`。

<h3 id="qdate">QDate</h3>

```c++
#include <QTextStream>
#include <QDate>

/*
enum DateFormat {
TextDate,      // default Qt
ISODate,       // ISO 8601
SystemLocaleDate, // deprecated
LocalDate = SystemLocaleDate, // deprecated
LocaleDate,     // deprecated
SystemLocaleShortDate,
SystemLocaleLongDate,
DefaultLocaleShortDate,
DefaultLocaleLongDate,
RFC2822Date,        // RFC 2822 (+ 850 and 1036 during parsing)
ISODateWithMs
};
*/

int main(void)
{
	QTextStream out(stdout);

	QDate d1(2017, 7, 18);
	out << d1.toString(Qt::TextDate) << "\n"
		<< d1.toString(Qt::ISODate) << "\n"
		<< d1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< d1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< d1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< d1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< d1.toString(Qt::RFC2822Date) << "\n"
		<< d1.toString(Qt::ISODateWithMs) << "\n"
		<< d1.year() << " " << d1.month() << " " << d1.day() << "\n"
		<< d1.dayOfWeek() << " " << d1.dayOfYear() << "\n"
		<< d1.daysInMonth() << " " << d1.daysInYear() << "\n"
		<< d1.weekNumber() << endl;

	QString str("2017-07-29");
	d1 = QDate::fromString(str, Qt::ISODate);
	out << d1.toString(Qt::ISODate) << endl;

	d1.setDate(2017, 7, 20);
	out << d1.daysTo(QDate::currentDate()) << "\n"
		<< d1.addDays(2).toString(Qt::ISODate) << "\n"
		<< d1.addMonths(2).toString(Qt::ISODate) << "\n"
		<< d1.addYears(2).toString(Qt::ISODate) << "\n"
		<< d1.toString(Qt::ISODate) << " > "
		<< QDate::currentDate().toString(Qt::ISODate)
		<< " is " << (d1 > QDate::currentDate())
		<< endl;

	return 0;
}
```

结果：

```text
周二 七月 18 2017
2017-07-18
2017/7/18
2017年7月18日
2017/7/18
2017年7月18日
18 Jul 2017
2017-07-18
2017 7 18
2 199
31 365
29
2017-07-29
-2
2017-07-22
2017-09-20
2019-07-20
2017-07-20 > 2017-07-18 is 1
```

上面没有演示以下两个函数，因为它们需要自定义日期格式：

```c++
QString toString(const QString &format) const;
static QDate fromString(const QString &s, const QString &format);
```

自定义日期格式：

Expression | Output
------------ | ---------------------------------
yy | 两位数年份(00~99)
yyyy | 四位数年份
M | 不带前置零的月份数(1 ~ 12)
MM | 带有前置零的月份数(01 ~ 12)
MMM | 短的本地化月份名(如 Jan ~ Dec)
MMMM | 长的本地化月份名(如 January ~ December)
d | 不带前置零的天数(1 ~ 31)
dd | 带有前置零的天数(01 ~ 31)
ddd | 短的本地化天名(如 Mon ~ Sun)
dddd | 长的本地化天名(如 Monday ~ Sunday)

```c++
#include <QTextStream>
#include <QDate>

int main(void)
{
	QTextStream out(stdout);

	QDate cd = QDate::currentDate();

	out << "Today is " << cd.toString("yyyy-MM-dd") << endl;
	out << "Today is " << cd.toString("yy/M/dd") << endl;
	out << "Today is " << cd.toString("d. M. yyyy") << endl;
	out << "Today is " << cd.toString("d-MMMM-yyyy") << endl;

	QString fmt("yyyy-MM-dd");
	QString str("2017-07-18");
	out << QDate::fromString(str, fmt).toString("yy/M/dd") << endl;

	return 0;
}
```

结果：

```text
Today is 2017-07-18
Today is 17/7/18
Today is 18. 7. 2017
Today is 18-七月-2017
17/7/18
```

<h3 id="qtime">QTime</h3>

```c++
#include <QTextStream>
#include <QTime>

int main(void)
{
	QTextStream out(stdout);

	QTime t1(20, 01, 18, 50);
	out << t1.toString(Qt::TextDate) << "\n"
		<< t1.toString(Qt::ISODate) << "\n"
		<< t1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< t1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< t1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< t1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< t1.toString(Qt::RFC2822Date) << "\n"
		<< t1.toString(Qt::ISODateWithMs) << "\n"
		<< t1.hour() << " " << t1.minute() << " "
		<< t1.second() << " " << t1.msec()
		<< endl;

	QString str("20:02:20.22");
	QTime t2 = QTime::fromString(str, Qt::ISODate);
	out << t2.toString(Qt::ISODate) << endl;

	t2 = QTime::currentTime();
	t2.setHMS(21, 01, 18, 50);
	out << t2.secsTo(t1) << "\n"
		<< t2.msecsTo(t1) << "\n"
		<< t2.addSecs(2).toString(Qt::ISODate) << "\n"
		<< t2.addMSecs(950).toString(Qt::ISODate) << "\n"
		<< t2.toString(Qt::ISODate) << " > " << t1.toString(Qt::ISODate)
		<< " is " << (t2 > t1)
		<< endl;

	return 0;
}
```

结果：

```text
20:01:18
20:01:18
20:01
20:01:18
20:01
20:01:18
20:01:18
20:01:18.050
20 1 18 50
20:02:20
-3600
-3600000
21:01:20
21:01:19
21:01:18 > 20:01:18 is 1
```

自定义时间格式：

Expression | Output
------------ | ---------------------------------
AP <br> A | AM/PM
ap <br> a | am/pm
t | 时区
h | 0 ~ 23 或 1 ~ 12
hh | 00 ~ 23 或 01 ~ 12
H | 0 ~ 23
HH | 00 ~ 23
m | 0 ~ 59
mm | 00 ~ 59
s | 0 ~ 59
ss | 00 ~ 59
z | 0 ~ 999
zzz | 000 ~ 999

```c++
#include <QTextStream>
#include <QTime>

int main(void)
{
	QTextStream out(stdout);

	QTime cd = QTime::currentTime();

	out << "The time is " << cd.toString("hh:mm:ss.zzz") << endl;
	out << "The time is " << cd.toString("h:m:s a") << endl;
	out << "The time is " << cd.toString("H:m:s A") << endl;
	out << "The time is " << cd.toString("h:m AP") << endl;

	QString fmt("hh:mm:ss.zzz");
	QString str("20:20:20.200");
	out << QTime::fromString(str, fmt).toString("h:m:s a") << endl;

	return 0;
}
```

结果：

```text
Today is 13:40:26.653
Today is 1:40:26 下午
Today is 13:40:26 下午
Today is 1:40 下午
8:20:20 下午
```

仔细查看 QTime 的成员函数，发现还有三个特别的函数：

```c++
// 一天86400秒
void QTime::start()
{
    *this = currentTime();
}

int QTime::restart()
{
    QTime t = currentTime();
    int n = msecsTo(t);
    if (n < 0)                                // passed midnight
        n += 86400*1000;
    *this = t;
    return n;
}

int QTime::elapsed() const
{
    int n = msecsTo(currentTime());
    if (n < 0)                                // passed midnight
        n += 86400 * 1000;
    return n;
}
```

这三个函数时干什么的呢，从名字上很容易猜出来，它们是用来计时的。根据源代码，当时间超过24小时后，`restart`和`elapsed`将会从零重新开始计时。

```c++
#include <QTextStream>
#include <QTime>
#include <thread>
#include <chrono>

int main(void)
{
	QTextStream out(stdout);

	QTime t;
	t.start();
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(100));
	out << "took " << t.restart() << " ms" << "\n";
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(200));
	out << "took " << t.elapsed() << " ms" << "\n";

	return 0;
}
```

结果：

```text
took 100 ms
took 200 ms
```

<h3 id="qdatetime">QDateTime</h3>

你可以把 QDateTime 当做 QDate 和 QTime 的并集，使用时可以使用成员函数`date()`和`time()`来获取对应的 QDate 和 QTime，修改之后再通过成员函数`setDate`和`setTime`将修改合并到原 QDateTime 实例中；剩余比较独立的函数是`toUTC`和`toTime_t`，其中UTC时间是世界标准时间，不随地区、季节的改变而改变，`time_t`是Unix时间。

```c++
#include <QTextStream>
#include <QDateTime>

int main(void)
{
	QTextStream out(stdout);

	QDate d = QDate::currentDate();
	QTime t = QTime::currentTime();
	QDateTime dt1(d, t);
	QDateTime dt2 = QDateTime::currentDateTime();
	QDateTime dt3 = QDateTime::currentDateTimeUtc();

	out << dt1.toString(Qt::ISODate) << "\n"
		<< dt2.toString(Qt::ISODate) << "\n"
		<< dt3.toString(Qt::ISODate) << "\n"
		<< dt2.date().toString(Qt::ISODate) << "\n"
		<< dt2.time().toString(Qt::ISODate) << "\n"
		<< dt1.toUTC().toString(Qt::ISODate) << "\n"
		<< dt2.toTime_t()
		<< endl;

	return 0;
}
```

结果：

```text
2017-07-18T14:56:57
2017-07-18T14:56:57
2017-07-18T06:56:57Z
2017-07-18
14:56:57
2017-07-18T06:56:57Z
1500361017
```

<h2 id="qt_containers">Qt 容器</h2>

容器分为顺序容器与关联容器。顺序容器中元素的顺序由其加入容器时的位置决定；关联容器中元素的顺序由其相关联的关键字值决定。

Qt中的顺序容器包含QVector、QList、QStringList，关联容器包含QSet、QMap。

<h3 id="qvector">QVector</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qvector.h`。

仔细看其实现，你可以简单的把它当标准vector来用：

```c++
#include <QTextStream>
#include <QVector>

template <typename T>
QTextStream& operator<<(QTextStream& out, const QVector<T> &v);

int main(void)
{
	QTextStream out(stdout);

	QVector<int> v1{ 1,2,3,4,5 };
	QVector<int> v2(5, 1);

	v1.swap(v2);
	v2.push_back(7);
	v2.push_front(0);
	v2.insert(v2.end() - 1, 6);
	v2.pop_back();
	v2.pop_front();

	out << "v1: " << v1 << "\n"
		<< "v2: " << v2 << "\n"
		<< "v1.size = " << v1.size() << "\n"
		<< "v1[1] = " << v1[1] << "\n"
		<< "v2[2] = " << v2.at(2) << "\n"
		<< "v2.front = " << v2.front() << "\n"
		<< "v2.back = " << v2.back()
		<< endl;

	return 0;
}

template <typename T>
QTextStream& operator<<(QTextStream& out, const QVector<T> &v)
{
	if (!v.empty())
	{
		for (auto &i : v)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
v1: 1 1 1 1 1
v2: 1 2 3 4 5 6
v1.size = 5
v1[1] = 1
v2[2] = 3
v2.front = 1
v2.back = 6
```

<h3 id="qlist">QList</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qlist.h`和`qlist.cpp`。

QList 的使用跟 QVector 差不多。

```c++
#include <QTextStream>
#include <QVector>
#include <QList>

template <typename T>
QTextStream& operator<<(QTextStream& out, const QList<T> &l);

int main(void)
{
	QTextStream out(stdout);

	QList<int> l1{ 1,2,3,4,5 };
	QList<int> l2 = QVector<int>(5, 1).toList();

	l1.swap(l2);
	l2.push_back(7);
	l2.push_front(0);
	l2.insert(l2.end() - 1, 6);
	l2.pop_back();
	l2.pop_front();

	out << "l1: " << l1 << "\n"
		<< "l2: " << l2 << "\n"
		<< "l1.size = " << l1.size() << "\n"
		<< "l1[1] = " << l1[1] << "\n"
		<< "l2[2] = " << l2.at(2) << "\n"
		<< "l2.front = " << l2.front() << "\n"
		<< "l2.back = " << l2.back()
		<< endl;


	return 0;
}

template <typename T>
QTextStream& operator<<(QTextStream& out, const QList<T> &l)
{
	if (!l.empty())
	{
		for (auto &i : l)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
l1: 1 1 1 1 1
l2: 1 2 3 4 5 6
l1.size = 5
l1[1] = 1
l2[2] = 3
l2.front = 1
l2.back = 6
```

<h3 id="qstringlist">QStringList</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qstringlist.h`和`qstringlist.cpp`。

QStringList 继承自`QList<QString>`，它比较有用的函数是`filter`，该函数返回当前list中包含传入子串的字符串组成的list，其它使用与QList没什么区别，相当于一个特例化版本，有时候与 QString 的 split 配合使用。

```c++
#include <QTextStream>
#include <QStringList>
#include <QVector>

QTextStream& operator<<(QTextStream& out, const QStringList &sl);

int main(void)
{
	QTextStream out(stdout);

	QList<QString> l1{ "1","2","3","4","5" };
	QList<QString> l2 = QVector<QString>(5, "1").toList();

	QStringList sl1(l1);
	QStringList sl2(l2);

	sl1.swap(sl2);
	sl2.push_back("7");
	sl2.push_front("0");
	sl2.insert(sl2.end() - 1, "6");
	sl2.pop_back();
	sl2.pop_front();

	out << "sl1: " << sl1 << "\n"
		<< "sl2: " << sl2 << "\n"
		<< "sl1.size = " << sl1.size() << "\n"
		<< "sl1[1] = " << sl1[1] << "\n"
		<< "sl2[2] = " << sl2.at(2) << "\n"
		<< "sl2.front = " << sl2.front() << "\n"
		<< "sl2.back = " << sl2.back()
		<< endl;

	QStringList sl3{ "Bill Murray","John Doe","Bill Clinton" };
	sl3 = sl3.filter("Bill");

	out << "sl3: " << sl3 << endl;

	QString str = "a,,b,c";
	QStringList sl4 = str.split(',');
	QStringList sl5 = str.split(',', QString::SkipEmptyParts);

	out << "sl4: " << sl4 << "\n"
		<< "sl5: " << sl5
		<< endl;

	return 0;
}

QTextStream& operator<<(QTextStream& out, const QStringList &sl)
{
	if (!sl.empty())
	{
		for (auto &i : sl)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
sl1: 1 1 1 1 1
sl2: 1 2 3 4 5 6
sl1.size = 5
sl1[1] = 1
sl2[2] = 3
sl2.front = 1
sl2.back = 6
sl3: Bill Murray Bill Clinton
sl4: a  b c
sl5: a b c
```

<h3 id="qset">QSet</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qset.h`。

众所周知，关联容器的查找速度相当快，所以在很多查找算法中都使用了关联容器。相比于`std::set`，**QSet 不对元素进行默认排序**，如果你一定要排序的话，可以使用`std::sort`。

QSet 的实现基于 QHash。**一个type要想使用 QSet，它必须提供一个默认构造函数、复制构造函数、一个赋值运算符、以及一个全局的qHash函数**，该函数返回一个传入type值的hash值。

**默认 QSet 可以使用的类型包含基础类型如int、double、指针等，以及 Qt 数据类型QString、QDate、QTime等，QObject 以及 任何其派生类(QWidget、QDialog、QTimer等)都不能使用 QSet**。如果你想对一种类型使用 QSet，你可以编译试验或者查看其实现是否满足条件，直接编译或许更快一点。

**在实现qHash函数时，对于一个给定值，任何时候调用此函数都应该返回相同的结果，对于不等的对象几乎总是产生不同的结果**。在`qtbase-5.9\src\corelib\tools`目录下的`qhashfunctions.h`和`qhash.cpp`中，你能看到相当多的qHash函数定义及实现，所有类型最终都转成了uint，uint的qHash实现如下：

```c++
inline uint qHash(uint key, uint seed = 0) Q_DECL_NOTHROW { return key ^ seed; }
```

qHash函数可以是以下四种签名的任何一种：

```c++
uint qHash(K key);
uint qHash(const K &key);

uint qHash(K key, uint seed);
uint qHash(const K &key, uint seed);
```

如果你每种都实现了，那么QHsh会使用两个参数的实现。仔细看源码，你会发现所有的qHash实现都没有使用单参数的签名方式，相对的，它们对第二个参数设置了默认值，这就相当于同时实现了单参数与双参数的qHash函数。再查看官方说明，**要想自定义一个qHash函数，还需要定义`operator==()`**。

下面我们就来实现一个自定义的类型，并使它满足 QSet 的使用条件：

```c++
#ifndef MYQSETTYPE_HPP
#define MYQSETTYPE_HPP

#include <QString>
#include <QDate>
#include <QHash>
#include <QTextStream>

class myQSetType
{
	QString name;
	QDate birth;
	int height;

public:
	myQSetType() = default;
	~myQSetType() = default;

	myQSetType(QString name_, QDate birth_, int height_)
		: name(name_), birth(birth_), height(height_)
	{}

	myQSetType(const myQSetType &other)
	{
		operator=(other);
	}

	myQSetType& operator=(const myQSetType &other)
	{
		if (this != &other)
		{
			name = other.name;
			birth = other.birth;
			height = other.height;
		}
		return *this;
	}

	inline QString getName() const
	{
		return name;
	}

	inline QDate getBirth() const
	{
		return birth;
	}

	inline int getHeight() const
	{
		return height;
	}
};

inline bool operator==(const myQSetType &t1, const myQSetType &t2)
{
	return t1.getName() == t2.getName() &&
		t1.getBirth() == t2.getBirth() &&
		t1.getHeight() == t2.getHeight();
}

inline uint qHash(const myQSetType &key, uint seed = 0)
{
	return qHash(key.getName(), seed) ^
		qHash(key.getBirth().toString("yyyyMMdd"), seed) ^
		key.getHeight();
}

QTextStream& operator<<(QTextStream& out, const myQSetType& t)
{
	out << "name: " << t.getName() << " "
		<< "borth: " << t.getBirth().toString("yyyyMMdd") << " "
		<< "height: " << t.getHeight();
	return out;
}

#endif // MYQSETTYPE_HPP
```

QSet 的使用方式也可以参照`std::set`来使用：

```c++
#include <QTextStream>
#include <QSet>

#include "myQSetType.hpp"

template <typename T>
QTextStream& operator<<(QTextStream& out, const QSet<T> &s);

int main(void)
{
	QTextStream out(stdout);

	QSet<myQSetType> qset;

	myQSetType s1("Bill Murray", QDate(1970, 1, 1), 180);
	myQSetType s2("John Doe", QDate(1993, 12, 5), 170);
	myQSetType s3("Bill Clinton", QDate(1993, 8, 18), 210);

	qset.insert(s1);
	qset.insert(s2);
	qset.insert(s3);

	out << qset
		<< qset.size() << "\n"
		<< *(qset.find(s1)) << "\n";

	qset.erase(qset.begin());
	out << qset
		<< qset.size() << "\n"
		<< (qset.end() == qset.find(s1)) << "\n";

	return 0;
}

template <typename T>
QTextStream& operator<<(QTextStream& out, const QSet<T> &s)
{
	if (!s.empty())
	{
		for (auto &i : s)
		{
			out << i << "\n";
		}
	}
	return out;
}
```

结果1：

```text
name: Bill Murray borth: 19700101 height: 180
name: Bill Clinton borth: 19930818 height: 210
name: John Doe borth: 19931205 height: 170
3
name: Bill Murray borth: 19700101 height: 180
name: Bill Clinton borth: 19930818 height: 210
name: John Doe borth: 19931205 height: 170
2
1
```

结果2：

```text
name: Bill Clinton borth: 19930818 height: 210
name: John Doe borth: 19931205 height: 170
name: Bill Murray borth: 19700101 height: 180
3
name: Bill Murray borth: 19700101 height: 180
name: John Doe borth: 19931205 height: 170
name: Bill Murray borth: 19700101 height: 180
2
0
```

从结果来看，**QSet 的元素是无序的**。

<h3 id="qmap">QMap</h3>

你可以在`qtbase-5.9\src\corelib\tools`目录下找到`qmap.h`和`qmap.cpp`。

QMap 是一个基于红黑树的词典，相对于 QHash 来说，**QMap 的平均查找速度略低于 QHash 的查找速度，QMap 的元素总是按其键值进行排序**，这意味着键类型必须提供一个比较运算符，根据官方说明，**这个运算符是小于符号**，比较运算符的要求是：对于两个值x、y，如果`x < y`和`y < x`都为假，那么`x == y`。

QMap 默认一个键只能对应一个值，当你在添加已存在的键值对时，原来的键值对会被移除。但是 QMap 提供了一个成员函数`insertMulti`使得你可以为一个键提供多个值，然后你可以通过成员函数`values`来获取该键对应的值的 QList，你也可以使用 QMap 的继承类 QMultiMap，该类只是将`insert`的实现移交到了`insertMulti`，仅此而已。

通过上面的了解，我们应当注意到 QMultiMap 与 `std::multimap`的不同，前者是一个键对多个值，后者是可以拥有多个键，但是每个键只能对应一个值。

**要想一个type能够作为 QMap 的键，该type必须提供一个默认构造函数、复制构造函数、赋值运算符、和一个非成员小于运算符**。

将上面的 myQSetType 重构为支持 QMap 的自定义类型：

```c++
#ifndef MYQSETTYPE_HPP
#define MYQSETTYPE_HPP

#include <QString>
#include <QDate>
#include <QHash>
#include <QTextStream>

class myQSetType
{
	QString name;
	QDate birth;
	int height;

public:
	myQSetType() = default;
	~myQSetType() = default;

	myQSetType(QString name_, QDate birth_, int height_)
		: name(name_), birth(birth_), height(height_)
	{}

	myQSetType(const myQSetType &other)
	{
		operator=(other);
	}

	myQSetType& operator=(const myQSetType &other)
	{
		if (this != &other)
		{
			name = other.name;
			birth = other.birth;
			height = other.height;
		}
		return *this;
	}

	inline QString getName() const
	{
		return name;
	}

	inline QDate getBirth() const
	{
		return birth;
	}

	inline int getHeight() const
	{
		return height;
	}
};

inline bool operator<(const myQSetType &t1, const myQSetType &t2)
{
	return t1.getBirth() < t2.getBirth() ||
		(t1.getBirth() == t2.getBirth() && t1.getName() < t2.getName()) ||
		(t1.getBirth() == t2.getBirth() && t1.getName() == t2.getName() && t1.getHeight() < t2.getHeight());
}

QTextStream& operator<<(QTextStream& out, const myQSetType& t)
{
	out << "name: " << t.getName() << " "
		<< "borth: " << t.getBirth().toString("yyyyMMdd") << " "
		<< "height: " << t.getHeight();
	return out;
}

#endif // MYQSETTYPE_HPP
```

QMap 的使用方式也可以参照`std::map`来使用：

```c++
#include <QTextStream>
#include <QMap>

#include "myQSetType.hpp"

template <typename KEY, typename VALUE>
QTextStream& operator<<(QTextStream& out, const QMap<KEY, VALUE> &m);

int main(void)
{
	QTextStream out(stdout);

	myQSetType s1("Bill Murray", QDate(1970, 1, 1), 180);
	myQSetType s2("John Doe", QDate(1993, 12, 5), 170);
	myQSetType s3("Bill Clinton", QDate(1993, 12, 5), 210);

	QMap<myQSetType, QString> qmap
	{
		{ s1,"Bill Murray" },
		{ s2,"John Doe" },
		{ s3,"Bill Clinton" }
	};
	qmap.clear();
	qmap.insert(s1, "Bill Murray");
	qmap[s2] = "John Doe";
	qmap.insertMulti(s3, "Bill Clinton");

	// 注意这里find得到的迭代器类型与标准迭代器的区别
	out << qmap
		<< qmap.size() << "\n"
		<< *(qmap.find(s1)) << "\n"
		<< endl;

	qmap.erase(qmap.begin());
	out << qmap
		<< qmap.size() << "\n"
		<< (qmap.end() == qmap.find(s1)) << "\n"
		<< endl;

	QList<QString> s3Values = qmap.values(s3);
	out << s3Values.size() << endl;

	return 0;
}

template <typename KEY, typename VALUE>
QTextStream& operator<<(QTextStream& out, const QMap<KEY, VALUE> &m)
{
	if (!m.empty())
	{
		QList<KEY> keys = m.keys();
		QList<VALUE> values = m.values();

		out << "keys: \n";
		for (auto &i : keys)
		{
			out << i << "\n";
		}

		out << "values: \n";
		for (auto &i : values)
		{
			out << i << "\n";
		}
	}
	return out;
}
```

结果：

```text
keys:
name: Bill Murray borth: 19700101 height: 180
name: Bill Clinton borth: 19931205 height: 210
name: John Doe borth: 19931205 height: 170
values:
Bill Murray
Bill Clinton
John Doe
3
Bill Murray

keys:
name: Bill Clinton borth: 19931205 height: 210
name: John Doe borth: 19931205 height: 170
values:
Bill Clinton
John Doe
2
1

1
```

<h2 id="io">IO</h2>

Qt5 中处理文件的基本类是 QFile、QDir 和 QFileInfo。其中 QFile 用来读写文件，QDir 用来访问文件夹，QFileInfo 用来获取文件的相关信息(如路径、文件名、修改时间、权限等)。

Qt5 的输出流一般使用 QDebug，你也可以使用 QTextStream 或 QDataStream 同时处理输入输出。

<h3 id="qfile">QFile</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qfile.h`和`qfile.cpp`。

我们先回想一下`std::fstream`是如何对文件进行读写的，然后顺着这个思路去看 QFile 是如何对应的：

*	首先，`std::fstream`由默认构造函数，QFile 也有；
*	`std::fstream`可以传递一个文件名构造并打开该文件，QFile 也有，但是 **QFile 只支持带正斜杠`/`的文件名**；
*	`std::fstream`可以使用成员函数`open`打开一个文件并设置打开模式，QFile 没有，但可以组合其成员函数`setFileName`和`open`来达到这一效果；
*	`std::fstream`可以使用成员函数`is_open`来检验文件是否成功打开，QFile 有`isOpen`；
*	`std::fstream`可以使用成员函数`close`来关闭打开的文件，QFile 也有；
*	`std::fstream`的析构函数会自动调用`close`，QFile 也是；
*	`std::fstream`可以使用非成员函数`getline`来从流中获取一行数据，QFile 有成员函数`readLine`；
*	`std::fstream`可以使用运算符`>>`和`<<`进行读写，QFile 可以使用`read`和`write`，另外你还可以绑定 QFile 到[QDataStream](#qdatastream)或[QTextStream](#qtextstream)来获得使用`>>`和`<<`读写的功能；
*	`std::fstream`可以使用成员函数`eof`来检测是否到达文件结尾，QFile 有`atEnd`；

我们知道`std::fstream`是没有直接获取文件大小的函数的，但 QFile 的成员函数`size`实现了这个功能，**在Unix下一些特别的系统文件(如`/proc`)的`size`总是返回0，`atEnd`也会一直返回true，但是你却可以从中读取到数据**，这时候你就需要这么做：

```c++
QFile file("/proc/modules");
if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
	return;

QTextStream in(&file);
QString line = in.readLine();
while (!line.isNull()) {
	process_line(line);
	line = in.readLine();
}
```

上面的代码来自官方文档，通过该代码，我们知道 QFile 的文件打开模式在 QIODevice 中定义，所以我们查看`qiodevice.h`：

```c++
enum OpenModeFlag {
	NotOpen = 0x0000,
	ReadOnly = 0x0001,
	WriteOnly = 0x0002,
	ReadWrite = ReadOnly | WriteOnly,
	Append = 0x0004,
	Truncate = 0x0008,
	Text = 0x0010,
	Unbuffered = 0x0020
};
```

通过上面的对比学习，我们来做一个演示：

```c++
#include <QTextStream>
#include <QFile>
#include <QTextStream>

int main(void)
{
	QTextStream out(stdout);
	QString filename("test.txt");

	QFile file;
	file.setFileName(filename);
	file.open(QIODevice::ReadWrite);
	if (!file.isOpen())
	{
		out << "open " << filename << "failed.\n";
		return 1;
	}

	file.write("line1 line1 line1\n");
	file.write("line2 line2 line2\n");
	file.write("line3 line3 line3\n");
	file.seek(0);

	QString str1 = file.read(11);
	QString str2 = file.read(12);
	QString str3 = file.readLine();
	QString str4 = file.readAll();
	bool isEnd = file.atEnd();
	qint64 size = file.size();

	file.close();

	out << "str1: " << str1 << "\n"
		<< "str2: " << str2 << "\n"
		<< "str3: " << str3 << "\n"
		<< "str4: " << str4 << "\n"
		<< isEnd << "\n"
		<< size << endl;

	return 0;
}
```

结果：

```text
str1: line1 line1
str2:  line1
line2
str3:  line2 line2

str4: line3 line3 line3

1
54
```

<h3 id="qdir">QDir</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qdir.h`和`qdir.cpp`。

标准库没有处理文件夹的类，但是网上有很多自己实现的类，你可以在[这里](https://stackoverflow.com/questions/612097/how-can-i-get-the-list-of-files-in-a-directory-using-c-or-c)得到相当多的建议。

QDir 也使用正斜杠`/`作为其目录分隔符，并且支持相对路径，你可以使用其成员函数`isRelative()`或`isAbsolute()`来判断使用的路径的是相对的还是绝对的，你甚至可以使用成员函数`makeAbsolute`从一个相对路径得到一个绝对路径。

QDir 有一些相似shell命令行的函数，如`mkdir`、`rmdir`、`cd`；一些有用的非静态成员函数：

*	`exists`；
*	`isReadable`；
*	`count`：获取当前目录下的文件夹和文件总数；
*	`entryList`：获取当前目录下的文件夹和文件名列表；
*	`entryInfoList`：获取当前目录下的文件夹和文件信息列表；
*	`remove`：删除文件；
*	`setFilter`：文件类型过滤器，影响`entryList`和`entryInfoList`；
*	`setNameFilters`：文件名过滤器，影响`entryList`和`entryInfoList`；
*	`setSorting`：设置文件排序顺序，如按大小排列、按修改时间排列等，影响`entryList`和`entryInfoList`；
*	`filePath`：返回当前目录下的指定文件名的路径，不检查其是否存在，如果当前目录是相对的，返回的路径也是相对的；
*	`absoluteFilePath`：返回当前目录下的指定文件名的绝对路径，不检查其是否存在。

一些静态成员函数：

QDir | QString | 返回值
--------------- | -------------- | ------------------------
current() | currentPath() | 当前工作目录 <br>你可以使用`setCurrent`来设置当前工作目录
home() | homePath() | 当前用户目录
root() | rootPath() | 根目录
temp() | tempPath() | 系统临时文件夹

演示：

```c++
#include <QTextStream>
#include <QDir>
#include <QFile>

QTextStream& operator<<(QTextStream& out, const QStringList &sl);

int main(void)
{
	QTextStream out(stdout);
	QString dir_name("directory");

	out << "current: " << QDir::currentPath() << "\n"
		<< "home: " << QDir::homePath() << "\n"
		<< "root: " << QDir::rootPath() << "\n"
		<< "temp: " << QDir::tempPath() << endl;

	QDir temp(QDir::temp());
	if (!temp.exists())
	{
		out << QDir::tempPath()
			<< "is not exist.\n";
		return 1;
	}
	if (!temp.isReadable())
	{
		out << QDir::tempPath()
			<< "is not readable.\n";
		return 1;
	}
	if (!temp.exists(dir_name))
	{
		temp.mkdir(dir_name);
	}

	temp.cd(dir_name);
	QString dir_path = temp.absolutePath();
	out << "after cd(\"directory\"): "
		<< dir_path << endl;
	temp.cd("..");
	out << "after cd(\"..\"): "
		<< temp.absolutePath() << endl;
	temp.setPath(dir_path);

	QString subDir("dir%1");
	QString subFile("file%1");
	for (int i = 1; i <= 3; ++i)
	{
		QString tmp_dir = subDir.arg(i);
		temp.mkdir(tmp_dir);

		QString tmp_file = subFile.arg(i);
		QFile file(temp.filePath(tmp_file));
		file.open(QIODevice::WriteOnly);
	}
	out << "after created: \n"
		<< temp.entryList()
		<< endl;

	temp.rmdir("dir2");
	temp.remove("file2");

	out << "after removed: \n";
	out << "dirs: ";
	temp.setFilter(QDir::Dirs);
	temp.setSorting(QDir::Name | QDir::Reversed);
	out << temp.entryList() << "\n";
	out << "files: ";
	temp.setFilter(QDir::Files);
	temp.setSorting(QDir::Name | QDir::Reversed);
	out << temp.entryList() << "\n";

	return 0;
}

QTextStream& operator<<(QTextStream& out, const QStringList &sl)
{
	if (!sl.empty())
	{
		for (auto &i : sl)
		{
			out << i << " ";
		}
	}
	return out;
}
```

结果：

```text
current: E:/qt_project
home: C:/Users/pengzhen
root: C:/
temp: C:/Users/pengzhen/AppData/Local/Temp
after cd("directory"): C:/Users/pengzhen/AppData/Local/Temp/directory
after cd(".."): C:/Users/pengzhen/AppData/Local/Temp
after created:
. .. dir1 dir2 dir3 file1 file2 file3
after removed:
dirs: dir3 dir1 .. .
files: file3 file1
```

<h3 id="qfileinfo">QFileInfo</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qfileinfo.h`和`qfileinfo.cpp`。

前面我们说过，QFileInfo 提供关于文件或文件夹的相关信息，它可以使用绝对路径，又可以使用相对路径，你可以使用成员函数`isRelative`进行确认，也可以使用成员函数`makeAbsolute`从一个相对路径得到一个绝对路径。

查看其头文件，你会发现其实它能用的函数并不多：

```c++
QFileInfo(const QString &file);
QFileInfo(const QFile &file);
QFileInfo(const QDir &dir, const QString &file);
void setFile(const QString &file);
void setFile(const QFile &file);
void setFile(const QDir &dir, const QString &file);
bool exists() const;
static bool exists(const QString &file);
void refresh(); // 刷新文件信息
QString fileName() const;
QString filePath() const;
QString absoluteFilePath() const;
QString suffix() const; // 返回文件名最后一个.后所有字符
QString completeSuffix() const; // 返回文件名第一个.后所有字符
bool isReadable() const;
bool isWritable() const;
bool isExecutable() const;
bool isHidden() const;
bool isFile() const;
bool isDir() const;
bool isSymLink() const;
QString readLink() const;
qint64 size() const;
QDateTime created() const;
QDateTime lastModified() const;
QDateTime lastRead() const;
QString owner() const;
QString group() const;
bool permission(QFile::Permissions permissions) const;
QFile::Permissions permissions() const;
```

其中`owner`、`group`、`permissions`在NTFS文件系统上的返回值是不准确的，因为NTFS系统默认禁用了所有权的权限的检查，要想启用它，你需要：

```c++
extern Q_CORE_EXPORT int qt_ntfs_permission_lookup;
qt_ntfs_permission_lookup++; // turn checking on
qt_ntfs_permission_lookup--; // turn it off again
```

查看`qfile.h`，再转到`qfiledevice.h`：

```c++
enum Permission {
	ReadOwner = 0x4000, WriteOwner = 0x2000, ExeOwner = 0x1000,
	ReadUser  = 0x0400, WriteUser  = 0x0200, ExeUser  = 0x0100,
	ReadGroup = 0x0040, WriteGroup = 0x0020, ExeGroup = 0x0010,
	ReadOther = 0x0004, WriteOther = 0x0002, ExeOther = 0x0001
};
```

演示：

```c++
#include <QTextStream>
#include <QFileInfo>
#include <QDir>
#include <QFile>
#include <QDateTime>

extern Q_CORE_EXPORT int qt_ntfs_permission_lookup;

int main(void)
{
	qt_ntfs_permission_lookup++; // turn checking on
	QTextStream out(stdout);

	QFileInfo fileinfo1("release/qt_project.exe");
	QFileInfo fileinfo2(QDir::current(), "main.cpp");

	out << "path: "
		<< fileinfo1.filePath() << "\n"
		<< fileinfo2.filePath() << "\n"
		<< "name: "
		<< fileinfo1.fileName() << " "
		<< fileinfo2.fileName() << "\n"
		<< "exists: "
		<< fileinfo1.exists() << " "
		<< fileinfo2.exists() << "\n"
		<< "suffix: "
		<< fileinfo1.suffix() << " "
		<< fileinfo2.suffix() << "\n"
		<< "created: "
		<< fileinfo1.created().toString(Qt::ISODate) << " "
		<< fileinfo2.created().toString(Qt::ISODate) << "\n"
		<< "owner: "
		<< fileinfo1.owner() << " "
		<< fileinfo2.owner() << "\n"
		<< "permissions: "
		<< fileinfo1.permission(QFile::ExeUser) << " "
		<< fileinfo2.permission(QFile::ExeUser)
		<< endl;

	return 0;
}
```

结果：

```text
path: release/qt_project.exe
E:/qt_project/main.cpp
name: qt_project.exe main.cpp
exists: 1 1
suffix: exe cpp
created: 2017-07-21T12:24:37 2017-07-14T15:16:35
owner: pengzhen pengzhen
permissions: 1 1
```

<h3 id="qtextstream">QTextStream</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qtextstream.h`和`qtextstream.cpp`。

QTextStream 是 Qt 用来读写文本的流，查看其头文件，QTextStream 可以对 QIODevice、`FILE*`、QString 和 QByteArray进行操作。我们知道 QFile 继承自 QIODevice，所以 QTextStream 可以在 QFile 上进行操作；我们之前一直在使用`stdout`，它到底是个什么类型呢，在`C:\Program Files (x86)\Windows Kits\10\Include\10.0.15063.0\ucrt\corecrt_wstdio.h`中我们找到：

```c++
_ACRTIMP_ALT FILE* __cdecl __acrt_iob_func(unsigned _Ix);

#define stdin  (__acrt_iob_func(0))
#define stdout (__acrt_iob_func(1))
#define stderr (__acrt_iob_func(2))
```

所以`stdin`、`stdout`、`stderr`都是`FILE*`类型，所以可以使用 QTextStream 进行操作。

我们知道`std::iostream`有很多格式化控制符，如`hex`、`boolalpha`、`flush`、`ends`、`endl`等等，QTextStream 也有很多这样的控制符：

控制符(*前缀代表默认) | 说明
------------------------ | -----------------------------------
bin | 整型值设置为二进制
oct | 整型值设置为八进制
*dec | 整型值设置为十进制
hex | 整型值设置为十六进制
showbase | 对整型值输出表示进制的前缀 <br> 二进制：0b，八进制：0，十六进制：0x
*noshowbase | 不输出表示进制的前缀
forcesign | 总是显示正负号
*noforcesign | 需要时显示负号
forcepoint | 总是显示小数分隔符
*noforcepoint | 需要时显示小数分隔符
uppercasebase | 使用大写的进制前缀 <br> 二进制：0B，八进制：0，十六进制：0X
*lowercasebase | 使用小写的进制前缀 <br> 二进制：0b，八进制：0，十六进制：0x
uppercasedigits | 使用大写字母表示10~35
lowercasedigits | 使用小写字母表示10~35
fixed | 浮点值显示为定点十进制，e小写
scientific | 科学计数法，e小写
left | 左对齐
right | 右对齐
center | 中对齐
endl | 输出换行，并刷新缓冲区
flush | 刷新缓冲区
reset | 重置格式选项，返回到原始状态
ws | 按字符读取时丢弃空白字符
bom | 如果使用UTF解码器，那么每次写入数据时会插入BOM

除了上面的控制符外，QTextStream 还提供了`setFieldWidth`来设定每次输出宽度、`setPadChar`来设定填充字符、`setRealNumberPrecision`来设定输出数字的精度，默认是6。

QTextStream 默认使用unicode编码，你也可以使用成员函数`setCodec`手动设置(**操作QString时无效**)。在输入输出时，你可以使用流运算符`<<`和`>>`，你也可以使用成员函数`read`、`readLine`和`readAll`。

仿照[QFile 中的演示](#qfile)，最后再加一些格式控制：

```c++
#include <QTextStream>
#include <QFile>

int main(void)
{
	QTextStream out(stdout);
	QString filename("test.txt");

	QFile file(filename);
	file.open(QIODevice::ReadWrite);
	if (!file.isOpen())
	{
		out << "open " << filename << "failed.\n";
		return 1;
	}

	QTextStream fStream(&file);
	fStream << "line1 line1 line1\n"
		<< "line2 line2 line2\n"
		<< "line3 line3 line3\n";
	fStream.seek(0);

	QString str1 = fStream.read(11);
	QString str2 = fStream.read(12);
	QString str3 = fStream.readLine();
	QString str4 = fStream.readAll();
	bool isEnd = file.atEnd();
	qint64 size = file.size();

	fStream.flush();
	file.close();

	out << "str1: " << str1 << "\n"
		<< "str2: " << str2 << "\n"
		<< "str3: " << str3 << "\n"
		<< "str4: " << str4 << "\n"
		<< isEnd << "\n"
		<< size << endl;

	QTextStream sStream("0x50 0x20");
	int num1, num2, num3;
	char ch;
	sStream >> num1
		>> dec >> num2
		>> ch >> num3;

	out.setFieldWidth(10);
	out.setPadChar('*');
	out << left << hex << showbase << num1;
	out.setPadChar('-');
	out.setFieldWidth(5);
	out << "\n"
		<< dec << num2 << "\n"
		<< right
		<< ch << "\n"
		<< num3 << endl;

	return 0;
}
```

结果：

```text
str1: line1 line1
str2:  line1
line2
str3:  line2 line2
str4: line3 line3 line3

1
54
0x50******
----0----
--------x----
---20----
```

通过与 QFile 中的结果对比，我们发现 **QTextStream 的`readLine`会丢弃换行符**，而 QFile 的不会；QTextStream 的`size`与其流的位置无关；**QTextStream 会根据流中的数据自动检测基数**；**如果设定输出宽度大于1，那么输出换行符会输出输出宽度减1个填充字符**。

<h3 id="qdatastream">QDataStream</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qdatastream.h`和`qdatastream.cpp`。

QDataStream 支持 QIODevice 和 QByteArray，它提供二进制数据的序列化。查看[这篇文章](http://blog.csdn.net/feiyinzilgd/article/details/6107587)，大概了解了**QDataStream 与 QTextStream 唯一的不同就是它提供了数据的序列化，这样在传输数据和解析数据时会更加方便**。

<h3 id="qdebug">QDebug</h3>

你可以在`qtbase-5.9\src\corelib\io`目录下找到`qdebug.h`和`qdebug.cpp`。

QDebug 提供调试信息的输出流，其有五个全局的默认实例定义：

```c++
#define qDebug QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).debug
#define qInfo QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).info
#define qWarning QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).warning
#define qCritical QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).critical
#define qFatal QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).fatal
```

你可以简单的像printf一样使用，也可以像流一样使用：

```c++
#include <QDebug>

int main(void)
{
	qInfo() << "C++ Style Info Message";
	qInfo("C Style Info Message");

	qDebug() << "C++ Style Debug Message";
	qDebug("C Style Debug Message");

	qWarning() << "C++ Style Warning Message";
	qWarning("C Style Warning Message");

	qCritical() << "C++ Style Critical Error Message";
	qCritical("C Style Critical Error Message");

	// qFatal does not have a C++ style method.
	qFatal("C Style Fatal Error Message");

	return 0;
}
```

**定义`QT_NO_WARNING_OUTPUT`或`QT_NO_DEBUG_OUTPUT`会屏蔽掉qWarning或qDebug的输出**。

**一般在Qt中打印输出信息时，都会使用 QDebug**。

<h2 id="qt_widget">Qt 部件</h2>

<h3 id="qapplication">QApplication</h3>

你可以在`qtbase-5.9\src\widgets\kernel`目录下找到`qapplication.h`和`qapplication.cpp`。

QApplication 管理GUI应用的控制流和主要设置，它继承自 QGUIApplication，实现了一些基于 QWidget 的应用程序所需要的功能。**使用Qt的任何GUI应用，都需要一个 QApplication 对象，不管该应用有多少个窗口**。**对于非基于 QWidget 的Qt应用，可以使用 QGUIApplication 代替**，因为 QGUIApplication 不依赖于 QtWidget 库。

一些GUI应用提供特殊的批处理模式，如根据提供的命令行参数执行相关任务而不能人工干预，在这种非GUI模式下，**只需要实例化一个简单的 QCoreApplication 就足够了**，这避免了不必要的图形用户界面所需资源的初始化，官方示例如下：

```c++
QCoreApplication* createApplication(int &argc, char *argv[])
{
	for (int i = 1; i < argc; ++i)
		if (!qstrcmp(argv[i], "-no-gui"))
			return new QCoreApplication(argc, argv);
	return new QApplication(argc, argv);
}

int main(int argc, char* argv[])
{
	QScopedPointer<QCoreApplication> app(createApplication(argc, argv));

	if (qobject_cast<QApplication *>(app.data())) {
		// start GUI version...
	}
	else {
		// start non-GUI version...
	}

	return app->exec();
}
```

查看 QCoreApplication、QGUIApplication、QApplication 源码，你会发现一个名为`qApp`的预定义变量：

```c++
// QCoreApplication.h
#define qApp QCoreApplication::instance()
static QCoreApplication *instance() { return self; }
static QCoreApplication *self;

// QGUIApplication.h
#if defined(qApp)
#undef qApp
#endif
#define qApp (static_cast<QGuiApplication *>(QCoreApplication::instance()))

// QApplication.h
#if defined(qApp)
#undef qApp
#endif
#define qApp (static_cast<QApplication *>(QCoreApplication::instance()))
```

通过上面的源码我们知道，该qApp指向当前 QCoreApplication 系列实例。

QApplication 的主要责任有：

*	使用用户的桌面设置初始化应用；
*	执行事件处理；
*	解析常见的命令行参数，从而设置相应的内部状态；
*	定义应用的外观和感觉；
*	指定应用如何分配颜色；
*	字符串的本地化；
*	提供了一些神奇的实例，如`desktop()`和`clipboard()`
*	掌控所有窗口的部件位置；
*	管理应用的鼠标光标处理；

由于 QApplication 做了这么多初始化，所以**它必须在创建与用户界面相关的任何其他对象之前被创建**。

<h3 id="qwidget">QWidget</h3>

你可以在`qtbase-5.9\src\widgets\kernel`目录下找到`qwidget.h`和`qwidget.cpp`。

QWidget 是所有用户界面对象的基类，QDialog、QMainWindow、QLabel、QPushButton、QListWidget等都是它的子类。查看其公有构造函数：

```c++
explicit QWidget(QWidget* parent = Q_NULLPTR, Qt::WindowFlags f = Qt::WindowFlags());
```

当不传入参数或传入的第一个参数为空时，表示该部件是一个窗口，也被称为顶层部件(top-level widget)，你可以使用成员函数`setWindowTitle`来设置标题栏，`setWindowIcon`来设置窗口图标。**QMainWindow 和 QDialog 的各种子类是Qt中最常用的窗口类型**。

当传入的第一个参数不为空时，表示该部件是传入参数的一个子部件，**当父部件被删除时，所有该父部件的子部件都将被删除**。**当你为一个可视部件添加一个子部件时，要想子部件变得可见，你必须显式调用成员函数`show()`**。

关于第二个参数，你可以在`qtbase-5.9\src\corelib\global\qnamespace.h`中找到`enum WindowType`，它随后被声明为`WindowFlags`；该参数被用来指定部件的各种窗口系统属性，它们通常不怎么被使用，你可以查看[官方文档](http://doc.qt.io/qt-5/qt.html#WindowType-enum)了解各种标志的意义。

QWidget 包含[相当多的功能和属性](http://doc.qt.io/qt-5/qwidget.html#groups-of-functions-and-properties)，其中最常用的就是事件处理。**要想进行事件处理，你必须继承 QWidget，然后重新定义相关的事件处理函数**，下面就来做一些演示：

我们首先继承 QWidget，定义一个 myWidget 新类，该类重定义了相当多的事件：

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDebug>
#include <QWidget>
#include <QString>
#include <QMouseEvent>

class myWidget :public QWidget
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QWidget(parent)
	{}

private:
#define eventOccured qDebug() << __func__ << " called."

protected:
	// 鼠标按下、移动、释放、双击、滚轮滚动事件
	void mousePressEvent(QMouseEvent* event) override;
	void mouseMoveEvent(QMouseEvent*) override { eventOccured; };
	void mouseReleaseEvent(QMouseEvent*) override { eventOccured; };
	void mouseDoubleClickEvent(QMouseEvent*) override { eventOccured; };
	void wheelEvent(QWheelEvent*) override { eventOccured; };

	// 键盘按下、释放事件
	void keyPressEvent(QKeyEvent*) override { eventOccured; };
	void keyReleaseEvent(QKeyEvent*) override { eventOccured; };

	// 鼠标光标进入部件区域、离开部件区域事件
	void enterEvent(QEvent*) override { eventOccured; };
	void leaveEvent(QEvent*) override { eventOccured; };

	// 部件移动事件
	void moveEvent(QMoveEvent*) override { eventOccured; };

	// 绘制事件，当update()或repaint()被调用或组件需要被绘制时发生
	void paintEvent(QPaintEvent*) override { eventOccured; };

	// 组件大小发生了变化
	void resizeEvent(QResizeEvent*) override { eventOccured; };

	// 组件被关闭了
	void closeEvent(QCloseEvent*) override { eventOccured; };
};

// ！！！注意：不加inline会报错，这与Q_OBJECT有关
inline void myWidget::mousePressEvent(QMouseEvent* event)
{
	QString button;
	switch (event->button())
	{
	case Qt::LeftButton:
		button = "LeftButton"; break;
	case Qt::RightButton:
		button = "RightButton"; break;
	case Qt::MidButton:
		button = "MidButton"; break;
	default:
		return;
	}
	qDebug() << button << " clicked.";
}

#endif // MYWIDGET_HPP
```

然后在main.cpp中使用它：

```c++
#include <QApplication>
#include "myWidget.hpp"

int main(int argc, char *argv[]) 
{
	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("event handlers");
	window.show();

	return app.exec();
}
```

重新构建工程`qmake -project`，在生成的`.pro`文件后添加：

```text
QT += widgets
CONFIG += console
```

其中widgets用来显示部件、console用来在命令行下输出打印信息。

触发相应事件，得到打印输出如下：

```text
moveEvent  called.
resizeEvent  called.
paintEvent  called.
enterEvent  called.
leaveEvent  called.
moveEvent  called.
moveEvent  called.
moveEvent  called.
enterEvent  called.
"LeftButton"  clicked.
mouseReleaseEvent  called.
mouseDoubleClickEvent  called.
mouseReleaseEvent  called.
wheelEvent  called.
"MidButton"  clicked.
mouseReleaseEvent  called.
"RightButton"  clicked.
mouseReleaseEvent  called.
leaveEvent  called.
resizeEvent  called.
paintEvent  called.
resizeEvent  called.
paintEvent  called.
resizeEvent  called.
paintEvent  called.
keyPressEvent  called.
keyReleaseEvent  called.
keyPressEvent  called.
keyReleaseEvent  called.
enterEvent  called.
"LeftButton"  clicked.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseMoveEvent  called.
mouseReleaseEvent  called.
leaveEvent  called.
closeEvent  called.
```

<h3 id="qmenu">QMenu</h3>

你可以在`qtbase-5.9\src\widgets\widgets`目录下找到`qmenu.h`和`qmenu.cpp`。

菜单栏是GUI应用的常见部分，QMenu 就是Qt专门用来做菜单的类。**一个菜单栏部件是一个选择菜单，它可以是位于菜单栏的下拉菜单、也可以是点击右键或某个特定按钮出现的独立上下文菜单**。QMenu 还支持撕下菜单(tear-off menu)，撕下菜单是一个顶层窗口，用户可以把它“撕下”放在其他位置。

**一个菜单包含一个操作选项列表，该列表垂直排列，每个操作选项可以拥有一个文本标签、位于左侧的图标和一个快捷键**。操作选项有四种类型：分割线、子菜单、部件(QWidgetAction)、执行某个特定操作。

当插入某个操作选项时，你通常需要为其指定一个接收者和一个槽(slot)：每当该操作选项被触发时，就会发出信号提醒接收者，然后执行对应的slot。这是Qt中的一大特性，**如果你想自定义类支持这种信号槽机制的话，就需要像上面的myWidget一样在头文件中加上`Q_OBJECT`宏，然后信号函数用`Q_SIGNALS`标注、槽函数用`Q_SLOTS`标注，如下所示：

```c++
class Example
{
	Q_OBJECT

public:
	Example();
	~Example();
Q_SIGNALS:
	void signal();
Q_SLOTS:
	void slot();
}
```

我们查看 QMenu 的源代码：

```c++
// 菜单系列函数
QAction *addMenu(QMenu *menu);
QMenu *addMenu(const QString &title);
QMenu *addMenu(const QIcon &icon, const QString &title); // 专为子菜单
QAction *addSeparator();
QAction *insertMenu(QAction *before, QMenu *menu);
QAction *insertSeparator(QAction *before);
// 操作选项系列函数
void addAction(QAction *action);
void addActions(QList<QAction*> actions);
...
void insertActions(QAction *before, QList<QAction*> actions);
void insertAction(QAction *before, QAction *action);
void removeAction(QAction *action);
QList<QAction*> actions() const;
// 使能撕下菜单
void setTearOffEnabled(bool);
// 要想QMenu可见，必须调用popup或exec而不是show
void popup(const QPoint &pos, QAction *at = Q_NULLPTR);
QAction *exec();
QAction *exec(const QPoint &pos, QAction *at = Q_NULLPTR);
// 信号
Q_SIGNALS:
    void aboutToShow();
    void aboutToHide();
    void triggered(QAction *action);
    void hovered(QAction *action);
```

演示：

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QIcon>
#include <QDebug>
#include <QCursor>
#include <QString>
#include <QMenuBar>
#include <QMouseEvent>
#include <QMainWindow>
#include <QKeySequence>
#include <QApplication>

class myWidget :public QMainWindow
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QMainWindow(parent)
	{
		menu = menuBar()->addMenu(QString("&File"));

		QAction *openAction = menu->addAction(
			QIcon("open.png"),
			QString("&Open"),
			[] {qDebug() << "open action clicked."; },
			QKeySequence("CTRL+O"));

		QAction *quitAction = menu->addAction(
			QIcon("quit.png"),
			QString("&Quit"),
			qApp,
			&QApplication::quit,
			QKeySequence("CTRL+Q"));

		QAction *SepAction = menu->insertSeparator(quitAction);

		QAction *newAction = new QAction(QIcon("new.png"), "&New", this);
		newAction->setShortcut(QKeySequence("CTRL+N"));
		menu->insertAction(SepAction, newAction);
		// 连接信号槽
		connect(newAction, &QAction::triggered, this, &myWidget::newActionClicked);

		// 设置鼠标光标悬停提示
		menu->setTearOffEnabled(true);
		menu->setToolTipsVisible(true);
		openAction->setToolTip("open action");
		newAction->setToolTip("new action");
		SepAction->setToolTip("separator");
		quitAction->setToolTip("quit action");
	}

private:
	void newActionClicked()
	{
		qDebug() << "new action clicked.";
	}

	void mousePressEvent(QMouseEvent* event) override;

	QMenu *menu;
};

inline void myWidget::mousePressEvent(QMouseEvent* event)
{
	if (event->button() == Qt::RightButton)
	{
		if (menu) {
			menu->exec(QCursor::pos());
		}
	}
}

#endif // MYWIDGET_HPP
```

```c++
#include "myWidget.hpp"

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("QMenu");
	window.show();

	return app.exec();
}
```

<h3 id="qtoolbar">QToolBar</h3>

你可以在`qtbase-5.9\src\widgets\widgets`目录下找到`qtoolbar.h`和`qtoolbar.cpp`。

工具栏也是GUI应用常见的部分，其通常包含菜单栏里比较常用的操作选项，QToolBar 是Qt专门用来做工具栏的类。

与 QMenu 不同，QToolBar 没有`addMenu`或`insertMenu`函数，但是它有`addWidget`和`insertWidget`函数，这意味着你可以显式向工具栏里添加各种部件，但是**如果你的 QToolBar 不是 QMainWindow 的子部件的话，你就不能使用`addWidget`和`insertWidget`函数，你只能像 QMenu 一样继承`QWidgetAction`，然后使用`addAction`或`insertAction`**。**另外 QToolBar 不能设置快捷键**，所以相应的`addAction`会少一个参数。

默认工具栏是可以在工具栏区域移动的，你也可以使用`setMovable`来禁用这个功能。当工具栏项目太多导致工具栏无法全部显示时，工具栏会自动在最后面显示一个扩展按钮，点击该扩展按钮，将会弹出一个菜单显示没有在工具栏里显示的项目。

**由于 QToolBar 很多特性都是基于 QMainWindow 的，所以如果你要使用 QToolBar 的话，建议一致使用 QMainWindow**。

演示：

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QIcon>
#include <QDebug>
#include <QString>
#include <QToolBar>
#include <QMainWindow>
#include <QKeySequence>
#include <QApplication>

class myWidget :public QMainWindow
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QMainWindow(parent)
	{
		QToolBar *toolbar = addToolBar("main toolbar");
		toolbar->setMovable(false);

		QAction *openAction = toolbar->addAction(
			QIcon("open.png"),
			QString("&Open"),
			[] {qDebug() << "open action clicked."; });

		QAction *quitAction = toolbar->addAction(
			QIcon("quit.png"),
			QString("&Quit"),
			qApp,
			&QApplication::quit);

		QAction *SepAction = toolbar->insertSeparator(quitAction);

		QAction *newAction = new QAction(QIcon("new.png"), "&New", this);
		toolbar->insertAction(SepAction, newAction);
		// 连接信号槽
		connect(newAction, &QAction::triggered, this, &myWidget::newActionClicked);

		// 设置鼠标光标悬停提示
		openAction->setToolTip("open action");
		newAction->setToolTip("new action");
		SepAction->setToolTip("separator");
		quitAction->setToolTip("quit action");
	}

private:
	void newActionClicked()
	{
		qDebug() << "new action clicked.";
	}
};

#endif // MYWIDGET_HPP
```

```c++
#include "myWidget.hpp"

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("QToolBar");
	window.show();

	return app.exec();
}
```

<h3 id="qt_common_widgets">常用小部件</h3>

GUI常用的小部件无非按钮、文本框、标签、下拉框、复选框、滚动条、状态栏七种，在Qt中，按钮用`QPushButton`实现、文本框分为`QTextEdit`(大型文本)和`QLineEdit`(行文本)以及`QPlainTextEdit`(纯文本)、标签用`QLabel`实现、下拉框分为`QComboBox`和`QSpinBox`以及`QDoubleSpinBox`、复选框用`QCheckBox`实现、滚动条分为`QSlider`和`QScrollBar`、状态栏用`QStatusBar`实现。

这些小部件非常简单，查看其头文件就知道怎么用了，看看官方说明文档也非常快，再结合之前的事件处理、信号槽知识，使用起来应该没什么大问题：

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDebug>
#include <QLabel>
#include <QSlider>
#include <QPixmap>
#include <QString>
#include <QSpinBox>
#include <QCheckBox>
#include <QTextEdit>
#include <QLineEdit>
#include <QComboBox>
#include <QStatusBar>
#include <QStringList>
#include <QPushButton>
#include <QMainWindow>
#include <QApplication>
#include <QPlainTextEdit>

class myWidget :public QMainWindow
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QMainWindow(parent)
	{
		mWidget = nullptr;
	}

	void showPushButton();
	void showTextEdit();
	void showLineEdit();
	void showPlainTextEdit();
	void showLabel();
	void showComboBox();
	void showSpinBox();
	void showCheckBox();
	void showSlider();
	void showStatusBar();

protected:
	void paintEvent(QPaintEvent*) override;

private:
	QWidget *mWidget;
};

inline void myWidget::paintEvent(QPaintEvent*)
{
	if (mWidget) {
		int relative_x = width() / 4;
		int relative_y = height() / 4;
		int widget_width = width() / 2;
		int widget_height = height() / 2;
		mWidget->setGeometry(relative_x, relative_y, widget_width, widget_height);
		mWidget->setVisible(true);
		mWidget->show();
	}
}

inline void myWidget::showPushButton()
{
	QPushButton *tmp = new QPushButton("QPushButton", this);
	connect(tmp, &QPushButton::clicked,
		[] {qDebug() << "QPushButton clicked."; });

	mWidget = tmp;
	update();
}

inline void myWidget::showTextEdit()
{
	QTextEdit *tmp = new QTextEdit("QTextEdit", this);
	connect(tmp, &QTextEdit::textChanged,
		[] {qDebug() << "QTextEdit textChanged."; });

	mWidget = tmp;
	update();
}

inline void myWidget::showLineEdit()
{
	QLineEdit *tmp = new QLineEdit("QLineEdit", this);
	connect(tmp, &QLineEdit::editingFinished,
		[] {qDebug() << "QLineEdit editingFinished."; });

	mWidget = tmp;
	update();
}

inline void myWidget::showPlainTextEdit()
{
	QPlainTextEdit *tmp = new QPlainTextEdit("QPlainTextEdit", this);
	connect(tmp, &QPlainTextEdit::textChanged,
		[] {qDebug() << "QPlainTextEdit textChanged."; });

	mWidget = tmp;
	update();
}

inline void myWidget::showLabel()
{
	QLabel *tmp = new QLabel("QLabel", this);
	tmp->setPixmap(QPixmap("stock-photo-8"));

	mWidget = tmp;
	update();
}

inline void myWidget::showComboBox()
{
	QComboBox *tmp = new QComboBox(this);
	QStringList strList{ "str0","str1","str2","str3" };
	tmp->addItems(strList);
	tmp->setCurrentIndex(2);
	connect(tmp, static_cast<void(QComboBox::*)(const QString &)>(&QComboBox::currentIndexChanged),
		[](const QString &str) {qDebug() << "QComboBox current item is " << str; });

	mWidget = tmp;
	update();
}

inline void myWidget::showSpinBox()
{
	QSpinBox *tmp = new QSpinBox(this);
	tmp->setRange(0, 100);
	tmp->setWrapping(true);
	tmp->setValue(1);
	tmp->setSingleStep(2);
	connect(tmp, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged),
		[](int i) {qDebug() << "QSpinBox current value is " << i; });

	mWidget = tmp;
	update();
}

inline void myWidget::showCheckBox()
{
	QCheckBox *tmp = new QCheckBox("QCheckBox", this);
	connect(tmp, &QCheckBox::stateChanged,
		[](int state) {qDebug() << "QCheckBox current state is " << (state ? "true" : "false"); });

	mWidget = tmp;
	update();
}

inline void myWidget::showSlider()
{
	QSlider *tmp = new QSlider(Qt::Horizontal, this);
	tmp->setRange(0, 100);
	tmp->setSingleStep(10);
	tmp->setSliderPosition(50);
	connect(tmp, &QSlider::sliderMoved,
		[](int pos) {qDebug() << "QSlider current position is " << pos; });

	mWidget = tmp;
	update();
}

inline void myWidget::showStatusBar()
{
	QStatusBar *tmp = new QStatusBar(this);
	connect(tmp, &QStatusBar::messageChanged,
		[](const QString &text) {qDebug() << "QStatusBar messageChanged: " << text; });
	tmp->showMessage("QStatusBar");
	statusBar()->showMessage("QStatusBar");

	mWidget = tmp;
	update();
}

#endif // MYWIDGET_HPP
```

```c++
#include <QMap>
#include "myWidget.hpp"

static QMap<QString, int> COMMAND_MAP{
	{ "pushButton",0 },
	{ "textEdit",1 },
	{ "lineEdit",2 },
	{ "plainTextEdit",3 },
	{ "label",4 },
	{ "comboBox",5 },
	{ "spinBox",6 },
	{ "checkBox",7 },
	{ "slider",8 },
	{ "statusBar",9 }
};

void showWidget(myWidget *w, QString state);

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("mutiWidgets");
	window.show();

	if (argc != 1) {
		showWidget(&window, argv[1]);
	}

	return app.exec();
}

void showWidget(myWidget *w, QString state)
{
	if (!w) return;

	auto ret = COMMAND_MAP.find(state);
	if (COMMAND_MAP.end() == ret) {
		return;
	}

	switch (ret.value())
	{
	case 0:
		w->showPushButton();
		break;
	case 1:
		w->showTextEdit();
		break;
	case 2:
		w->showLineEdit();
		break;
	case 3:
		w->showPlainTextEdit();
		break;
	case 4:
		w->showLabel();
		break;
	case 5:
		w->showComboBox();
		break;
	case 6:
		w->showSpinBox();
		break;
	case 7:
		w->showCheckBox();
		break;
	case 8:
		w->showSlider();
		break;
	case 9:
		w->showStatusBar();
		break;
	default:
		break;
	}
}
```

<h3 id="qsplitter">QSplitter</h3>

QSplitter 可以让用户通过拖拽相邻组件的边界来控制组件的相对大小，它不怎么常用：

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDebug>
#include <QWidget>
#include <QTextEdit>
#include <QSplitter>
#include <QHeaderView>
#include <QListWidget>
#include <QTreeWidget>
#include <QVBoxLayout>
#include <QApplication>
#include <QListWidgetItem>
#include <QTreeWidgetItem>

class myWidget :public QWidget
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QWidget(parent)
	{
		initListWidget();
		initTreeWidget();

		QSplitter *splitter1 = new QSplitter(Qt::Horizontal, this);
		QSplitter *splitter2 = new QSplitter(Qt::Vertical, this);

		splitter1->addWidget(mpListWidget);
		splitter1->addWidget(mpTreeWidget);
		splitter2->addWidget(splitter1);
		splitter2->addWidget(new QTextEdit("QTextEdit", this));

		QVBoxLayout *vbox = new QVBoxLayout(this);
		vbox->addWidget(splitter2);
		setLayout(vbox);
	}

private:
	void initListWidget();
	void initTreeWidget();

	QListWidget *mpListWidget;
	QTreeWidget *mpTreeWidget;
};

inline void myWidget::initListWidget()
{
	mpListWidget = new QListWidget(this);

	QListWidgetItem *item1 = new QListWidgetItem();
	QListWidgetItem *item2 = new QListWidgetItem();
	QListWidgetItem *item3 = new QListWidgetItem();

	item1->setText("file");
	item1->setIcon(QIcon("file.png"));
	item2->setText("new");
	item2->setIcon(QIcon("new.png"));
	item3->setText("open");
	item3->setIcon(QIcon("open.png"));

	mpListWidget->addItem(item1);
	mpListWidget->addItem(item2);
	mpListWidget->addItem(item3);
}

inline void myWidget::initTreeWidget()
{
	mpTreeWidget = new QTreeWidget(this);

	mpTreeWidget->setHeaderLabel("header");
	mpTreeWidget->header()->close();

	QTreeWidgetItem *item1 = new QTreeWidgetItem();
	QTreeWidgetItem *item2 = new QTreeWidgetItem();
	QTreeWidgetItem *item3 = new QTreeWidgetItem();
	QTreeWidgetItem *item4 = new QTreeWidgetItem();

	item1->setText(0, "file");
	item1->setIcon(0, QIcon("file.png"));
	item2->setText(0, "new");
	item2->setIcon(0, QIcon("new.png"));
	item3->setText(0, "open");
	item3->setIcon(0, QIcon("open.png"));
	item4->setText(0, "quit");
	item4->setIcon(0, QIcon("quit.png"));

	item1->addChild(item2);
	item2->addChild(item3);

	mpTreeWidget->addTopLevelItem(item1);
	mpTreeWidget->addTopLevelItem(item4);
}

#endif // MYWIDGET_HPP
```

```c++
#include "myWidget.hpp"

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("view");
	window.show();

	return app.exec();
}
```

<h3 id="progressbar">QProgressBar</h3>

优秀的gui应用都是立即响应的，这意味着当用户做完某个操作时，可以立即做下一个操作。如果某个操作特别耗时，应用就会卡住，所以一般耗时的操作都是交给另一个线程去做的，主线程只需要显示操作的进度即可。

Qt中的线程类是 QThread，你可以参照[官网](http://doc.qt.io/qt-5/qthread.html#details)进行使用；QProgressBar 是Qt中用来显示进度的组件，你可以在`qtbase-5.9\src\widgets\widgets`目录下找到`qprogressbar.h`和`qprogressbar.cpp`，其使用非常简单，但有一些技巧：

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDebug>
#include <QTimer>
#include <QWidget>
#include <QVBoxLayout>
#include <QApplication>
#include <QProgressBar>

class myWidget :public QWidget
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QWidget(parent)
	{
		mpTimer = new QTimer();
		mpTimer->setInterval(100);

		mpProgressBar = new QProgressBar(this);
		mpProgressBar->setRange(0, 100);

		mProgressValue = 0;

		QVBoxLayout *vbox = new QVBoxLayout(this);
		vbox->addWidget(mpProgressBar);
		setLayout(vbox);
	}

	void progressStart()
	{
		connect(mpTimer, &QTimer::timeout, this, &myWidget::onTimeout);

		mProgressValue = 0;
		mpTimer->start();
		show();
	}

	void progressEnd()
	{
		disconnect(mpTimer, &QTimer::timeout, this, &myWidget::onTimeout);

		mProgressValue = mpProgressBar->maximum();
		mpTimer->stop();
		close();
	}

	void setProgressValue(int value)
	{
		if (value <= mpProgressBar->maximum() &&
			value >= mpProgressBar->minimum()) {
			mProgressValue = value;
		}
	}

private:
	void onTimeout();

	QTimer *mpTimer;
	QProgressBar *mpProgressBar;
	int mProgressValue;
};

inline void myWidget::onTimeout()
{
	mpProgressBar->setValue(mProgressValue);
}

#endif // MYWIDGET_HPP
```

```c++
#ifndef MYPROGRESS_HPP
#define MYPROGRESS_HPP

#include "myWidget.hpp"
#include <QThread>
#include <thread> // slepp_for

class myProgress :public QThread
{
	Q_OBJECT

private:
	myWidget *mpProgressBar;

	void run() override
	{
		if (mpProgressBar) {
			emit begin();
			std::this_thread::sleep_for(std::chrono::duration<double, std::milli>(2000));
			mpProgressBar->setProgressValue(10);
			std::this_thread::sleep_for(std::chrono::duration<double, std::milli>(5000));
			mpProgressBar->setProgressValue(70);
			std::this_thread::sleep_for(std::chrono::duration<double, std::milli>(3000));
			mpProgressBar->setProgressValue(100);
			std::this_thread::sleep_for(std::chrono::duration<double, std::milli>(500));
			emit end();
		}
	}

public:
	myProgress(myWidget *w)
		:mpProgressBar(w)
	{}

signals:
	void begin();
	void end();
};

#endif // MYPROGRESS_HPP
```

```c++
#include "myProgress.hpp"

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 50);
	window.move(300, 300);
	window.setWindowTitle("QProgressBar");

	myProgress *pro = new myProgress(&window);
	QObject::connect(pro, &myProgress::begin, &window, &myWidget::progressStart);
	QObject::connect(pro, &myProgress::end, &window, &myWidget::progressEnd);
	QObject::connect(pro, &QThread::finished, pro, &QObject::deleteLater);
	pro->start();

	return app.exec();
}
```

<h3 id="qpainter">QPainter</h3>

你可以在`qtbase-5.9\src\gui\painting`目录下找到`qpainter.h`和`qpainter.cpp`。

<h3 id="qgraphicsscene_qgraphicsview_qgraphicsitem">QGraphicsScene、QGraphicsView、QGraphicsItem</h3>

虽然 QLabel 可以用来显示图像，但是 Qt 有专门的图形视图工具。查看[Graphics View Framework](http://doc.qt.io/qt-5/graphicsview.html)，我们知道图形视图提供了一个用于管理和交互大量自定义的2D图形项目的界面，和一个用于可视化图形项目、并且支持缩放和旋转的视图组件。

如果你有大量的图像需要同时显示的话，使用图形视图工具；如果只有固定几张图片，可以使用 QLabel 来实现，但是一个 QLabel 又只能显示一张图片，就不太好管理，所以**如果仅需要显示一张图片，你可以使用 QLabel，否则使用图形视图工具**。

**图形视图基于项目，其场景(scene)使用 QGraphicsScene 实现、视图使用 QGraphicsView 实现、项目使用 QGraphicsItem 实现**。

你可以在`qtbase-5.9\src\widgets\graphicsview`目录下找到对应的源码。

QGraphicsScene 是 QGraphicsItem 的容器，你可以使用`QGraphicsScene::addItem()`来添加一个项目，然后通过各种项目搜索函数来获取一个或多个项目，项目的顺序与视图顺序一致；你也可以通过`QGraphicsScene::selectedItems()`和`QGraphicsScene::focusItem()`来管理选择项和聚焦项。

QGraphicsView 用于可视化 QGraphicsScene 包含的项目，其视图是一个提供滚动条的滚动区域，而 QLabel 需要自行添加滚动条(如果图片太大的话)，所以**如果需要显示的图片足够大以致需要滚动条的话，使用 QGraphicsView 比使用 QLabel 更加方便**。另外，使用`QGraphicsView::transform()`可以进行视图的缩放与旋转变换(查看scale源码)；你还可以使用`QGraphicsView::render()`将场景中的部分渲染到 QPainter 中，这对截屏非常有用。

QGraphicsItem 是图形项目的基类，已实现的项目类有线(QGraphicsLineItem)、矩形(QGraphicsRectItem)、椭圆(QGraphicsEllipseItem)、多边形(QGraphicsPolygonItem)、图像(QGraphicsPixmapItem)、文本(QGraphicsTextItem)和简单文本(QGraphicsSimpleTextItem)，如果你想自定义项目的话，可以构建 QGraphicsItem 的子类来实现。**QGraphicsItem 也支持缩放和旋转，使用`QGraphicsItem::transform()`**。

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDir>
#include <QList>
#include <QDebug>
#include <QPointF>
#include <QPixmap>
#include <QPainter>
#include <QFileDialog>
#include <QWheelEvent>
#include <QApplication>
#include <QGraphicsView>
#include <QGraphicsScene>
#include <QGraphicsPixmapItem>

class myWidget :public QGraphicsView
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QGraphicsView(parent)
	{
		m_pScene = nullptr;
		m_scaleFactor = 0.1;
	}

	void setPixmap(const QPixmap&);
	void addPixmap(const QPixmap&);
	public slots:

	// 旋转
	void myRotate(int angle)
	{
		// rotate相对当前视图
		static int preAngle = 0;
		rotate(angle - preAngle);

		preAngle = angle;
	};

	// 截屏
	void capture()
	{
		// QRect viewRect = viewport()->rect();
		// QPixmap pixmap(viewRect.size()); // 必须初始化！
		// QPainter painter(&pixmap);
		// painter.setRenderHint(QPainter::Antialiasing);
		// render(&painter,QRectF(viewRect),viewRect);
		// painter.end();

		QPixmap pixmap = QWidget::grab(viewport()->rect());

		QString fileName = QFileDialog::getSaveFileName(
			this,
			"Save image",
			QDir::currentPath(),
			"PNG (*.png);;BMP Files (*.bmp);;JPEG (*.JPEG)");
		if (!fileName.isNull())
		{
			pixmap.save(fileName);
		}
	}

	// 添加图片
	void addImage()
	{
		QStringList imgList = QFileDialog::getOpenFileNames(
			this,
			"add images",
			QDir::currentPath(),
			"Images (*.png *.bmp *.jpg)");
		for (QString &path : imgList)
		{
			addPixmap(QPixmap(path));
		}
	}

protected:
	void wheelEvent(QWheelEvent*) override;

private:
	void zoomIn()
	{
		qreal sx, sy;
		sx = sy = 1 + m_scaleFactor;
		myScale(sx, sy);
	};

	void zoomOut()
	{
		qreal sx, sy;
		sx = sy = 1 - m_scaleFactor;
		myScale(sx, sy);
	};

	// 缩放
	void myScale(qreal sx, qreal sy)
	{
		// QGraphicsView::scale(qreal sx, qreal sy)源码修改
		QTransform matrix = transform();
		matrix.scale(sx, sy);

		// 防止过大或过小
		qreal factor = matrix.mapRect(QRectF(0, 0, 1, 1)).width();
		if (factor < 0.07 || factor > 100)
			return;

		setTransform(matrix);
	}

	QGraphicsScene* m_pScene;
	qreal m_scaleFactor;
};

inline void myWidget::wheelEvent(QWheelEvent* e)
{
	// 按下ctrl键+滚轮触发缩放，否则移动滚动条
	if (e->modifiers() & Qt::ControlModifier)
	{
		// 固定值120，滚动幅度越大，事件触发次数越多
		int angle = e->angleDelta().y();

		// 在鼠标光标处进行缩放
		const ViewportAnchor anchor = transformationAnchor();
		setTransformationAnchor(QGraphicsView::AnchorUnderMouse);

		angle > 0 ? zoomIn() : zoomOut();
		setTransformationAnchor(anchor);
	}
	else
	{
		QGraphicsView::wheelEvent(e);
	}
}

inline void myWidget::setPixmap(const QPixmap &pixmap)
{
	QGraphicsScene* tmp = new QGraphicsScene();
	tmp->addPixmap(pixmap);

	qSwap(tmp, m_pScene);
	delete(tmp);

	setScene(m_pScene);
	show();
}

inline void myWidget::addPixmap(const QPixmap &pixmap)
{
	if (!m_pScene) {
		m_pScene = new QGraphicsScene();
	}

	int dy_newItem = 0;
	for (QGraphicsItem *tmp : items())
	{
		const QRectF size = tmp->boundingRect();
		dy_newItem += size.height() * tmp->scale();

		// 间隙
		dy_newItem += 5;
	}

	QGraphicsPixmapItem *pixmapItem = m_pScene->addPixmap(pixmap);
	pixmapItem->moveBy(0, dy_newItem);
	setScene(m_pScene);
	show();
}

#endif // MYWIDGET_HPP
```

```c++
#ifndef MYWINDOW_HPP
#define MYWINDOW_HPP

#include "myWidget.hpp"
#include <QSlider>
#include <QWidget>
#include <QPushButton>
#include <QHBoxLayout>
#include <QVBoxLayout>

class myWindow :public QWidget
{
	Q_OBJECT

public:
	myWindow(QWidget *parent = 0)
		:QWidget(parent)
	{
		initGraphicsView();
		initSlider();
		initAddImgBtn();
		initCaptureBtn();

		QHBoxLayout *hbox = new QHBoxLayout();
		hbox->addWidget(m_pAddImgBtn);
		hbox->addWidget(m_pCaptureBtn);

		QVBoxLayout *vbox = new QVBoxLayout(this);
		vbox->addWidget(m_pGraphicsView);
		vbox->addWidget(m_pSlider);
		vbox->addLayout(hbox);
		setLayout(vbox);
	}

private:
	void initGraphicsView();
	void initSlider();
	void initAddImgBtn();
	void initCaptureBtn();

	myWidget *m_pGraphicsView;
	QSlider *m_pSlider;
	QPushButton *m_pAddImgBtn;
	QPushButton *m_pCaptureBtn;
};

inline void myWindow::initGraphicsView()
{
	m_pGraphicsView = new myWidget(this);
}

inline void myWindow::initSlider()
{
	m_pSlider = new QSlider(Qt::Horizontal, this);
	m_pSlider->setRange(-180, 180);
	m_pSlider->setSingleStep(45);
	m_pSlider->setPageStep(45);
	m_pSlider->setSliderPosition(0);

	connect(m_pSlider, &QSlider::valueChanged,
		m_pGraphicsView, &myWidget::myRotate);
}

inline void myWindow::initAddImgBtn()
{
	m_pAddImgBtn = new QPushButton("add", this);
	connect(m_pAddImgBtn, &QPushButton::clicked,
		m_pGraphicsView, &myWidget::addImage);
}

inline void myWindow::initCaptureBtn()
{
	m_pCaptureBtn = new QPushButton("capture", this);
	connect(m_pCaptureBtn, &QPushButton::clicked,
		m_pGraphicsView, &myWidget::capture);
}

#endif // MYWINDOW_HPP
```

```c++
#include "myWindow.hpp"

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWindow window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("QGraphicsView");
	window.show();

	return app.exec();
}
```

<h2 id="widget_containers">部件容器</h2>

TBC

<h2 id="layout">各种 layout</h2>

上面我们只是将每个小部件单独显示在窗口中央，要是需要显示多个小部件的话，你就需要管理这些部件的位置和大小，这在GUI应用中通常称为布局管理(layout management)。

Qt 提供了四种布局方式：垂直布局(QVBoxLayout)、水平布局(QHBoxLayout)、网格布局(QGridLayout)和表单布局(QFormLayout)。其中表单布局由输入型控件和关联的标签组成，其布局就像你注册账号时的表单差不多，左边一列标签，右边一列输入。

你可以在`qtbase-5.9\src\widgets\kernel`目录下找到`qboxlayout.h`、`qformlayout.h`和`qgridlayout.h`。

<h3 id="qvboxlayout_qhboxlayout">QVBoxLayout、QHBoxLayout</h3>

查看`qboxlayout.h`，我们知道 QVBoxLayout 和 QHBoxLayout 都是 QBoxLayout 的子类，它们只是分别在构造时强制了项目排列的方向，QVBoxLayout 是 TopToBottom、QHBoxLayout 是 LeftToRight，所以如果你想布置一个水平或者垂直的布局，你也可以直接使用 QBoxLayout，其支持的排列方向包括：

```c++
enum Direction { LeftToRight, RightToLeft, TopToBottom, BottomToTop, 
				Down = TopToBottom, Up = BottomToTop };
```

QBoxLayout 可以添加四种项目：

*	`addWidget`,`insertWidget`：添加一个部件，可以指定拉伸因子和摆放位置，注意这个摆放位置与排列方向有很大关系；
*	`addSpacing`,`insertSpacing`：添加一个不可拉伸的空间；
*	`addStretch`,`insertStretch`：添加一个可拉伸的空项目；
*	`addLayout`,`insertLayout`：添加一个子布局。

如果你想要移除布局中某个部件，你可以使用成员函数`removeWidget`，或者你也可以调用`QWidget::hide()`来隐藏(且不占用空间)这个插件直到`QWidget::show()`被调用。

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDebug>
#include <QLabel>
#include <QWidget>
#include <QString>
#include <QLineEdit>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QApplication>

// 做一个表单，注意不能继承QMainWindow
// https://stackoverflow.com/questions/18947375/qt-compiler-complains-when-invoking-setlayout-on-my-mainwindow
class myWidget :public QWidget
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QWidget(parent)
	{
		QVBoxLayout *vbox = new QVBoxLayout(this);

		QHBoxLayout *hbox1 = new QHBoxLayout();
		QHBoxLayout *hbox2 = new QHBoxLayout();
		QHBoxLayout *hbox3 = new QHBoxLayout();

		QLabel *label1 = new QLabel("label1", this);
		QLabel *label2 = new QLabel("label2", this);
		QLabel *label3 = new QLabel("label3", this);

		QLineEdit *lineEdit1 = new QLineEdit("lineEdit1", this);
		QLineEdit *lineEdit2 = new QLineEdit("lineEdit2", this);
		QLineEdit *lineEdit3 = new QLineEdit("lineEdit3", this);

		hbox1->addWidget(label1);
		hbox1->addWidget(lineEdit1);
		hbox2->addWidget(label2);
		hbox2->addWidget(lineEdit2);
		hbox3->addWidget(label3);
		hbox3->addWidget(lineEdit3);

		vbox->addLayout(hbox1);
		vbox->addLayout(hbox2);
		vbox->addLayout(hbox3);

		setLayout(vbox);
	}
};

#endif // MYWIDGET_HPP
```

```c++
#include "myWidget.hpp"

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("QBoxLayout");
	window.show();

	return app.exec();
}
```

<h3 id="qgridlayout">QGridLayout</h3>

QGridLayout 的布局是网格型的，你可以使用`addWidget`或`addLayout`来添加部件或子布局，并指定行列位置，你也可以使用`addItem`来添加占用多个格子的项目。

与 QBoxLayout 一样，你可以使用`removeWidget`彻底删除某个部件，也可以使用`QWidget::hide()`来隐藏(但不占用空间)某个部件。

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDebug>
#include <QLabel>
#include <QWidget>
#include <QString>
#include <QLineEdit>
#include <QCheckBox>
#include <QGridLayout>
#include <QApplication>

class myWidget :public QWidget
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QWidget(parent)
	{
		QGridLayout *gl = new QGridLayout(this);

		for (int i = 0; i < 3; ++i)
		{
			QCheckBox *checkBox = new QCheckBox(this);
			QLabel *label = new QLabel(this);
			QLineEdit *lineEdit = new QLineEdit(this);

			QString num = QString::number(i);
			checkBox->setCheckState(Qt::Unchecked);
			checkBox->setText("checkBox" + num);
			label->setText("label" + num);
			lineEdit->setText("lineEdit" + num);

			gl->addWidget(checkBox, i, 0);
			gl->addWidget(label, i, 1);
			gl->addWidget(lineEdit, i, 2);
		}

		setLayout(gl);
	}
};

#endif // MYWIDGET_HPP
```

```c++
#include "myWidget.hpp"

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("QGridLayout");
	window.show();

	return app.exec();
}
```

<h3 id="qformlayout">QFormLayout</h3>

QFormLayout 只有两列，它最初被设计出来就是为了写表单用的，你可以使用如下成员函数为其添加项目：

```c++
void addRow(QWidget *label, QWidget *field);
void addRow(QWidget *label, QLayout *field);
void addRow(const QString &labelText, QWidget *field);
void addRow(const QString &labelText, QLayout *field);
void addRow(QWidget *widget);
void addRow(QLayout *layout);

void insertRow(int row, QWidget *label, QWidget *field);
void insertRow(int row, QWidget *label, QLayout *field);
void insertRow(int row, const QString &labelText, QWidget *field);
void insertRow(int row, const QString &labelText, QLayout *field);
void insertRow(int row, QWidget *widget);
void insertRow(int row, QLayout *layout);

void removeRow(int row);
void removeRow(QWidget *widget);
void removeRow(QLayout *layout);
```

演示：

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDebug>
#include <QLabel>
#include <QWidget>
#include <QString>
#include <QLineEdit>
#include <QFormLayout>
#include <QApplication>

class myWidget :public QWidget
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QWidget(parent)
	{
		QFormLayout *fl = new QFormLayout(this);

		for (int i = 0; i < 3; ++i)
		{
			QLabel *label = new QLabel(this);
			QLineEdit *lineEdit = new QLineEdit(this);

			QString num = QString::number(i);
			label->setText("label" + num);
			lineEdit->setText("lineEdit" + num);

			fl->addRow(label, lineEdit);
		}

		setLayout(fl);
	}
};

#endif // MYWIDGET_HPP
```

```c++
#include "myWidget.hpp"

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("QFormLayout");
	window.show();

	return app.exec();
}
```

<h2 id="view">各种 view</h2>

Qt 包含四种视图：QListView、QTreeView、QTableView、QColumnView，其中 QListView、QTreeView、QTableView为了方便又实现了对应三个子类 QListWidget、QTreeWidget、QTableWidget。

**view基于模型(model)，widget基于项目(item)**。

<h3 id="model_and_model_index">模型与模型索引</h3>

查看[Model/View Programming](http://doc.qt.io/qt-5/model-view-programming.html)，如果你学过Android的话，应该知道MVC设计模式--应用的所有对象分为三类：

*	模型(model)对象：存储数据与业务逻辑。不关心用户界面，它存在的唯一目的就是存储和管理应用数据；
*	视图(view)对象：凡是能够在屏幕上看见的对象，就是视图对象。视图对象知道如何在屏幕上绘制自己以及如何响应用户输入；
*	控制器(controller)对象：视图对象与模型对象的联系纽带，响应由视图对象触发的各种事件，以及管理模型对象与视图层间的数据流动。

**如果将视图对象与控制器对象合并，其结果就是模型/视图(model/view)架构**。很明显，模型/视图架构可以使用不同的视图来表示相同的数据。

查看[model class](http://doc.qt.io/qt-5/model-view-programming.html#model-classes)，我们知道**模型就是用来提供访问数据的接口，视图使用模型索引(model index)来访问数据**，模型索引包含创建它的模型的指针，**由于模型可以随时重构其内部结构，所以其模型索引(QModeIndex)可能变得不可用；如果你需要长期引用某个数据，你就需要一个持久的模型索引(QPersistentModelIndex)**。

**模型索引是访问模型数据的唯一方式**，要想获得与数据项相对应的模型索引，你必须指定模型的三个属性：行数、列数、父模型索引：

```c++
QModelIndex index = model->index(row, column, parent);
```

如果数据项是顶层数据，或者说数据项没有父模型索引，你就需要使用`QModelIndex()`来构建一个空的模型索引来充当父模型索引。查看[这里](http://doc.qt.io/qt-5/model-view-programming.html#rows-and-columns)获取更多详细信息。

演示：

```c++
#include <QDir>
#include <QDebug>
#include <QString>
#include <QDirModel>
#include <QModelIndex>

int main(void)
{
	QString path = QDir::currentPath();
	qDebug() << path;

	// QDirModel类似于树模型(tree model)
	QDirModel *model = new QDirModel();
	model->setSorting(QDir::Name | QDir::Reversed);
	QModelIndex parentIndex = model->index(path);
	int numRows = model->rowCount(parentIndex);
	for (int row = 0; row < numRows; ++row) {
		QModelIndex index = model->index(row, 0, parentIndex);
		QString text = model->data(index, QDirModel::Roles::FileNameRole).toString();
		qDebug() << text;
	}
	return 0;
}
```

查看[这里](http://doc.qt.io/qt-5/qfilesystemmodel.html#caching-and-performance)了解不用 QFileSystemModel 的原因，结果：

```text
e:\qt_project>release\qt_project.exe
"E:/qt_project"
"release"
"quit.png"
"qt_project.pro"
"open.png"
"new.png"
"myWidget.hpp"
"main.cpp"
"file.png"
"debug"
"Makefile.Release"
"Makefile.Debug"
"Makefile"
".qmake.stash"
```

<h3 id="qlistview_qtreeview_qtableview_qcolumnview">QListView、QTreeView、QTableView、QColumnView</h3>

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QDir>
#include <QDebug>
#include <QLayout>
#include <QDirModel>
#include <QListView>
#include <QTreeView>
#include <QTableView>
#include <QPaintEvent>
#include <QColumnView>
#include <QStringList>
#include <QMainWindow>
#include <QApplication>
#include <QFileSystemModel>
#include <QStringListModel>
#include <QAbstractItemView>
#include <QAbstractItemModel>
#include <QStandardItemModel>

class myWidget :public QMainWindow
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QMainWindow(parent)
	{
		mpView = nullptr;
	}

	void showListView();
	void showTreeView();
	void showTableView();
	void showColumnView();
protected:
	void paintEvent(QPaintEvent*) override;
private:
	QAbstractItemView *mpView;
};

inline void myWidget::paintEvent(QPaintEvent*)
{
	if (mpView) {
		mpView->resize(width(), height());
		mpView->show();
	}
}

inline void myWidget::showListView()
{
	QListView *view = new QListView(this);

	QStringList numbers;
	numbers << "One" << "Two" << "Three" << "Four" << "Five";
	QStringListModel *model = new QStringListModel(numbers);
	view->setModel(model);

	mpView = view;
}

inline void myWidget::showTreeView()
{
	QTreeView *view = new QTreeView(this);

	// QDirModel *model = new QDirModel();
	// model->setSorting(QDir::DirsFirst);

	QFileSystemModel *model = new QFileSystemModel();
	model->setRootPath(QDir::currentPath());
	view->setModel(model);
	view->setRootIndex(model->index(QDir::currentPath()));

	mpView = view;
}

inline void myWidget::showTableView()
{
	QTableView *view = new QTableView(this);

	QStandardItemModel *model = new QStandardItemModel(2, 3);
	QStringList header{ "col1","col2","col3" };
	model->setHorizontalHeaderLabels(header);
	view->setModel(model);

	mpView = view;
}

inline void myWidget::showColumnView()
{
	QColumnView *view = new QColumnView(this);
	QStandardItemModel *model = new QStandardItemModel();
	for (int groupnum = 0; groupnum < 3; ++groupnum)
	{
		QStandardItem *group = new QStandardItem(QString("Group %1").arg(groupnum));

		for (int personnum = 0; personnum < 5; ++personnum)
		{
			QStandardItem *child = new QStandardItem(
				QString("Person %1 (group %2)").arg(personnum).arg(groupnum));
			group->appendRow(child);
		}
		model->appendRow(group);
	}
	view->setModel(model);

	mpView = view;
}

#endif // MYWIDGET_HPP
```

```c++
#include <QMap>
#include "myWidget.hpp"

static QMap<QString, int> COMMAND_MAP{
	{ "list",0 },
	{ "tree",1 },
	{ "table",2 },
	{ "column",3 }
};

void showView(myWidget *w, QString state);

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("view");
	window.show();

	if (argc != 1) {
		showView(&window, argv[1]);
	}

	return app.exec();
}

void showView(myWidget *w, QString state)
{
	if (!w) return;

	auto ret = COMMAND_MAP.find(state);
	if (COMMAND_MAP.end() == ret) {
		return;
	}

	switch (ret.value())
	{
	case 0:
		w->showListView();
		break;
	case 1:
		w->showTreeView();
		break;
	case 2:
		w->showTableView();
		break;
	case 3:
		w->showColumnView();
		break;
	default:
		break;
	}
}
```

<h3 id="qlistwidget_qtreewidget_qtablewidget">QListWidget、QTreeWidget、QTableWidget</h3>

```c++
#ifndef MYWIDGET_HPP
#define MYWIDGET_HPP

#include <QIcon>
#include <QDebug>
#include <QHeaderView>
#include <QPaintEvent>
#include <QStringList>
#include <QMainWindow>
#include <QListWidget>
#include <QTreeWidget>
#include <QTableWidget>
#include <QApplication>
#include <QTreeWidgetItem>
#include <QListWidgetItem>
#include <QTableWidgetItem>
#include <QAbstractItemView>

class myWidget :public QMainWindow
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QMainWindow(parent)
	{
		mpWidget = nullptr;
	}

	void showListWidget();
	void showTreeWidget();
	void showTableWidget();
protected:
	void paintEvent(QPaintEvent*) override;
private:
	QAbstractItemView *mpWidget;
};

inline void myWidget::paintEvent(QPaintEvent*)
{
	if (mpWidget) {
		mpWidget->resize(width(), height());
		mpWidget->show();
	}
}

inline void myWidget::showListWidget()
{
	QListWidget *widget = new QListWidget(this);

	QListWidgetItem *item1 = new QListWidgetItem();
	QListWidgetItem *item2 = new QListWidgetItem();
	QListWidgetItem *item3 = new QListWidgetItem();

	item1->setText("file");
	item1->setIcon(QIcon("file.png"));
	item2->setText("new");
	item2->setIcon(QIcon("new.png"));
	item3->setText("open");
	item3->setIcon(QIcon("open.png"));

	widget->addItem(item1);
	widget->addItem(item2);
	widget->addItem(item3);

	mpWidget = widget;
}

inline void myWidget::showTreeWidget()
{
	QTreeWidget *widget = new QTreeWidget(this);

	widget->setHeaderLabel("header");
	widget->header()->close();

	QTreeWidgetItem *item1 = new QTreeWidgetItem();
	QTreeWidgetItem *item2 = new QTreeWidgetItem();
	QTreeWidgetItem *item3 = new QTreeWidgetItem();
	QTreeWidgetItem *item4 = new QTreeWidgetItem();

	item1->setText(0, "file");
	item1->setIcon(0, QIcon("file.png"));
	item2->setText(0, "new");
	item2->setIcon(0, QIcon("new.png"));
	item3->setText(0, "open");
	item3->setIcon(0, QIcon("open.png"));
	item4->setText(0, "quit");
	item4->setIcon(0, QIcon("quit.png"));

	item1->addChild(item2);
	item2->addChild(item3);

	widget->addTopLevelItem(item1);
	widget->addTopLevelItem(item4);

	mpWidget = widget;
}

inline void myWidget::showTableWidget()
{
	QTableWidget *widget = new QTableWidget(this);

	widget->setRowCount(2);
	widget->setColumnCount(3);
	QStringList header{ "col1","col2","col3" };
	widget->setHorizontalHeaderLabels(header);

	QTableWidgetItem *item1 = new QTableWidgetItem();
	QTableWidgetItem *item2 = new QTableWidgetItem();
	QTableWidgetItem *item3 = new QTableWidgetItem();

	item1->setText("file");
	item1->setIcon(QIcon("file.png"));
	item2->setText("new");
	item2->setIcon(QIcon("new.png"));
	item3->setText("open");
	item3->setIcon(QIcon("open.png"));

	widget->setItem(0, 0, item1);
	widget->setItem(0, 1, item2);
	widget->setItem(0, 2, item3);

	mpWidget = widget;
}

#endif // MYWIDGET_HPP
```

```c++
#include <QMap>
#include "myWidget.hpp"

static QMap<QString, int> COMMAND_MAP{
	{ "list",0 },
	{ "tree",1 },
	{ "table",2 }
};

void showWidget(myWidget *w, QString state);

int main(int argc, char *argv[]) {

	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("widget");
	window.show();

	if (argc != 1) {
		showWidget(&window, argv[1]);
	}

	return app.exec();
}

void showWidget(myWidget *w, QString state)
{
	if (!w) return;

	auto ret = COMMAND_MAP.find(state);
	if (COMMAND_MAP.end() == ret) {
		return;
	}

	switch (ret.value())
	{
	case 0:
		w->showListWidget();
		break;
	case 1:
		w->showTreeWidget();
		break;
	case 2:
		w->showTableWidget();
		break;
	default:
		break;
	}
}
```

### 建议

在演示了view和widget的使用之后，你应该感觉到使用widget会方便的多，但是要想[自定义model](http://doc.qt.io/qt-5/model-view-programming.html#creating-new-models)的话，还是要使用view才行。查看[这里](https://forum.qt.io/topic/17481/easiest-way-to-have-a-simple-list-with-custom-items/3)了解如何在widget中自定义组件：

```c++
void QListWidget::setItemWidget(QListWidgetItem *item, QWidget *widget);
void QTreeWidget::setItemWidget(QTreeWidgetItem *item, int column, QWidget *widget);
void QTableWidget::setCellWidget(int row, int column, QWidget *widget);
```

