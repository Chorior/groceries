---
title:      "Qt5 基础篇"
subtitle:   "Hello Qt5"
date:       2017-08-28 20:20:00 +0800
header-img: "img/stock-photo-8.jpg"
tags:
    - C++
    - Qt5
---

本文将根据[官方说明文档](http://doc.qt.io/qt-5/)、一些QT书籍、及一些个人经验来讲解QT的基础知识，鉴于水平有限，可能会有些错误。**但这篇文章的目的主要是我个人使用**。

#   本文结构

*   [Qt 概述](#overview)
*	[Hello QT](#hello_qt)
*	[命令行参数](#qcommandlineparser)
*   [字符串](#qstring_qbytearray)
*	[QVariant](#qvariant)

<h2 id="overview">Qt 概述</h2>

Qt 是一个跨平台的应用开发框架，它被广泛用于开发GUI应用，一些著名的软件，如Opera、Google Earth 和 Skype都是基于它进行开发的，你可以用它创建开源应用程序以及商业应用程序。相对于只支持Windows的MFC来说，虽然MFC更为强大，但是MFC的封装不是很好，很多地方很乱很杂(来自网络)，Qt除了跨平台之外，各个组件也封装得非常好，这意味着使用Qt你将更容易的编写程序。

Qt 一般使用C++进行开发，通过语言绑定，也可以使用其它语言。

Qt开放源代码，你可以在[Qt github](https://github.com/qt)上获取；其提供三种授权方式：

*	商业版：可以任意的修改源代码而不必公开，适用于开发专属或商业软件；
*	GNU LGPL：可以被专属软件作为类库引用、发布和销售；
*	GNU GPL：可以自由运行，学习，共享和修改。

<h2 id="hello_qt">Hello QT</h2>

到<http://download.qt.io/official_releases/qt/>下载开源QT，选择 mingw 安装完成后开始我们的第一个程序--Hello QT。

首先，我们创建一个文件夹，例如`E:\qt_practice`，然后创建一个main.cpp:

```c++
#include <QDebug>

int main() 
{
    qDebug() << "Hello QT.";
	return 0;
}
```

然后打开**qt命令行**：

```bash
$ cd E:\qt_practice
$ qmake -project       # 生成QT工程文件
```

这时会生成一个`.pro`文件：

```text
######################################################################
# Automatically generated by qmake (3.0) ?? ?? 28 09:37:58 2017
######################################################################

TEMPLATE = app
TARGET = qt_practice
INCLUDEPATH += .

# Input
SOURCES += main.cpp

```

由于我们需要在命令行上进行输出，所以在`.pro`文件末尾加上 `CONFIG += console`，然后执行：

```bash
$ qmake          # 生成 makefile
$ mingw32-make   # 编译
```

这里默认执行的是 `mingw32-make -f Makefile.Release`，你也可以手动执行 `mingw32-make -f Makefile.Debug`，然后你会在相应文件夹下看到可运行的exe:

```bash
$ e:\qt_practice>release\qt_practice.exe
Hello QT.

```

可以看到，qDebug 默认会输出换行。

<h2 id="qcommandlineparser">命令行参数</h2>

所谓命令行参数，举一个简单的例子 `prog -i file_in -o file_out`，其中 `file_in` 和 `file_out` 就是命令行参数，而 `i` 和 `o` 被称为命令行选项，命令行选项通常用来表示后面命令行参数的类型，这意味着你可以修改命令行参数的顺序，如 `prog -o file_out -i file_in`。

我知道 linux 下面有 `getopt` 函数可以获取命令行参数，但标准 C++ 似乎没有这种函数，所以一般我都是将命令行参数转化为 `std::string`，然后自行解析。你可以查看 [stackoverflow](https://stackoverflow.com/questions/865668/how-to-parse-command-line-arguments-in-c) 获取如何在标准 C++ 中进行命令行参数解析。

QT 提供了 QCommandLineParser 专门用于命令行参数解析。

命令行选项通常以单个破折号或双个破折号开始，**单个字母的命令行选项可以进行合并**，如 `-a -b -c` 可以写成 `-abc`，**但多个字母的命令行选项不能进行合并，且一般以双个破折号开始**。**你可以使用等号或空格符为选项赋值**，如 `-v=value --verbose=value`、`-v value --verbose value`。

我仿照官方示例做了一个演示：

```c++
#include <QDebug>
#include <QCoreApplication>
#include <QCommandLineParser>

void initInputParser(QCommandLineParser &parser);

int main(int argc, char *argv[])
{
	// QCoreApplication 提供命令行参数作为一个简单的字符串列表
	QCoreApplication app(argc, argv);
	QCoreApplication::setApplicationName("my-copy-program");
	QCoreApplication::setApplicationVersion("1.0");

	// QCommandLineParser 初始化，由于其不可复制，故而采用引用方式进行处理
	QCommandLineParser parser;
	initInputParser(parser);

	// 处理用户给出的实际命令行参数
	parser.process(app);

	// 所有基于位置的命令行参数列表，可能包含未定义的命令行参数
	const QStringList args = parser.positionalArguments();

	// 检查命令行选项是否被指定，多个名字的话被认为是相等的
	bool showProgress = parser.isSet("p");
	bool force = parser.isSet("f");
	bool target = parser.isSet("t");
	bool dft = parser.isSet("default");

	// 获取命令行选项对应的值，即命令行参数
	QString targetDir = parser.value("t");
	QString defaultName = parser.value("default-name");

	// 输出
	qDebug() << "-p: " << showProgress;
	qDebug() << "-f: " << force;
	qDebug() << "-t, --target-directory: " << target;
	qDebug() << "-d, --default, --default-name: " << dft;

	qDebug() << "target directory: " << targetDir;
	qDebug() << "default name: " << defaultName;
	
	qDebug() << "positionalArguments: ";
	for (int i = 0; i < args.size(); ++i) {
		qDebug() << " " << args[i];
	}
}

void initInputParser(QCommandLineParser &parser)
{
	parser.setApplicationDescription("Test helper");
	parser.addHelpOption();    // -h, --help and -? on Windows
	parser.addVersionOption(); // -v / --version

	// 添加基于位置的命令行参数，这意味着你不能随意调换它们的相对顺序
	// QCoreApplication::translate: 返回第二个参数翻译后的字符串，这意味着支持多种语言
	parser.addPositionalArgument("source", 
		QCoreApplication::translate("main", "Source file to copy."));
	parser.addPositionalArgument("destination", 
		QCoreApplication::translate("main", "Destination directory."));

	// http://doc.qt.io/qt-5/qcommandlineparser.html#addOptions
	// http://doc.qt.io/qt-5/qcommandlineoption.html
	parser.addOptions({
		// 不带命令行参数的命令行选项(-p)，这意味着你不能为该选项赋值
		// 第二个参数是选项描述，见帮助菜单
		{ "p",
			QCoreApplication::translate("main", "Show progress during copy") },
		// 不带命令行参数的命令行选项(-f, --force)
		// 为一个选项指定多个名字时，列表中任何单个字符的名字都被认为是短名
		// 名字列表不允许为空，名字不能以破折号或斜杠开头、不能包含=、也不能重复
		{ { "f", "force" },
			QCoreApplication::translate("main", "Overwrite existing files.") },
		// 带命令行参数的命令行选项(-t, --target-directory)
		// 第三个参数为命令行参数名，见帮助菜单
		{ { "t", "target-directory" },
			QCoreApplication::translate("main", "Copy all source files into <directory>."),
			QCoreApplication::translate("main", "directory") },
		// 带命令行参数的命令行选项(-d, --default, --default-name)
		// 第四个参数为默认选项值
		{ { "d","default","default-name" },
			QCoreApplication::translate("main", "default name <name>."),
			QCoreApplication::translate("main", "name"),
			QCoreApplication::translate("main", "untitled") }
	});
}
```

编译完成之后，首先查看 help:

```text
$ e:\qt_practice>release\qt_practice.exe -h
Usage: release\qt_practice.exe [options] source destination
Test helper

Options:
  -?, -h, --help                        Displays this help.
  -v, --version                         Displays version information.
  -p                                    Show progress during copy
  -f, --force                           Overwrite existing files.
  -t, --target-directory <directory>    Copy all source files into <directory>.
  -d, --default, --default-name <name>  default name <name>.

Arguments:
  source                                Source file to copy.
  destination                           Destination directory.

```

这样就对上面的代码有了更深的了解了，接下来我们只需要按照 help 显示的那样进行测试即可：

```cmd
$ e:\qt_practice>release\qt_practice.exe -v
my-copy-program 1.0

$ e:\qt_practice>release\qt_practice.exe -pf -t target -d default src dst undef
-p:  true
-f:  true
-t, --target-directory:  true
-d, --default, --default-name:  true
target directory:  "target"
default name:  "default"
positionalArguments:
  "src"
  "dst"
  "undef"

$ e:\qt_practice>release\qt_practice.exe src dst -t=dir undef
-p:  false
-f:  false
-t, --target-directory:  true
-d, --default, --default-name:  false
target directory:  "dir"
default name:  "untitled"
positionalArguments:
  "src"
  "dst"
  "undef"

$ e:\qt_practice>release\qt_practice.exe -a
Unknown option 'a'.

$ e:\qt_practice>release\qt_practice.exe -t
Missing value after '-t'.

$ e:\qt_practice>release\qt_practice.exe -default name
-p:  false
-f:  false
-t, --target-directory:  false
-d, --default, --default-name:  true
target directory:  ""
default name:  "efault"
positionalArguments:
  "name"

$ e:\qt_practice>release\qt_practice.exe --default name
-p:  false
-f:  false
-t, --target-directory:  false
-d, --default, --default-name:  true
target directory:  ""
default name:  "name"
positionalArguments:

```

可以看到，**如果一个选项被设置为需要一个值，则必须存在一个、当不指定有默认值的命令行选项时，就会得到该选项的默认值、使用长字符选项时一定要使用双破折号**。

<h2 id="qstring_qbytearray">字符串</h2>

QT5 默认兼容标准 C++11，但 QT4 需要在 `.pro` 文件中加上 `CONFIG += c++11`，这意味着你不必特意去学习新的类似的库，能用标准 C++ 处理的就用标准 C++ 进行处理，但在 QT 下写程序你却全部使用标准 C++，那使用 QT 的意义又在哪儿呢？由于 QT 所有 API 的参数和返回值除了简单类型之外都是自行封装的，这又意味着**你需要对 QT 的库有一定的了解才行**。

QT 有两个类来存储字符串，它们分别是 QString 和 QByteArray。其中 QString 是 QT 最为常用的字符串，因为它存储了一串 QChar 字符，而一个 QChar 提供了一个16位的 Unicode 字符；而 QByteArray 提供的是一个字节数组，即一个元素是一个字节，以空字符`'\0'`结尾的8位字符串。**除了需要存储原始二进制数据或者对内存保护要求很高的情况下，一般都推荐使用 QString，但使用 QByteArray 比使用 `const char *` 更方便，它确保数据后跟`'\0'`终止符**。

**QString 和 QByteArray 都是采用的[写时复制](http://doc.qt.io/qt-5/implicit-sharing.html)来减少内存使用量和不必要的复制操作**。

下面我们就来对 QString 的常用操作来做一个简单的演示，更多的操作你可以查看[说明文档](http://doc.qt.io/qt-5/qstring.html#details)：

```c++
#include <string>     // 标准字符串

#include <QDebug>
#include <QString>

int main()
{
	std::string std_str = "World";

	// 赋值
	QString str0 = QChar('H');                      // QChar 赋值运算符
	QString str1 = "Hello";                         // const char* 赋值运算符
	QString str2 = QString::fromStdString(std_str); // 标准字符串转 QString 
	qDebug() << str0 << " " << str1 << " " << str2;

	// 访问
	bool isEmpty = str2.isEmpty();                  // 是否为空
	int size = str0.size();                         // 获取字符串大小
	str0[0] = QChar('E');                           // 修改字符
	QChar ch = str1.at(1);                          // at 用于只读
	qDebug() << str0 << " size: " << size;
	qDebug() << str1 << ".at(1): " << ch;
	qDebug() << str2 << " is empty?: " << isEmpty;

	// 修改
	str0.prepend("haha");                           // 前置添加
	str0.push_front("wa");                          // 前置添加
	str1.append(" ");                               // 后置添加
	str1.push_back(str2);                           // 后置添加
	str1 += "!";                                    // 后置添加
	str2.insert(0, "Hello ");                       // 在位置0上插入“Hello "
	QString str3 = str2;                            // str3: Hello World
	str3.replace(6, 5, "QT");                       // 将从位置6开始的5个字符替换为"QT"
	QString str4(str3);                             // str4: Hello QT
	str4.remove(0, 6);                              // 移除从位置0开始的6个字符
	str3.swap(str4);                                // 交换
	qDebug() << str0 << " " << str1 << " "
		<< str2 << " " << str3 << " " << str4;

	// 获取子串
	QString sub0 = str2.right(5);                   // 右边5个字符
	QString sub1 = str2.mid(1, 4);                  // 位置1开始4个字符
	QString sub2 = str2.left(5);                    // 左边5个字符
	qDebug() << sub0 << " " << sub1 << " " << sub2;

	// 比较
	QString str5("_raw.png");
	QString str6("_RAW.png");
	bool equal = (str5 == str6);                    // 比较运算符
	bool startsWith = str5.startsWith("_");         // 是否以"_"开始
	bool endsWith = str5.endsWith(".png");          // 是否以".png"结尾
	bool contains =
		str5.contains("RAW", Qt::CaseInsensitive);  // 是否包含"raw",大小写无关
	qDebug() << equal << " " << startsWith << " "
		<< endsWith << " " << contains;

	// 标记替换
	QString s0 = "file name is %1, function name is %2.";
	QString s1 = s0.arg(__FILE__);                  // 将s1的最小的标记%1替换为文件名
	QString s2 = s1.arg(__func__);                  // 将s2的最小的标记%2替换为函数名
	qDebug() << s0 << "\n" << s1 << "\n" << s2;

	// 转换
	QString str_num0 = QString::number(123);        // 数字转 QString
	QString str_num1 = QString().setNum(1.234);     // 数字转 QString
	std::string std_num = str_num0.toStdString();   // QString 转 std::string
	int num0 = str_num0.toInt();                    // QString 转数字
	double num1 = str_num1.toDouble();              // QString 转数字
	str5 = str5.toUpper();                          // 转换为大写
	str6 = str6.toLower();                          // 转换为小写
	qDebug() << str_num0 << ": " << num0 << ", "
		<< str_num1 << ": " << num1;
	qDebug() << str5 << " " << str6;

	// 字符类型
	QString str7 = "7 white, 3 red roses.";
	int digits = 0, letters = 0;
	int spaces = 0, puncts = 0;
	for (const QChar &s : str7)
	{
		if (s.isDigit()) {
			digits++;
		}
		else if (s.isLetter()) {
			letters++;
		}
		else if (s.isSpace()) {
			spaces++;
		}
		else if (s.isPunct()) {
			puncts++;
		}
	}
	qDebug() << QString("There are %1 characters").arg(str7.count());
	qDebug() << QString("There are %1 letters").arg(letters);
	qDebug() << QString("There are %1 digits").arg(digits);
	qDebug() << QString("There are %1 spaces").arg(spaces);
	qDebug() << QString("There are %1 punctuation characters").arg(puncts);
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
"H"   "Hello"   "World"
"E"  size:  1
"Hello" .at(1):  'e'
"World"  is empty?:  false
"wahahaE"   "Hello World!"   "Hello World"   "QT"   "Hello QT"
"World"   "ello"   "Hello"
false   true   true   true
"file name is %1, function name is %2."
 "file name is main.cpp, function name is %2."
 "file name is main.cpp, function name is main."
"123" :  123 ,  "1.234" :  1.234
"_RAW.PNG"   "_raw.png"
"There are 21 characters"
"There are 13 letters"
"There are 2 digits"
"There are 4 spaces"
"There are 2 punctuation characters"
```

上面打印出来的字符串有引号，如果你觉得不爽的话，可以使用[qPrintable](http://doc.qt.io/qt-5/qtglobal.html#qPrintable)全局函数将 QString 转换为 `const char *`后再进行输出。

<h2 id="qvariant">QVariant</h2>
