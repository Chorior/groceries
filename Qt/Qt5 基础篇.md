---
title:      "Qt5 基础篇"
subtitle:   "Hello Qt5"
date:       2017-08-28 20:20:00 +0800
header-img: "img/stock-photo-8.jpg"
tags:
    - C++
    - Qt5
---

本文将根据[官方说明文档](http://doc.qt.io/qt-5/)、一些QT书籍、及一些个人经验来讲解QT的基础知识，鉴于水平有限，可能会有些错误。**但这篇文章的目的主要是我个人使用**。

#   本文结构

*   [Qt 概述](#overview)
*	[Hello QT](#hello_qt)
*	[命令行参数](#qcommandlineparser)
*   [字符串](#qstring_qbytearray)
*	[QVariant](#qvariant)
*	[日期时间](#qdate_qtime_and_qdatetime)
	*	[QDate](#qdate)
	*	[QTime](#qtime)
	*	[QDateTime](#qdatetime)
*	[文件输入输出](#qfile_qdir)
	*	[QFile](#qfile)
	*	[QFileInfo](#qfileinfo)
	*	[QDir](#qdir)
*	[Qt 特性](#qt_feature)
	*	[信号和槽](#signals_and_slots)
	*	[对象属性](#object_properties)	
	*	[事件系统](#event_system)
	*	[国际化字符串](#international_string)
	*	[定时器](#qtimer)
	*	[对象树](#object_tree)
	*	[QPointer](#qpointer)
	*	[元对象系统](#the_meta_object_system)
*	[GUI 基础](#gui_basic)
	*	[基础窗口部件 QWidget](#qwidget)
	*	[启动界面 QSplashScreen](#qsplashscreen)
	*	[对话框 QDialog](#qdialog)

<h2 id="overview">Qt 概述</h2>

Qt 是一个跨平台的应用开发框架，它被广泛用于开发GUI应用，一些著名的软件，如Opera、Google Earth 和 Skype都是基于它进行开发的，你可以用它创建开源应用程序以及商业应用程序。相对于只支持Windows的MFC来说，虽然MFC更为强大，但是MFC的封装不是很好，很多地方很乱很杂(来自网络)，Qt除了跨平台之外，各个组件也封装得非常好，这意味着使用Qt你将更容易的编写程序。

Qt 一般使用C++进行开发，通过语言绑定，也可以使用其它语言。

Qt开放源代码，你可以在[Qt github](https://github.com/qt)上获取；其提供三种授权方式：

*	商业版：可以任意的修改源代码而不必公开，适用于开发专属或商业软件；
*	GNU LGPL：可以被专属软件作为类库引用、发布和销售；
*	GNU GPL：可以自由运行，学习，共享和修改。

<h2 id="hello_qt">Hello QT</h2>

到<http://download.qt.io/official_releases/qt/>下载开源QT，选择 mingw 安装完成后开始我们的第一个程序--Hello QT。

首先，我们创建一个文件夹，例如`E:\qt_practice`，然后创建一个main.cpp:

```c++
#include <QDebug>

int main() 
{
    qDebug() << "Hello QT.";
	return 0;
}
```

然后打开**qt命令行**：

```bash
$ cd E:\qt_practice
$ qmake -project       # 生成QT工程文件
```

这时会生成一个`.pro`文件：

```text
######################################################################
# Automatically generated by qmake (3.0) ?? ?? 28 09:37:58 2017
######################################################################

TEMPLATE = app
TARGET = qt_practice
INCLUDEPATH += .

# Input
SOURCES += main.cpp

```

由于我们需要在命令行上进行输出，所以在`.pro`文件末尾加上 `CONFIG += console`，然后执行：

```bash
$ qmake          # 生成 makefile
$ mingw32-make   # 编译
```

这里默认执行的是 `mingw32-make -f Makefile.Release`，你也可以手动执行 `mingw32-make -f Makefile.Debug`，然后你会在相应文件夹下看到可运行的exe:

```bash
$ e:\qt_practice>release\qt_practice.exe
Hello QT.

```

可以看到，qDebug 默认会输出换行，如果你了解输出缓冲和一些输出调试的知识的话，**这个换行是为了调试方便而加上的**。

<h2 id="qcommandlineparser">命令行参数</h2>

所谓命令行参数，举一个简单的例子 `prog -i file_in -o file_out`，其中 `file_in` 和 `file_out` 就是命令行参数，而 `i` 和 `o` 被称为命令行选项，命令行选项通常用来表示后面命令行参数的类型，这意味着你可以修改命令行参数的顺序，如 `prog -o file_out -i file_in`。

我知道 linux 下面有 `getopt` 函数可以获取命令行参数，但标准 C++ 似乎没有这种函数，所以一般我都是将命令行参数转化为 `std::string`，然后自行解析。你可以查看 [stackoverflow](https://stackoverflow.com/questions/865668/how-to-parse-command-line-arguments-in-c) 获取如何在标准 C++ 中进行命令行参数解析。

QT 提供了 QCommandLineParser 专门用于命令行参数解析。

命令行选项通常以单个破折号或双个破折号开始，**单个字母的命令行选项可以进行合并**，如 `-a -b -c` 可以写成 `-abc`，**但多个字母的命令行选项不能进行合并，且一般以双个破折号开始**。**你可以使用等号或空格符为选项赋值**，如 `-v=value --verbose=value`、`-v value --verbose value`。

我仿照官方示例做了一个演示：

```c++
#include <QDebug>
#include <QCoreApplication>
#include <QCommandLineParser>

void initInputParser(QCommandLineParser &parser);

int main(int argc, char *argv[])
{
	// QCoreApplication 提供命令行参数作为一个简单的字符串列表
	QCoreApplication app(argc, argv);
	QCoreApplication::setApplicationName("my-copy-program");
	QCoreApplication::setApplicationVersion("1.0");

	// QCommandLineParser 初始化，由于其不可复制，故而采用引用方式进行处理
	QCommandLineParser parser;
	initInputParser(parser);

	// 处理用户给出的实际命令行参数
	parser.process(app);

	// 所有基于位置的命令行参数列表，可能包含未定义的命令行参数
	const QStringList args = parser.positionalArguments();

	// 检查命令行选项是否被指定，多个名字的话被认为是相等的
	bool showProgress = parser.isSet("p");
	bool force = parser.isSet("f");
	bool target = parser.isSet("t");
	bool dft = parser.isSet("default");

	// 获取命令行选项对应的值，即命令行参数
	QString targetDir = parser.value("t");
	QString defaultName = parser.value("default-name");

	// 输出
	qDebug() << "-p: " << showProgress;
	qDebug() << "-f: " << force;
	qDebug() << "-t, --target-directory: " << target;
	qDebug() << "-d, --default, --default-name: " << dft;

	qDebug() << "target directory: " << targetDir;
	qDebug() << "default name: " << defaultName;
	
	qDebug() << "positionalArguments: ";
	for (int i = 0; i < args.size(); ++i) {
		qDebug() << " " << args[i];
	}
}

void initInputParser(QCommandLineParser &parser)
{
	parser.setApplicationDescription("Test helper");
	parser.addHelpOption();    // -h, --help and -? on Windows
	parser.addVersionOption(); // -v / --version

	// 添加基于位置的命令行参数，这意味着你不能随意调换它们的相对顺序
	// QCoreApplication::translate: 返回第二个参数翻译后的字符串，这意味着支持多种语言
	parser.addPositionalArgument("source", 
		QCoreApplication::translate("main", "Source file to copy."));
	parser.addPositionalArgument("destination", 
		QCoreApplication::translate("main", "Destination directory."));

	// http://doc.qt.io/qt-5/qcommandlineparser.html#addOptions
	// http://doc.qt.io/qt-5/qcommandlineoption.html
	parser.addOptions({
		// 不带命令行参数的命令行选项(-p)，这意味着你不能为该选项赋值
		// 第二个参数是选项描述，见帮助菜单
		{ "p",
			QCoreApplication::translate("main", "Show progress during copy") },
		// 不带命令行参数的命令行选项(-f, --force)
		// 为一个选项指定多个名字时，列表中任何单个字符的名字都被认为是短名
		// 名字列表不允许为空，名字不能以破折号或斜杠开头、不能包含=、也不能重复
		{ { "f", "force" },
			QCoreApplication::translate("main", "Overwrite existing files.") },
		// 带命令行参数的命令行选项(-t, --target-directory)
		// 第三个参数为命令行参数名，见帮助菜单
		{ { "t", "target-directory" },
			QCoreApplication::translate("main", "Copy all source files into <directory>."),
			QCoreApplication::translate("main", "directory") },
		// 带命令行参数的命令行选项(-d, --default, --default-name)
		// 第四个参数为默认选项值
		{ { "d","default","default-name" },
			QCoreApplication::translate("main", "default name <name>."),
			QCoreApplication::translate("main", "name"),
			QCoreApplication::translate("main", "untitled") }
	});
}
```

编译完成之后，首先查看 help:

```text
$ e:\qt_practice>release\qt_practice.exe -h
Usage: release\qt_practice.exe [options] source destination
Test helper

Options:
  -?, -h, --help                        Displays this help.
  -v, --version                         Displays version information.
  -p                                    Show progress during copy
  -f, --force                           Overwrite existing files.
  -t, --target-directory <directory>    Copy all source files into <directory>.
  -d, --default, --default-name <name>  default name <name>.

Arguments:
  source                                Source file to copy.
  destination                           Destination directory.

```

这样就对上面的代码有了更深的了解了，接下来我们只需要按照 help 显示的那样进行测试即可：

```cmd
$ e:\qt_practice>release\qt_practice.exe -v
my-copy-program 1.0

$ e:\qt_practice>release\qt_practice.exe -pf -t target -d default src dst undef
-p:  true
-f:  true
-t, --target-directory:  true
-d, --default, --default-name:  true
target directory:  "target"
default name:  "default"
positionalArguments:
  "src"
  "dst"
  "undef"

$ e:\qt_practice>release\qt_practice.exe src dst -t=dir undef
-p:  false
-f:  false
-t, --target-directory:  true
-d, --default, --default-name:  false
target directory:  "dir"
default name:  "untitled"
positionalArguments:
  "src"
  "dst"
  "undef"

$ e:\qt_practice>release\qt_practice.exe -a
Unknown option 'a'.

$ e:\qt_practice>release\qt_practice.exe -t
Missing value after '-t'.

$ e:\qt_practice>release\qt_practice.exe -default name
-p:  false
-f:  false
-t, --target-directory:  false
-d, --default, --default-name:  true
target directory:  ""
default name:  "efault"
positionalArguments:
  "name"

$ e:\qt_practice>release\qt_practice.exe --default name
-p:  false
-f:  false
-t, --target-directory:  false
-d, --default, --default-name:  true
target directory:  ""
default name:  "name"
positionalArguments:

```

可以看到，**如果一个选项被设置为需要一个值，则必须存在一个、当不指定有默认值的命令行选项时，就会得到该选项的默认值、使用长字符选项时一定要使用双破折号**。

<h2 id="qstring_qbytearray">字符串</h2>

QT5 默认兼容标准 C++11，但 QT4 需要在 `.pro` 文件中加上 `CONFIG += c++11`，这意味着你不必特意去学习新的类似的库，能用标准 C++ 处理的就用标准 C++ 进行处理，但在 QT 下写程序你却全部使用标准 C++，那使用 QT 的意义又在哪儿呢？由于 QT 所有 API 的参数和返回值除了简单类型之外都是自行封装的，这又意味着**你需要对 QT 的库有一定的了解才行**。

QT 有两个类来存储字符串，它们分别是 QString 和 QByteArray。其中 QString 是 QT 最为常用的字符串，因为它存储了一串 QChar 字符，而一个 QChar 提供了一个16位的 Unicode 字符；而 QByteArray 提供的是一个字节数组，即一个元素是一个字节，以空字符`'\0'`结尾的8位字符串。**除了需要存储原始二进制数据或者对内存保护要求很高的情况下，一般都推荐使用 QString，但使用 QByteArray 比使用 `const char *` 更方便，它确保数据后跟`'\0'`终止符**。

**QString 和 QByteArray 都是采用的[写时复制](http://doc.qt.io/qt-5/implicit-sharing.html)来减少内存使用量和不必要的复制操作**。

下面我们就来对 QString 的常用操作来做一个简单的演示，更多的操作你可以查看[说明文档](http://doc.qt.io/qt-5/qstring.html#details)：

```c++
#include <string>     // 标准字符串

#include <QDebug>
#include <QString>

int main()
{
	std::string std_str = "World";

	// 赋值
	QString str0 = QChar('H');                      // QChar 赋值运算符
	QString str1 = "Hello";                         // const char* 赋值运算符
	QString str2 = QString::fromStdString(std_str); // 标准字符串转 QString 
	qDebug() << str0 << " " << str1 << " " << str2;

	// 访问
	bool isEmpty = str2.isEmpty();                  // 是否为空
	int size = str0.size();                         // 获取字符串大小
	str0[0] = QChar('E');                           // 修改字符
	QChar ch = str1.at(1);                          // at 用于只读
	qDebug() << str0 << " size: " << size;
	qDebug() << str1 << ".at(1): " << ch;
	qDebug() << str2 << " is empty?: " << isEmpty;

	// 修改
	str0.prepend("haha");                           // 前置添加
	str0.push_front("wa");                          // 前置添加
	str1.append(" ");                               // 后置添加
	str1.push_back(str2);                           // 后置添加
	str1 += "!";                                    // 后置添加
	str2.insert(0, "Hello ");                       // 在位置0上插入“Hello "
	QString str3 = str2;                            // str3: Hello World
	str3.replace(6, 5, "QT");                       // 将从位置6开始的5个字符替换为"QT"
	QString str4(str3);                             // str4: Hello QT
	str4.remove(0, 6);                              // 移除从位置0开始的6个字符
	str3.swap(str4);                                // 交换
	qDebug() << str0 << " " << str1 << " "
		<< str2 << " " << str3 << " " << str4;

	// 获取子串
	QString sub0 = str2.right(5);                   // 右边5个字符
	QString sub1 = str2.mid(1, 4);                  // 位置1开始4个字符
	QString sub2 = str2.left(5);                    // 左边5个字符
	qDebug() << sub0 << " " << sub1 << " " << sub2;

	// 比较
	QString str5("_raw.png");
	QString str6("_RAW.png");
	bool equal = (str5 == str6);                    // 比较运算符
	bool startsWith = str5.startsWith("_");         // 是否以"_"开始
	bool endsWith = str5.endsWith(".png");          // 是否以".png"结尾
	bool contains =
		str5.contains("RAW", Qt::CaseInsensitive);  // 是否包含"raw",大小写无关
	qDebug() << equal << " " << startsWith << " "
		<< endsWith << " " << contains;

	// 动态字符串
	QString s0 = "file name is %1, function name is %2.";
	QString s1 = s0.arg(__FILE__);                  // 将s1的最小的标记%1替换为文件名
	QString s2 = s1.arg(__func__);                  // 将s2的最小的标记%2替换为函数名
	qDebug() << s0 << "\n" << s1 << "\n" << s2;

	// 转换
	QString str_num0 = QString::number(123);        // 数字转 QString
	QString str_num1 = QString().setNum(1.234);     // 数字转 QString
	std::string std_num = str_num0.toStdString();   // QString 转 std::string
	int num0 = str_num0.toInt();                    // QString 转数字
	double num1 = str_num1.toDouble();              // QString 转数字
	str5 = str5.toUpper();                          // 转换为大写
	str6 = str6.toLower();                          // 转换为小写
	qDebug() << str_num0 << ": " << num0 << ", "
		<< str_num1 << ": " << num1;
	qDebug() << str5 << " " << str6;

	// 字符类型
	QString str7 = "7 white, 3 red roses.";
	int digits = 0, letters = 0;
	int spaces = 0, puncts = 0;
	for (const QChar &s : str7)
	{
		if (s.isDigit()) {
			digits++;
		}
		else if (s.isLetter()) {
			letters++;
		}
		else if (s.isSpace()) {
			spaces++;
		}
		else if (s.isPunct()) {
			puncts++;
		}
	}
	qDebug() << QString("There are %1 characters").arg(str7.count());
	qDebug() << QString("There are %1 letters").arg(letters);
	qDebug() << QString("There are %1 digits").arg(digits);
	qDebug() << QString("There are %1 spaces").arg(spaces);
	qDebug() << QString("There are %1 punctuation characters").arg(puncts);
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
"H"   "Hello"   "World"
"E"  size:  1
"Hello" .at(1):  'e'
"World"  is empty?:  false
"wahahaE"   "Hello World!"   "Hello World"   "QT"   "Hello QT"
"World"   "ello"   "Hello"
false   true   true   true
"file name is %1, function name is %2."
 "file name is main.cpp, function name is %2."
 "file name is main.cpp, function name is main."
"123" :  123 ,  "1.234" :  1.234
"_RAW.PNG"   "_raw.png"
"There are 21 characters"
"There are 13 letters"
"There are 2 digits"
"There are 4 spaces"
"There are 2 punctuation characters"
```

上面打印出来的字符串有引号，如果你觉得不爽的话，可以使用[qPrintable](http://doc.qt.io/qt-5/qtglobal.html#qPrintable)全局函数将 QString 转换为 `const char *`后再进行输出。

<h2 id="qvariant">QVariant</h2>

QVariant 像是一个 QT 常见数据类型的共用体。由于标准 union 只支持有默认构造函数和析构函数的类型，然而许多有用的 QT 类都不满足这一要求，所以有了 QVariant。

**一个 QVariant 对象在同一时间只持有一种数据类型的一个值**，假定该类型为 T，那么你就可以使用成员函数 `toT()` 来获取这个值，你还可以使用成员函数 `canConvert` 来判断该类型是否能够转换到你想要的类型，你甚至可以使用成员函数 `typename()` 来得到该类型的类型字符串。

由于 QVariant 是 Qt Core 模块的一部分，所以没有提供 Qt GUI 定义的数据类型的额转换函数 `toT()`，但是 [QVariant 支持的类型](http://doc.qt.io/qt-5/qvariant-obsolete.html#Type-enum)是包含一些 GUI 定义的类型的，如 QColor、QImage、QPixmap 等，这时你可以使用成员函数 `value` 或者转换函数 `qvariant_cast` 来获取存储的值。**实际上所有的 QVariant 对象都可以使用这样的方式来获取值**。

演示：

```c++
#include <QDebug>
#include <QColor>
#include <QString>
#include <QVariant>

int main()
{
	QVariant v(123);
	bool isInt = v.canConvert<int>();        // 能否转为 int
	bool isString = v.canConvert<QString>(); // 能否转为 QString
	int x = v.toInt();                       // 转换到 int
	QString str = v.toString();              // 转换到 QString
	QString type = v.typeName();             // v 的类型
	qDebug() << "QVariant: " << v;
	qDebug() << "isInt: " << isInt;
	qDebug() << "isString: " << isString;
	qDebug() << "toInt: " << x;
	qDebug() << "toString: " << str;
	qDebug() << "typeName: " << type;

	QColor color = QColor(Qt::red);
	v = color;
	qDebug() << "QVariant: " << v;
	qDebug() << "typeName: " << v.typeName();
	qDebug() << "value: " << v.value<QColor>();
	qDebug() << "value: " << qvariant_cast<QColor>(v);
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
QVariant:  QVariant(int, 123)
isInt:  true
isString:  true
toInt:  123
toString:  "123"
typeName:  "int"
QVariant:  QVariant(QColor, QColor(ARGB 1, 1, 0, 0))
typeName:  QColor
value:  QColor(ARGB 1, 1, 0, 0)
value:  QColor(ARGB 1, 1, 0, 0)
```

<h2 id="qdate_qtime_and_qdatetime">日期时间</h2>

熟悉 C 的兄弟们应该知道 `<time.h>` 是专门用来处理日期时间的，C++ 将该头文件放在命名空间 `std` 下，并重新构建了一个新的头文件 `<ctime>`，你可以使用该头文件来获取日期时间：

```c++
#include <ctime>
#include <string>
#include <iostream>

int main()
{
	time_t t = time(0);   // get time now
	struct tm * now = localtime(&t);

	std::cout << "year: " << now->tm_year + 1900 << "\n"
		<< "month: " << now->tm_mon + 1 << "\n"
		<< "day: " << now->tm_mday << "\n"
		<< "hour: " << now->tm_hour << "\n"
		<< "minute: " << now->tm_min << "\n"
		<< "second: " << now->tm_sec
		<< std::endl;
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
year: 2017
month: 8
day: 31
hour: 15
minute: 8
second: 21
```

在 C++11 中还有头文件 `<chrono>` 中的 `system_clock` 也可以获取当前时间，因为它提供了向 `time_t` 的类型转换函数 `to_time_t`，另外它还支持超**高精度的计时功能**，而使用 `time_t` 你只能获取到精确到秒的计时功能：

```c++
#include <ctime>
#include <thread> // sleep_for
#include <chrono>
#include <iostream>

int main()
{
	//auto now_steady = std::chrono::steady_clock::now();
	auto now_system = std::chrono::system_clock::now();

	time_t now = std::chrono::system_clock::to_time_t(now_system);
	std::cout << ctime(&now) << std::endl;  // unsafe way

	// safe way
	/*char buffer[26];
	ctime_s(buffer, 26, &now);
	std::cout << buffer << std::endl;*/

	// 计时
	// https://chorior.github.io/2017/04/24/C++-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/#clock
	auto time_start = std::chrono::high_resolution_clock::now();
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(100.001));
	auto time_stop = std::chrono::high_resolution_clock::now();
	std::cout << "took "
		<< std::chrono::duration<double, std::milli>(time_stop - time_start).count()
		<< " ms\n";
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
Thu Aug 31 15:22:07 2017

took 100.01 ms
```

**在 Qt 中，如果你想处理日期的话，你可以使用 QDate，如果你想处理时间的话，你可以使用 QTime，如果你想日期、时间一起处理的话，你可以使用 QDateTime**。

<h3 id="qdate">QDate</h3>

```c++
#include <QDate>
#include <QDebug>

int main()
{
	// 访问
	QDate d1 = QDate::currentDate();
	qDebug() << "year: " << d1.year() << "\n"
		<< "month: " << d1.month() << "\n"
		<< "day: " << d1.day() << "\n"
		<< "dayOfWeek: " << d1.dayOfWeek() << "\n"
		<< "dayOfYear: " << d1.dayOfYear() << "\n"
		<< "daysInMonth: " << d1.daysInMonth() << "\n"
		<< "TextDate: " << d1.toString(Qt::TextDate) << "\n"
		<< "ISODate: " << d1.toString(Qt::ISODate) << "\n"
		<< "SystemLocaleShortDate: " << d1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< "SystemLocaleLongDate: " << d1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< "DefaultLocaleShortDate: " << d1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< "DefaultLocaleLongDate: " << d1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< "RFC2822Date: " << d1.toString(Qt::RFC2822Date);

	// 字符串转 QDate
	QString str("2017-08-31");
	d1 = QDate::fromString(str, Qt::ISODate);
	qDebug() << d1.toString(Qt::ISODate);

	// 修改、比较
	d1.setDate(2017, 8, 1);
	qDebug() << d1.daysTo(QDate::currentDate()) << "\n"
		<< d1.addDays(2).toString(Qt::ISODate) << "\n"
		<< d1.addMonths(2).toString(Qt::ISODate) << "\n"
		<< d1.addYears(2).toString(Qt::ISODate) << "\n"
		<< d1.toString(Qt::ISODate) << " > "
		<< QDate::currentDate().toString(Qt::ISODate)
		<< " is " << static_cast<bool>(d1 > QDate::currentDate());
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
year:  2017
month:  8
day:  31
dayOfWeek:  4
dayOfYear:  243
daysInMonth:  31
TextDate:  "周四 八月 31 2017"
ISODate:  "2017-08-31"
SystemLocaleShortDate:  "2017/8/31"
SystemLocaleLongDate:  "2017年8月31日"
DefaultLocaleShortDate:  "2017/8/31"
DefaultLocaleLongDate:  "2017年8月31日"
RFC2822Date:  "31 Aug 2017"
"2017-08-31"
30
"2017-08-03"
"2017-10-01"
"2019-08-01"
"2017-08-01"  >  "2017-08-31"  is  false
```

**除了使用 QT 定义的格式进行输出和输入之外，你还可以自定义日期的格式**：

Expression | Output
------------ | ---------------------------------
yy | 两位数年份(00~99)
yyyy | 四位数年份
M | 不带前置零的月份数(1 ~ 12)
MM | 带有前置零的月份数(01 ~ 12)
MMM | 短的本地化月份名(如 Jan ~ Dec)
MMMM | 长的本地化月份名(如 January ~ December)
d | 不带前置零的天数(1 ~ 31)
dd | 带有前置零的天数(01 ~ 31)
ddd | 短的本地化天名(如 Mon ~ Sun)
dddd | 长的本地化天名(如 Monday ~ Sunday)

```c++
#include <QDate>
#include <QDebug>

int main()
{
	QDate cd = QDate::currentDate();

	qDebug() << "Today is " << cd.toString("yyyy-MM-dd");
	qDebug() << "Today is " << cd.toString("yy/M/dd");
	qDebug() << "Today is " << cd.toString("d. M. yyyy");
	qDebug() << "Today is " << cd.toString("d-MMMM-yyyy");

	QString fmt("yyyy-MM-dd");
	QString str("2017-08-31");
	qDebug() << QDate::fromString(str, fmt).toString("yy/M/dd");
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
Today is  "2017-08-31"
Today is  "17/8/31"
Today is  "31. 8. 2017"
Today is  "31-八月-2017"
"17/8/31"
```

<h3 id="qtime">QTime</h3>

```c++
#include <QTime>
#include <QDebug>

int main()
{
	// 访问
	QTime t1 = QTime::currentTime();
	qDebug() << "hour: " << t1.hour() << "\n"
		<< "minute: " << t1.minute() << "\n"
		<< "second: " << t1.second() << "\n"
		<< "msec: " << t1.msec() << "\n"
		<< "TextDate: " << t1.toString(Qt::TextDate) << "\n"
		<< "ISODate: " << t1.toString(Qt::ISODate) << "\n"
		<< "SystemLocaleShortDate: " << t1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< "SystemLocaleLongDate: " << t1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< "DefaultLocaleShortDate: " << t1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< "DefaultLocaleLongDate: " << t1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< "RFC2822Date: " << t1.toString(Qt::RFC2822Date);

	// 字符串转 QTime
	QString str("20:02:20.22");
	QTime t2 = QTime::fromString(str, Qt::ISODate);
	qDebug() << t2.toString(Qt::ISODate);

	// 修改、比较
	t1.setHMS(20, 01, 00, 00);
	qDebug() << t1.secsTo(t2) << "\n"
		<< t1.msecsTo(t2) << "\n"
		<< t1.addSecs(2).toString(Qt::ISODate) << "\n"
		<< t1.addMSecs(1000).toString(Qt::ISODate) << "\n"
		<< t1.toString(Qt::ISODate) << " > " << t2.toString(Qt::ISODate)
		<< " is " << static_cast<bool>(t1 > t2);
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
hour:  16
minute:  27
second:  49
msec:  351
TextDate:  "16:27:49"
ISODate:  "16:27:49"
SystemLocaleShortDate:  "16:27"
SystemLocaleLongDate:  "16:27:49"
DefaultLocaleShortDate:  "16:27"
DefaultLocaleLongDate:  "16:27:49"
RFC2822Date:  "16:27:49"
"20:02:20"
80
80220
"20:01:02"
"20:01:01"
"20:01:00"  >  "20:02:20"  is  false
```

**除了使用 QT 定义的格式进行输出和输入之外，你还可以自定义时间的格式**：

Expression | Output
------------ | ---------------------------------
AP <br> A | AM/PM
ap <br> a | am/pm
t | 时区
h | 0 ~ 23 或 1 ~ 12
hh | 00 ~ 23 或 01 ~ 12
H | 0 ~ 23
HH | 00 ~ 23
m | 0 ~ 59
mm | 00 ~ 59
s | 0 ~ 59
ss | 00 ~ 59
z | 0 ~ 999
zzz | 000 ~ 999

```c++
#include <QTime>
#include <QDebug>

int main()
{
	QTime cd = QTime::currentTime();

	qDebug() << "current time is " << cd.toString("hh:mm:ss.zzz");
	qDebug() << "current time is " << cd.toString("h:m:s a");
	qDebug() << "current time is " << cd.toString("H:m:s A");
	qDebug() << "current time is " << cd.toString("h:m AP");

	QString fmt("hh:mm:ss.zzz");
	QString str("20:20:20.200");
	qDebug() << QTime::fromString(str, fmt).toString("h:m:s a");
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
current time is  "16:32:43.386"
current time is  "4:32:43 下午"
current time is  "16:32:43 下午"
current time is  "4:32 下午"
"8:20:20 下午"
```

我们知道时间的计量就是**计时**，当然你可以自己编写函数进行计时，就像上面的 `system_clock` 一样，相减就可以，但 QT 帮你实现了这个 API：

```c++
void QTime::start()
{
    *this = currentTime();
}

int QTime::restart()
{
    QTime t = currentTime();
    int n = msecsTo(t);
    if (n < 0)                                // passed midnight
        n += 86400*1000;                      // 一天86400秒
    *this = t;
    return n;
}

int QTime::elapsed() const
{
    int n = msecsTo(currentTime());
    if (n < 0)                                // passed midnight
        n += 86400 * 1000;
    return n;
}
```

根据上面的源码，你应该很容易进行理解和测试：

```c++
#include <thread>  // sleep_for
#include <chrono>

#include <QTime>
#include <QDebug>

int main()
{
	QTime t;
	t.start();
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(100));
	
	qDebug() << "took " << t.restart() << " ms";
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(200));
	qDebug() << "took " << t.elapsed() << " ms";
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
took  100  ms
took  206  ms
```

**可以看到，其精度只到达毫秒，远不如 `chrono` 的精度高**。

<h3 id="qdatetime">QDateTime</h3>

**你可以把 QDateTime 当做 QDate 和 QTime 的并集**，使用时可以使用成员函数`date()`和`time()`来获取对应的 QDate 和 QTime，修改之后再通过成员函数`setDate`和`setTime`将修改合并到原 QDateTime 实例中；剩余比较独立的函数是`toUTC`和`toTime_t`，其中UTC时间是世界标准时间，不随地区、季节的改变而改变，`time_t`是Unix时间。

```c++
#include <QDebug>
#include <QDateTime>

int main()
{
	QDate d = QDate::currentDate();
	QTime t = QTime::currentTime();
	QDateTime dt1(d, t);
	QDateTime dt2 = QDateTime::currentDateTime();
	QDateTime dt3 = QDateTime::currentDateTimeUtc();

	qDebug() << dt1.toString(Qt::ISODate) << "\n"
		<< dt2.toString(Qt::ISODate) << "\n"
		<< dt3.toString(Qt::ISODate) << "\n"
		<< dt2.date().toString(Qt::ISODate) << "\n"
		<< dt2.time().toString(Qt::ISODate) << "\n"
		<< dt1.toUTC().toString(Qt::ISODate) << "\n"
		<< dt2.toTime_t();
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
"2017-08-31T16:50:22"
"2017-08-31T16:50:22"
"2017-08-31T08:50:22Z"
"2017-08-31"
"16:50:22"
"2017-08-31T08:50:22Z"
1504169422
```

<h2 id="qfile_qdir">文件输入输出</h2>

有些时候你可能需要对很多歌文件执行相同的操作，比如对几十张图片进行一些算法处理，你当然可以手动将这些文件的名字一一写死到程序里面，但是如果有一天需要换一批文件，你是否又需要一个一个去写呢？遇到这种问题，我一般都是将所有文件放在同一个目录下，让程序去一个个读文件，然后进行操作。**但 C++11 并没有读取目录的接口**，你可以在 [stackoverflow](https://stackoverflow.com/questions/612097/how-can-i-get-the-list-of-files-in-a-directory-using-c-or-c) 上找到如何在标准 C++ 里读取目录的方法。就我使用过的来说，[`dirent.h`](https://github.com/tronkko/dirent) 确实比较轻便又好用：

```c++
#include <iostream>

#include "dirent.h"

int main()
{
	DIR *dir;
	struct dirent *ent;
	if ((dir = opendir(".")) != NULL)
	{
		/* print all the files and directories within directory */
		while ((ent = readdir(dir)) != NULL)
		{
			std::cout << ent->d_name;
			switch (ent->d_type)
			{
			case DT_REG:
				std::cout << ": DT_REG\n"; break;
			case DT_DIR:
				std::cout << ": DT_DIR\n"; break;
			}
		}
		closedir(dir);
	}
	else {
		/* could not open directory */
		std::cerr << "open directory failed!\n";
		exit(EXIT_FAILURE);
	}
}
```

由于新添加了一个头文件，所以需要在 `.pro` 文件中加上 `HEADERS += dirent.h`，然后重新生成 makefile并编译：

```text
$ e:\qt_practice>qmake
$ e:\qt_practice>mingw32-make
$ e:\qt_practice>release\qt_practice.exe
.: DT_DIR
..: DT_DIR
.qmake.stash: DT_REG
debug: DT_DIR
dirent.h: DT_REG
main.cpp: DT_REG
Makefile: DT_REG
Makefile.Debug: DT_REG
Makefile.Release: DT_REG
qt_practice.pro: DT_REG
release: DT_DIR
```

从结果中可以看出，有两个特殊的文件夹 `.` 和 `..`，它们分别代表当前目录与上一级目录。

**QT 提供了 QFile、QDir 和 QFileInfo 来专门处理文件和目录**，其中 QFile 用来读写文件，QDir 用来访问目录，QFileInfo 用来获取文件的相关信息(如路径、文件名、修改时间、权限等)。**它们一致使用正斜杠 `/` 来作为文件分隔符，不支持反斜杠，可以使用相对路径**。

<h3 id="qfile">QFile</h3>

我们首先在 `e:/qt_practice` 目录下创建一个 `test.txt`:

```text
line1 line1 line1
line2 line2 line2
line3 line3 line3
line4 line4 line4
```

演示：

```c++
#include <QFile>
#include <QDebug>
#include <QString>
#include <QTextStream>

int main()
{
	QString filePath = "e:/qt_practice/test.txt";
	Q_ASSERT(QFile::exists(filePath));  // 是否存在

	QFile file(filePath);

	// 打开文件
	// http://doc.qt.io/qt-5/qiodevice.html#OpenModeFlag-enum
	file.open(QIODevice::ReadWrite | QIODevice::Text);
	if (!file.isOpen()) {
		qDebug() << "open " << filePath << " failed.";
	}

	// 读取文件
	qDebug() << "file.read(5): " << file.read(5);
	qDebug() << "file.readLine(): " << file.readLine();
	qDebug() << "file.readAll():\n" << file.readAll();
	qDebug() << "file.isEnd(): " << file.atEnd();	
	
	// 写文件
	file.write("\nline5");

	// 位置变换
	qDebug() << "file.pos(): " << file.pos();
	qDebug() << "file.size(): " << file.size();
	file.seek(0);  // 将位置变换到文件开始
	qDebug() << "after seek(0):";
	qDebug() << "file.pos(): " << file.pos();	

	// 文件流
	QTextStream stream(&file);
	qDebug() << "stream.read(5): " << stream.read(5);
	qDebug() << "stream.readLine(): " << stream.readLine();
	qDebug() << "stream.readAll():\n" << stream.readAll();
	qDebug() << "stream.isEnd(): " << stream.atEnd();
	qDebug() << "stream.pos(): " << stream.pos();
	stream.seek(0);  // 将位置变换到文件开始
	qDebug() << "after seek(0):";
	qDebug() << "stream.pos(): " << stream.pos();

	stream << "\nline6";
	
	QString str;
	stream >> str;
	qDebug() << "str: " << str;	

	// 关闭文件
	file.close(); // QFile 对象销毁时会自动调用
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
file.read(5):  "line1"
file.readLine():  " line1 line1\n"
file.readAll():
 "line2 line2 line2\nline3 line3 line3\nline4 line4 line4"
file.isEnd():  true
file.pos():  74
file.size():  74
after seek(0):
file.pos():  0
stream.read(5):  " line"
stream.readLine():  "1 line1"
stream.readAll():
 "line2 line2 line2\nline3 line3 line3\nline4 line4 line4"
stream.isEnd():  true
stream.pos():  74
after seek(0):
stream.pos():  0
str:  "line0"
```

test.txt:

```text
line0 line1 line1
line2 line2 line2
line3 line3 line3
line4 line4 line4
line5
```

可以看到，**这里的 `\n` 被当做了两个字符，由于是在 Windows 下，所以应该是 `\r\n`；QFile 的读写可能会影响流的读写，所以不能将它们混用；QFile 会读取换行符，而流不会**。

<h3 id="qfileinfo">QFileInfo</h3>

前面我们说过，QFileInfo 提供关于文件或文件夹的相关信息，它可以使用绝对路径，又可以使用相对路径，你可以使用成员函数 `isRelative` 进行确认，也可以使用成员函数`makeAbsolute`从一个相对路径得到一个绝对路径。

查看其头文件，你会发现其实它能用的函数并不多：

```c++
QFileInfo(const QString &file);
QFileInfo(const QFile &file);
QFileInfo(const QDir &dir, const QString &file);
void setFile(const QString &file);
void setFile(const QFile &file);
void setFile(const QDir &dir, const QString &file);
bool exists() const;
static bool exists(const QString &file);
void refresh(); // 刷新文件信息
QString fileName() const;
QString filePath() const;
QString absoluteFilePath() const;
QString suffix() const; // 返回文件名最后一个.后所有字符
QString completeSuffix() const; // 返回文件名第一个.后所有字符
bool isReadable() const;
bool isWritable() const;
bool isExecutable() const;
bool isHidden() const;
bool isFile() const;
bool isDir() const;
bool isSymLink() const;
QString readLink() const;
qint64 size() const;
QDateTime created() const;
QDateTime lastModified() const;
QDateTime lastRead() const;
QString owner() const;
QString group() const;
bool permission(QFile::Permissions permissions) const;
QFile::Permissions permissions() const;
```

其中`owner`、`group`、`permissions`在NTFS文件系统上的返回值是不准确的，因为NTFS系统默认禁用了所有权的权限的检查，要想启用它，你需要：

```c++
extern Q_CORE_EXPORT int qt_ntfs_permission_lookup;
qt_ntfs_permission_lookup++; // turn checking on
qt_ntfs_permission_lookup--; // turn it off again
```

查看 `QFile::Permissions`:

```c++
enum Permission {
	ReadOwner = 0x4000, WriteOwner = 0x2000, ExeOwner = 0x1000,
	ReadUser  = 0x0400, WriteUser  = 0x0200, ExeUser  = 0x0100,
	ReadGroup = 0x0040, WriteGroup = 0x0020, ExeGroup = 0x0010,
	ReadOther = 0x0004, WriteOther = 0x0002, ExeOther = 0x0001
};
```

演示：

```c++
#include <QDebug>
#include <QFileInfo>
#include <QDateTime>

extern Q_CORE_EXPORT int qt_ntfs_permission_lookup;

int main(void)
{
	qt_ntfs_permission_lookup++; // turn checking on	

	QFileInfo info("main.cpp");

	qDebug() << "isRelative: " << info.isRelative();
	qDebug() << "filePath: " << info.filePath();
	qDebug() << "absoluteFilePath: " << info.absoluteFilePath();
	qDebug() << "fileName: " << info.fileName();
	qDebug() << "exists: " << info.exists();
	qDebug() << "suffix: " << info.suffix();
	qDebug() << "created: " << info.created().toString(Qt::ISODate);
	qDebug() << "lastModified: " << info.lastModified().toString(Qt::ISODate);
	qDebug() << "owner: " << info.owner();
	qDebug() << "permissions: " << info.permissions();

	return 0;
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
isRelative:  true
filePath:  "main.cpp"
absoluteFilePath:  "E:/qt_practice/main.cpp"
fileName:  "main.cpp"
exists:  true
suffix:  "cpp"
created:  "2017-08-28T09:32:21"
lastModified:  "2017-09-01T17:13:44"
owner:  "pengzhen"
permissions:  QFlags(0x10|0x40|0x100|0x200|0x400|0x1000|0x2000|0x4000)
```

对照 `QFile::Permissions` 可以看到，该 `main.cpp` 的权限为其他人不可访问、组内可读可执行、用户或所有者可读可写可执行，即750。

<h3 id="qdir">QDir</h3>

QDir 也使用正斜杠 `/` 作为其目录分隔符，并且支持相对路径，你可以使用其成员函数 `isRelative()` 或 `isAbsolute()` 来判断使用的路径的是相对的还是绝对的，你甚至可以使用成员函数 `makeAbsolute` 从一个相对路径得到一个绝对路径。

QDir 有一些相似shell命令行的函数，如`mkdir`、`rmdir`、`cd`。

一些有用的静态成员函数：

QDir | QString | 返回值
--------------- | -------------- | ------------------------
current() | currentPath() | 当前工作目录 <br>你可以使用`setCurrent`来手动设置当前工作目录
home() | homePath() | 当前用户目录
root() | rootPath() | 根目录
temp() | tempPath() | 系统临时文件夹

一些常用的非静态成员函数：

*	`exists`；
*	`isReadable`；
*	`path`；
*	`absolutePath`；
*	`dirName`；
*	`count`：目录下的文件夹和文件总数；
*	`entryList`：目录下的文件夹和文件名列表；
*	`entryInfoList`：目录下的文件夹和文件信息列表；
*	`remove`：删除文件；
*	`setFilter`：文件类型过滤器，影响`entryList`和`entryInfoList`；
*	`setNameFilters`：文件名过滤器，影响`entryList`和`entryInfoList`；
*	`setSorting`：设置文件排序顺序，如按大小排列、按修改时间排列等，影响`entryList`和`entryInfoList`；

演示：

```c++
#include <QDir>
#include <QDebug>

int main(void)
{
	qDebug() << "currentPath: " << QDir::currentPath();
	qDebug() << "homePath: " << QDir::homePath();
	qDebug() << "rootPath: " << QDir::rootPath();
	qDebug() << "tempPath: " << QDir::tempPath();

	QDir dir(QDir::currentPath());
	qDebug() << "path: " << dir.path();
	qDebug() << "absolutePath: " << dir.absolutePath();
	qDebug() << "dirName: " << dir.dirName();
	qDebug() << "exists: " << dir.exists();
	qDebug() << "count: " << dir.count();

	qDebug() << "files: ";
	dir.setFilter(QDir::Files);
	dir.setSorting(QDir::Name | QDir::Reversed);
	for (const QString& file : dir.entryList())
	{
		qDebug() << " " << file;
	}

	dir.mkdir("dir");
	qDebug() << "after mkdir(dir): "
		<< "dir exists?: " << QDir("dir").exists();
	dir.cd("dir");
	qDebug() << "after cd(dir): " << dir.absolutePath();
	dir.cd("..");
	qDebug() << "after cd(..): " << dir.absolutePath();
	dir.rmdir("dir");
	qDebug() << "after rmdir(dir): "
		<< "dir exists?: " << QDir("dir").exists();
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
currentPath:  "E:/qt_practice"
homePath:  "C:/Users/pengzhen"
rootPath:  "C:/"
tempPath:  "C:/Users/pengzhen/AppData/Local/Temp"
path:  "E:/qt_practice"
absolutePath:  "E:/qt_practice"
dirName:  "qt_practice"
exists:  true
count:  12
files:
  "test.txt"
  "qt_practice.pro"
  "main.cpp"
  "dirent.h"
  "Makefile.Release"
  "Makefile.Debug"
  "Makefile"
  ".qmake.stash"
after mkdir(dir):  dir exists?:  true
after cd(dir):  "E:/qt_practice/dir"
after cd(..):  "E:/qt_practice"
after rmdir(dir):  dir exists?:  false
```

为什么是12，因为包含了两个特殊文件夹 `.` 和 `..`。

<h2 id="qt_feature">Qt 特性</h2>

标准 C++ 对象模型为对象范式(object paradigm)提供了非常有效的运行时支持，但它的静态性质在某些问题领域是不灵活的。**图形用户界面编程不仅需要运行时的高效性，还需要高度的灵活性，Qt 通过将 C++ 的速度与 Qt 对象模型的灵活性相结合来提供这一点**。

Qt 添加了这些功能到 C++ 中：

*	[信号和槽](http://doc.qt.io/qt-5/signalsandslots.html): 一种强大的无缝对象通信机制；
*	[对象属性](http://doc.qt.io/qt-5/properties.html): 提供可查询可设计的对象属性；
*	[事件与事件过滤器](http://doc.qt.io/qt-5/eventsandfilters.html)；
*	[国际化的字符串翻译机制](http://doc.qt.io/qt-5/internationalization.html)；
*	[定时器](http://doc.qt.io/qt-5/timers.html)：可以在事件驱动的 GUI 中优化整合多个任务；
*	[对象树](http://doc.qt.io/qt-5/objecttrees.html): 分层可查询，使用一种很自然的方式组织对象所有权；
*	[保护指针 QPointer](http://doc.qt.io/qt-5/qpointer.html): 当引用的对象被销毁时，被保护的指针被自动设置为 0；
*	[元对象系统](http://doc.qt.io/qt-5/metaobjects.html)；
*	[自定义类型创建](http://doc.qt.io/qt-5/custom-types.html)。

这些 Qt 特性大多都是继承自 QObject，然后使用标准 C++ 技术实现的。像信号槽和对象属性这样的特性还需要[元对象系统](http://doc.qt.io/qt-5/metaobjects.html)的支持。

**元对象系统是一种 C++ 扩展，使得该语言更适合于真正的组件 GUI 编程**。

<h3 id="signals_and_slots">信号和槽</h3>

**信号和槽用于两个对象之间的通信，它是 Qt 的核心特征，也是区别于其它开发框架的突出特征**。

在 GUI 编程中，当我们改变一个部件时，通常希望有另一个部件做出一些回应，举个简单的栗子，当你点击窗口的关闭按钮时，通常希望执行窗口的 `close` 函数来关闭窗口。一些工具包如 Android，使用回调机制(callback)来处理这样的通信，虽然回调机制很快，但却有两个很大的缺陷：**不直观、必须保证参数类型的正确性**；而 Qt 使用信号槽机制来处理这样的通信，当一个事件发生时，如上面的按钮被点击，便发射一个信号到一个槽，这个槽就是一个函数，接着便执行这个槽函数，即上面的 `close` 函数。

*	信号槽机制是类型安全的：**信号的函数签名必须与关联的槽的函数签名相匹配，实际上槽的函数签名可以短于信号的函数签名，多余的参数会被忽略**；
*	信号槽机制还是松散耦合的：**信号既不需要知道也不需要关心那个槽会接收这个信号**；
*	**任何继承自 QObject 或其子类且声明了 [`Q_OBJECT`](http://doc.qt.io/qt-5/qobject.html#Q_OBJECT) 宏的类都能使用信号槽机制**；
*	**信号不能被定义，也不能有返回值，即只能是 void 类型**；
*	**槽函数可以被用来接收信号，但也可以被当做正常函数进行调用**；
*	**你可以将多个信号关接到同一个槽，也可以将多个槽关联到同一个信号(槽执行的顺序与关联顺序一致)，你甚至可以将一个信号关联到另一个信号(这样当第一个信号被发射时，第二个信号也会被立即发射)**；
*	**一个信号被关联多少次，当其被触发时，就会发射多少次，不管槽函数是否相同，除非你使用 [`Qt::UniqueConnection`](http://doc.qt.io/qt-5/qt.html#ConnectionType-enum)**；
*	**当一个信号被发射时，其关联的槽默认会立即执行**，但是你也可以在关联时设置不同的[关联选项](http://doc.qt.io/qt-5/qt.html#ConnectionType-enum)来决定是否立即执行；
*	当有多个信号关联到同一个槽时，可以使用 [`QObject::sender()` 或 QSignalMapper](http://doc.qt.io/qt-5/signalsandslots.html#advanced-signals-and-slots-usage) 来对不同的信号进行不同的处理；
*	如果第三方库(如 boost)中有 `signals`、`slots`、`emit` 关键字的话，就会与 Qt 关键字重复，为了解决这个问题，你可以在 `.pro`文件中加上 `CONFIG += no_keywords` 来取消定义这三个关键字，转而使用 `Q_SIGNALS`、`Q_SLOTS` 和 `Q_EMIT` 宏，所以为了可扩展性，**建议一致使用这三个大写的宏**。

有多种关联信号和槽的 [`connect`](http://doc.qt.io/qt-5/qobject.html#connect) 函数，其中最常用的有三种：

*	[成员函数信号槽连接函数](http://doc.qt.io/qt-5/qobject.html#connect-3)；
*	[与 `SIGNAL` 和 `SLOT` 宏结合使用的信号槽连接函数](http://doc.qt.io/qt-5/qobject.html#connect)；
*	[与 C++11 lambda 表达式结合使用的信号槽连接函数](http://doc.qt.io/qt-5/qobject.html#connect-4)。

另一种比较常用的信号槽连接方式是[自动连接](http://doc.qt.io/qt-5/designer-using-a-ui-file.html#automatic-connections)，只要你在构造时执行(该语句在 `setupUi` 中会自动执行)：

```c++
QMetaObject::connectSlotsByName(this);
```

然后按如下命名规则命名槽函数，那么该槽函数就会根据自己的名字自动关联到相应的信号(其中 `object name` 可以通过 `QObject::setObjectName` 进行设置)：

```c++
void on_<object name>_<signal name>(<signal parameters>);
```

在没学习常见的 Qt 组件之前，这里只做一个简单的演示：

```c++
// Test.h
#pragma once
#include <QObject>

class Test : public QObject
{
	Q_OBJECT

public:
	Test()
		: m_value(0)
	{}

	int value() const;

public Q_SLOTS:
	void setValue(int);

Q_SIGNALS:
	void valueChanged(int);

private:
	int m_value;
};

inline int Test::value() const
{
	return m_value;
}

inline void Test::setValue(int value)
{
	if (value != m_value) {
		m_value = value;
		emit valueChanged(value);
	}
}
```

```c++
// main.cpp
#include <QDebug>

#include "Test.h"

int main(void)
{
	Test a, b;
	QObject::connect(&a, &Test::valueChanged, &b, &Test::setValue);

	qDebug() << "after init: ";
	qDebug() << "a: " << a.value();
	qDebug() << "b: " << b.value();

	a.setValue(1);
	qDebug() << "after a.setValue(1): ";
	qDebug() << "a: " << a.value();
	qDebug() << "b: " << b.value();

	b.setValue(2);
	qDebug() << "after b.setValue(2): ";
	qDebug() << "a: " << a.value();
	qDebug() << "b: " << b.value();
}
```

结果：

```text
$ E:\qt_practice>release\qt_practice.exe
after init:
a:  0
b:  0
after a.setValue(1):
a:  1
b:  1
after b.setValue(2):
a:  1
b:  2
```

<h3 id="object_properties">对象属性</h3>

Qt提供了类似于一些编译器供应商提供的复杂的属性系统，该属性系统基于[元对象系统](http://doc.qt.io/qt-5/metaobjects.html)，并且支持信号槽。

要想声明一个属性，你只需在 QObject 的继承类中使用 [`Q_PROPERTY` 宏](http://doc.qt.io/qt-5/qobject.html#Q_PROPERTY)即可：

```c++
Q_PROPERTY(type name(type name
           (READ getFunction (READ getFunction [WRITE setFunction] |
            MEMBER memberName [(READ getFunction READ getFunction | WRITE setFunction))])
           
           [RESET resetFunction]
           [NOTIFY notifySignal]
           [REVISION int]
           [DESIGNABLE boolbool]
           [SCRIPTABLE boolbool]
           [STORED boolbool]
           [USER boolbool]
           [CONSTANT]
           [FINAL])
```

举两个简单的例子：

```c++
Q_PROPERTY(bool focus READ hasFocus)
Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled)
Q_PROPERTY(QCursor cursor READ cursor WRITE setCursor RESET unsetCursor)
```

```c++
	Q_PROPERTY((QColor color MEMBER m_color NOTIFY colorChanged))
    Q_PROPERTY((qreal spacing MEMBER m_spacing NOTIFY spacingChanged))
    Q_PROPERTY(QString text MEMBER m_text NOTIFY textChanged)
    ...
signals:
    void colorChanged();
    void spacingChanged();
    void textChanged(const QString &newText);

private:
    QColor  m_color;
    qreal   m_spacing;
    QString m_text;
```

乍一看，这个属性系统不就声明了一个成员变量嘛，看上去没什么软用，但其实声明的属性比常规的成员变量多了一些额外的访问特性：

*	当没有指定 `MEMBER` 成员变量时，必须拥有一个 `READ` 访问函数，用来读取该属性；
*	一个可选的 `WRITE` 函数，用来设置属性的值，该函数只能拥有一个参数、且返回值必须为空；
*	当没有指定 `READ` 访问函数时，必须拥有一个关联 `MEMBER` 成员变量，这使得该成员变量变得可读可写(仅 QML)而不需要创建 `READ` 和 `WRITE` 函数；
*	一个可选的 `RESET` 重置函数，用以将该属性设置回默认值；
*	一个可选的 `NOTIFY` 信号，**该信号对于 `MEMBER` 成员变量来说只能拥有至多一个参数，且参数的类型必须与该成员变量一致，发射时该参数的值就是该属性的最新值**。当  `NOTIFY` 与 `MEMBER` 合并使用时，该信号在属性值发生变化时会自动发射；**单独使用时必须指定一个当属性变化时会发射、且存在的信号**；
*	`FINAL` 代表该属性不能被继承类重载；
*	其它选项可以参考[官方文档](http://doc.qt.io/qt-5/properties.html)。

**`READ`、`WRITE`、`RESET` 函数可以被继承，也可以是虚的，但多继承时只能继承自第一个父类**。

**`Q_PROPERTY` 声明的属性可以使用通用函数 [`QObject::property()`](http://doc.qt.io/qt-5/qobject.html#property) 和 [`QObject::setProperty()`](http://doc.qt.io/qt-5/qobject.html#setProperty) 进行读写，只需知道该属性的名字即可**：

```c++
// Test.h
#pragma once
#include <QString>
#include <QObject>

class Test : public QObject
{
	Q_OBJECT

	Q_PROPERTY(int value READ value WRITE setValue NOTIFY valueChanged)
	Q_PROPERTY(QString key READ key WRITE setKey NOTIFY keyChanged)
public:
	Test()
		: m_value(0), m_key("")
	{}

	int value() const;
	QString key() const;

	public Q_SLOTS:
	void setValue(int);
	void setKey(const QString&);

Q_SIGNALS:
	void valueChanged(int);
	void keyChanged(const QString&);

private:
	int m_value;
	QString m_key;
};

inline int Test::value() const
{
	return m_value;
}

inline void Test::setValue(int value)
{
	if (value != m_value) {
		m_value = value;
		emit valueChanged(value);
	}
}

inline QString Test::key() const
{
	return m_key;
}

inline void Test::setKey(const QString& key)
{
	if (key != m_key) {
		m_key = key;
		emit keyChanged(key);
	}
}
```

```c++
// main.cpp
#include <QDebug>
#include <QMetaProperty>

#include "Test.h"

int main(void)
{
	Test t;
	QObject::connect(&t, &Test::valueChanged,
		[](int value) { qDebug() << "value changed: " << value; });
	QObject::connect(&t, &Test::keyChanged,
		[](const QString& str) { qDebug() << "key changed: " << str; });

	qDebug() << "after init:";
	qDebug() << " t.value: " << t.value();
	qDebug() << " t.key: " << t.property("key").toString();

	t.setValue(2);
	t.setProperty("key", "pengzhen");

	qDebug() << "after write:";
	qDebug() << " t.value: " << t.property("value").toInt();
	qDebug() << " t.key: " << t.key();

	qDebug() << "print all properties of t:";
	const QMetaObject *metaobject = t.metaObject();
	int count = metaobject->propertyCount();
	for (int i = 0; i<count; ++i) {
		QMetaProperty metaproperty = metaobject->property(i);
		const char *name = metaproperty.name();
		QVariant value = t.property(name);
		qDebug() << " " << name << ": " << value;
	}
}
```

结果：

```text
$ E:\qt_practice>release\qt_practice.exe
after init:
 t.value:  0
 t.key:  ""
value changed:  2
key changed:  "pengzhen"
after write:
 t.value:  2
 t.key:  "pengzhen"
print all properties of t:
  objectName :  QVariant(QString, "")
  value :  QVariant(int, 2)
  key :  QVariant(QString, "pengzhen")
```

可以看到，**QObject 对象自带一个名为 `objectName` 的属性**，该属性在自动信号槽连接时有用，可以通过 `QObject::setObjectName` 重新设置。

另外，[`QObject::setProperty()`](http://doc.qt.io/qt-5/qobject.html#setProperty)还可以设置[动态属性](http://doc.qt.io/qt-5/properties.html#dynamic-properties)，即添加一个仅对当前对象有效的属性；**如果你的属性类型是自定义类型的话，还需要使用 [`Q_DECLARE_METATYPE` 宏](http://doc.qt.io/qt-5/qmetatype.html#Q_DECLARE_METATYPE)进行声明之后才能用于属性系统**。


<h3 id="event_system">事件系统</h3>

在 Qt 中，事件是一个对象，继承自抽象 QEvent 类，用以表示发生在应用程序内部的事情、或应用程序需要知道的外部活动的结果。**它们可以被任何 QObject 或其子类的对象进行接收和处理，通常被用于 Qt 组件**。

常见的事件如鼠标事件，分为单击、双击、移动等事件类型；又比如键盘事件，分为按下、释放等事件类型。**这些事件类型都有在 [`QEvent::Type`](http://doc.qt.io/qt-5/qevent.html#Type-enum)被定义，你可以通过不同的事件类型来快速的判断该事件的动态类型**。

```c++
bool MyWidget::event(QEvent *event)
{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent *ke = static_cast<QKeyEvent *>(event);
        if (ke->key() == Qt::Key_Tab) {
            // special tab handling here
            return true;
        }
    } else if (event->type() == MyCustomEventType) {
        MyCustomEvent *myEvent = static_cast<MyCustomEvent *>(event);
        // custom event handling here
        return true;
    }

    return QWidget::event(event);
}
```

当一个事件发生后，Qt 构造一个合适的 QEvent 子类的对象来表示它，然后将其传递到一个特定的 QObject 或其子类的对象。**要想使 Qt 程序进入事件循环，即使应用程序在运行时接收发生的各种事件，你必须调用 QCoreApplication 的 `exec()` 函数**。

```c++
int QApplication::exec()
{
    return QGuiApplication::exec();
}

int QGuiApplication::exec()
{
#ifndef QT_NO_ACCESSIBILITY
    QAccessible::setRootObject(qApp);
#endif
    return QCoreApplication::exec();
}
```

所有事件通过 [`QCoreApplication::notify`](http://doc.qt.io/qt-5/qcoreapplication.html#notify)函数进行发送，其返回值为接收对象处理该事件后的结果。**当接收对象所属类对该事件不感兴趣时(即返回值为 false)，该事件会被传递到其父类进行处理**。处理事件的方法有五种：

*	重新实现 QWidget 的 `paintEvent`、`mousePressEvent` 等特定事件处理函数，**只对单个部件有效**；
*	重新实现 [`QCoreApplication::notify`](http://doc.qt.io/qt-5/qcoreapplication.html#notify) 函数，这样能够对所有事件进行完全的控制，但**同一时间只能处理一个事件**；
*	在 [qApp](#qapp) 上安装一个或多个事件过滤器，这样能够处理所有组件的所有事件，且**可以同时处理多个事件**，但**优先级比 notify 函数要低，且只能处理发生在主线程中的事件**；
*	重新实现 [`QObject::event`](http://doc.qt.io/qt-5/qobject.html#event) 函数，该函数的优先级比特定事件处理函数的优先级高；
*	在对象上安装事件过滤器，这样能够处理所有该对象的子对象事件。

**实际编程中最常用的是第一种和第五种，因为方法二需要继承 QCoreApplication 且需要考虑诸多问题，方法三是实现的全局事件过滤器会减缓事件的处理**。

下面先来演示方法一四：

```c++
// myWidget.h
#pragma once
#include <QDebug>
#include <QEvent>
#include <QWidget> // QWidget 继承自 QObject
#include <QWheelEvent>
#include <QMouseEvent>

class myWidget : public QWidget
{
	Q_OBJECT

public:
	myWidget(QWidget *parent = 0)
		: QWidget(parent)
	{}

protected:
	// QObject::event
	bool event(QEvent*)	override;

	// QWidget::wheelEvent
	void wheelEvent(QWheelEvent*) override;

	// QWidget::mousePressEvent
	void mousePressEvent(QMouseEvent*) override;
};

inline bool myWidget::event(QEvent* e)
{
	if (e->type() == QEvent::Wheel) {
		QWheelEvent *we = static_cast<QWheelEvent *>(e);
		if (we->angleDelta().y() > 0) {
			qDebug() << "forward";
		}
		else {
			qDebug() << "backward";
		}
		return true; // 如果想让该事件继续被传递，返回 false
	}

	return QWidget::event(e); // QWidget::event 可能有些内部实现
}

inline void myWidget::wheelEvent(QWheelEvent* e)
{
	qDebug() << "wheelEvent called.";

	QWidget::wheelEvent(e);
}

inline void myWidget::mousePressEvent(QMouseEvent* e)
{
	qDebug() << "mousePressEvent called.";

	QWidget::mousePressEvent(e);
}
```

```c++
// main.cpp
#include <QApplication>
#include "myWidget.h"

int main(int argc, char *argv[])
{
	// QApplication 对象必须在创建与用户界面相关的任何其他对象之前被创建
	QApplication app(argc, argv);

	myWidget window;

	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("event handlers");
	window.show();

	return app.exec();
}
```

结果是一个名为 event handlers 的空白窗口：

```bash
$ qmake -project  # .pro 文件后手动加上 CONFIG += console 和 QT += widgets
$ qmake
$ mingw32-make
$ release\qt_practice.exe
backward
forward
mousePressEvent called.
```

可以看到，当前后滚动滚轮时，并没有打印 `wheelEvent called.`，说明 `QObject::event` 确实比特定事件处理函数更早获取事件。

我们再来实现方法五：

```c++
// mainWindow.h
#pragma once
#include <QMainWindow>
#include "myWidget.h"

class mainWindow : public QMainWindow
{
public:
	mainWindow(QWidget *parent = 0);

protected:
	bool eventFilter(QObject*, QEvent*) override;

private:
	myWidget *w;
};

mainWindow::mainWindow(QWidget *parent)
	: QMainWindow(parent)
{
	w = new myWidget();
	setCentralWidget(w); // 将 w 设在窗口中央

	w->installEventFilter(this); // 为 w 安装事件过滤器
}

bool mainWindow::eventFilter(QObject *obj, QEvent *event)
{
	if (obj == w)
	{
		if (event->type() == QEvent::Wheel) {
			qDebug() << "eventFilter: event is QWheelEvent.";
		}
		return false; // 继续传递该事件
	}
	else {
		return QMainWindow::eventFilter(obj, event);
	}
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
eventFilter: event is QWheelEvent.
backward
eventFilter: event is QWheelEvent.
forward
mousePressEvent called.
```

可以看到，**父对象的事件过滤器比子对象的事件过滤器更早获取到事件**。

**如果你想代码发送一个事件的话，使用 [`QCoreApplication::sendEvent`](http://doc.qt.io/qt-5/qcoreapplication.html#sendEvent) 或 [`QCoreApplication::postEvent`](http://doc.qt.io/qt-5/qcoreapplication.html#postEvent)**，它们的两个主要区别是：

*	`sendEvent` 立即发送事件而 `postEvent` 会将事件添加到事件队列中等待调度处理；
*	`sendEvent` 的 事件指针在事件处理完毕之后不会自行调用 delete，而 `postEvent` 会。

<h4 id="qapp">qApp</h4>

查看 [qApp](http://doc.qt.io/qt-5/qapplication.html#qApp) 的说明文档，我们知道 qApp 是一个全局指针，指向当前 application 实例。

```c++
// QCoreApplication.h
#define qApp QCoreApplication::instance()
static QCoreApplication *instance() { return self; }
static QCoreApplication *self;

// QGUIApplication.h
#if defined(qApp)
#undef qApp
#endif
#define qApp (static_cast<QGuiApplication *>(QCoreApplication::instance()))

// QApplication.h
#if defined(qApp)
#undef qApp
#endif
#define qApp (static_cast<QApplication *>(QCoreApplication::instance()))
```

<h3 id="international_string">国际化字符串</h3>

**应用程序的国际化(internationalization)和本地化(localization)是应用程序适应不同语言、不同区域、和不同目标市场技术需求的过程**。其中国际化意是指应用程序不需要修改工程就能适应不同语言和区域；本地化是指将应用程序适应到一个特定的语言或区域。

Qt 支持现在使用的大多数语言，包括所有东亚语言(汉语、日语、韩语)、所有西方语言(使用拉丁字母)、阿拉伯语言等，**所有 Qt 的输入部件和文本绘制方式都对这些语言提供了内置支持，Qt 内置的字体引擎可以在同一时间正确而精确的绘制不同的文本，这些文本可以包含来自众多不同书写系统的字符**。

你可以很容易的使用 [Qt Linguist](http://doc.qt.io/qt-5/qtlinguist-index.html) 工具来完成应用程序的翻译工作：

*	[编写可以翻译的源代码](http://doc.qt.io/qt-5/i18n-source-translation.html)；
*	在 `.pro` 文件中指定生成的 `.ts` 文件，如 `TRANSLATIONS = zh_CN.ts`；
*	Qt 命令行执行 `lupdate myproject.pro` 生成 `.ts` 文件；
*	[使用 Qt Linguist](http://blog.csdn.net/liang19890820/article/details/50274409) 对生成的 `.ts` 文件进行翻译；
*	Qt 命令行执行 `lrelease myproject.pro` 生成 `.qm` 文件；
*	最后在创建部件之前使用该 `.qm` 文件即可：

```c++
#include <QTranslator>
...
QApplication app(argc, argv);
QTranslator t;
t.load("zh_CN.qm");
qApp->installTranslator(&t);
...
```

**其实一般使用的翻译函数就两个，`tr()` 和 `QCoreApplication::translate`**，另外你还可以使用 [QTextCodec](http://doc.qt.io/qt-5/qtextcodec.html#details) 来转换各种编码，另外如数字、日期、时间等的本地化还需使用 [QLocal 类](http://doc.qt.io/qt-5/qlocale.html#details)，更多内容可以查看 <http://doc.qt.io/qt-5/internationalization.html> 。

<h3 id="qtimer">定时器</h3>

如果你想周期性的执行某些任务时，在 C++11 里，代码很可能像下面这样：

```c++
#include <thread>
...
while (!done)
{
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(sleep_time)
	);

	task();
}
...
```

当然我一开始没有想到线程的问题，不过 [SOF](https://stackoverflow.com/questions/14650885/how-to-create-timer-events-using-c-11) 总会给你一些不一样的灵感。

在 Qt 中，QObject 提供了基础的定时器支持，[QObject::startTimer](http://doc.qt.io/qt-5/qobject.html#startTimer) 开始一个定时器并返回该定时器 ID；每当一定时间过后，就会有一个定时器事件(就是时间到了)，然后就会调用 [QObject::timerEvent](http://doc.qt.io/qt-5/qobject.html#timerEvent) 虚函数，你可以重新实现该函数来完成相应任务；如果你想销毁这个定时器，调用 [QObject::killTimer](http://doc.qt.io/qt-5/qobject.html#killTimer)。

```c++
// Test.h
#pragma once
#include <QDebug>
#include <QObject>
#include <QTimerEvent>

class Test : public QObject
{
	Q_OBJECT

public:
	Test(QObject *parent = 0);
	~Test();

protected:
	void timerEvent(QTimerEvent*) override;

private:
	int id[3];
};

inline Test::Test(QObject *parent)
	: QObject(parent)
{
	id[0] = startTimer(100); // 100 ms
	id[1] = startTimer(200); // 200 ms
	id[2] = startTimer(300); // 300 ms
}

inline Test::~Test()
{
	killTimer(id[0]);
	killTimer(id[1]);
	killTimer(id[2]);
}

inline void Test::timerEvent(QTimerEvent *e)
{
	int ID = e->timerId();
	if (ID == id[0]){
		qDebug() << "timer1: " << ID;
	}else if (ID == id[1]){
		qDebug() << "timer2: " << ID;
	}
	else {
		qDebug() << "timer3: " << ID;
	}
}
```

由于需要传递 QTimerEvent，你必须先开始事件循环，即调用 `QCoreApplication::exec` 或 `QApplication::exec`：

```c++
// main.cpp
#include <QCoreApplication>
#include "Test.h"

int main(int argc, char *argv[])
{
	QCoreApplication app(argc, argv);

	Test t;
	
	return app.exec();
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
timer1:  1
timer2:  2
timer1:  1
timer3:  3
timer1:  1
timer2:  2
timer1:  1
timer1:  1
timer2:  2
timer3:  3
timer1:  1
timer1:  1
timer2:  2
timer1:  1
^C
```

对于多线程应用程序，你可以使用 [QTimer](http://doc.qt.io/qt-5/qtimer.html) 来创建一个定时器，只要该线程具有事件循环。对于 GUI 应用，调用 `QApplication::exec` 就能使所有线程开始事件循环了，但是**对于非 GUI 应用，你需要调用 [`QThread::exec`](http://doc.qt.io/qt-5/qthread.html#exec) 来使该线程进入事件循环**。

**你并不能在另一个线程开始一个当前线程中的定时器**。

QTimer 演示：

```c++
// Test.h
#pragma once
#include <QDebug>
#include <QTimer>
#include <QObject>

class Test : public QObject
{
	Q_OBJECT

public:
	Test(QObject *parent = 0);

public Q_SLOTS:
	void update();

private:	
	QTimer *timer;
};

inline Test::Test(QObject *parent)
	: QObject(parent)
{
	// 由于对象树特性，当 this 被销毁时，子对象也会被销毁
	// QTimer 的析构函数自动调用 stop()
	timer = new QTimer(this);
	timer->setInterval(1000); // 1s

	QObject::connect(timer, &QTimer::timeout, this, &Test::update);
	timer->start();
}

inline void Test::update()
{
	qDebug() << __func__;
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
update
update
update
update
^C
```

可以看到，由于 QTimer 使用了信号槽机制，可能会更加方便。

<h3 id="object_tree">对象树</h3>

**Qt 使用对象树(object tree)来管理所有的 QObject 类及其子类的对象**，当你创建一个 QObject 对象时，如果使用了其它的 QObject 对象作为父对象(parent)，就像上面的 QTimer 一样，那么这个 QObject 对象就会被添加到父对象的 [`QObject::children()`](http://doc.qt.io/qt-5/qobject.html#children) 列表中，**这样当父对象被销毁时，这个 QObject 对象也会被销毁；你也可以手动销毁该子对象，之后该子对象会将自己从其父对象的对象树中移除**。

不管你的 QObject 对象时创建在堆(heap)上还是栈(stack)上，对象树都能正常工作：

```c++
// Test.h
#pragma once
#include <QDebug>
#include <QObject>

class myObject : public QObject
{
	Q_OBJECT

public:
	myObject(QObject *parent = 0)
		: QObject(parent)
	{
		static int i;
		num = ++i;
	}

	~myObject()
	{
		qDebug() << "delete " << num;
	}

private:
	int num;
};

class Test : public QObject
{
	Q_OBJECT

public:
	Test(QObject *parent = 0)
		: QObject(parent)
	{
		obj[0] = new myObject(this);
		obj[1] = new myObject(this);
		obj[2] = new myObject(this);
	}

private:
	myObject* obj[3];
};
```

```c++
// main.cpp
#include "Test.h"

int main()
{
	// object tree on stack
	Test t;
	qDebug() << t.children();

	// object tree on heap
	Test *pt = new Test();
	qDebug() << pt->children();
	delete pt;
	
	return 0;
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
(myObject(0x3c7858), myObject(0x3c78e0), myObject(0x3c7940))
(myObject(0x3cbc38), myObject(0x3cbc68), myObject(0x3cbc80))
delete  4
delete  5
delete  6
delete  1
delete  2
delete  3
```

可以看到对象树在堆栈上都能很好的工作，但是为了方便，**一般子对象建立在堆上，顶层对象建立在栈上**。

**由于对象树的销毁特性，也可能造成析构函数被多次调用的危险**：

```c++
#include "Test.h"

int main()
{
	myObject obj0, obj1;
	
	obj0.setParent(&obj1);
	
	return 0;
}
```

很显然 obj0 的析构函数被调用了两次：

```text
$ e:\qt_practice>release\qt_practice.exe
delete  2
delete  1
delete  1
QObject: shared QObject was deleted directly. The program is malformed and may crash.
```

<h3 id="qpointer">QPointer</h3>

QPointer 是一个模板，**用来存储一个 QObject 类或其子类的对象的指针**。

**你可以像使用传统指针一样来使用 QPointer，只是当其存储的指针指向的对象被销毁后，该指针会被设为0**。

QPointer 的另一个优点是：**它能自动转换为 `T*`，这意味着你可以直接将其传递给参数为 `T*` 的函数而无需任何操作**。

**QPointer 在销毁时不会对指针指向的对象做任何操作**：

```c++
#include <QPointer>
#include <QSharedPointer>
#include "Test.h"

int main()
{
	QPointer<myObject> obj0 = new myObject();
	QSharedPointer<myObject> obj1(new myObject());
	
	return 0;
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
delete  2
```

QSharedPointer 与 `std::shared_ptr` 类似，在其生命周期结束且没有其它 QSharedPointer 对象引用其指针时，会自动销毁其存储的指针。**介于标准智能指针比较通用，建议一律使用[标准智能指针](https://chorior.github.io/2017/03/08/C++-%E9%87%8A%E7%96%91-%E4%BA%8C/#smart_pointer)**。

**往后凡是普通 QObject 指针，建议使用 QPointer 来存储，这样就不会有使用悬挂指针的危险了**。

<h3 id="the_meta_object_system">元对象系统</h3>

查看 [The Meta-Object System](http://doc.qt.io/qt-5/metaobjects.html)，我们知道所谓元对象系统，就是提供了对象间通信的信号和槽机制、运行时类别信息和动态属性的系统。

一个类要想获得元对象系统的优点，必须满足以下三个条件：

*	必须继承自 QObject，间接的、直接的均可；
*	必须在 private 部分声明 `Q_OBJECT` 宏；
*	必须使用元对象编译器(moc)提供必要的实现元对象特性的代码，其结果一般是一个以 `moc` 开头的 cpp 文件，如 `E:\qt_practice\release\moc_Test.cpp`。

```c++
// main.cpp
#include <QMetaObject>
#include "Test.h"

int main()
{
	myObject myobject;
	QObject *qobject = &myobject;

	qDebug() << "is inherits from QObject: "
		<< myobject.inherits("QObject");              // 是否继承自 QObject

	const QMetaObject *mobj = myobject.metaObject();  // 获取 obj 的元对象
	qDebug() << "class name: " << mobj->className();  // 打印 obj 所属类的类名

	// 动态类型转换，不需要 RTTI 的支持
	// 比 std::dynamic_cast 快
	if (qobject_cast<myObject *>(qobject)) {
		qDebug() << "qobject is a myObject pointer.";
	}

	return 0;
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
is inherits from QObject:  true
class name:  myObject
qobject is a myObject pointer.
delete  1
```

可以看到，转换为 QMetaObject 对象后，就能方便的使用元对象系统的特性了，动态转换也是一个非常不错的工具。

<h2 id="gui_basic">GUI 基础</h2>

<h3 id="qapplication">QApplication</h3>

QApplication 管理 GUI 应用的控制流和主要设置，它继承自 QGUIApplication，实现了一些基于 QWidget 的应用程序所需要的功能。**使用 Qt 的任何 GUI 应用，都需要一个 QApplication 对象，不管该应用有多少个窗口**；**对于非基于 QWidget 的 Qt 应用，可以使用 QGUIApplication 代替**，因为 QGUIApplication 不依赖于 [QtWidget 库](http://doc.qt.io/qt-5/qtwidgets-module.html)。

一些 GUI 应用提供特殊的批处理模式，如根据提供的命令行参数执行相关任务而不能人工干预，在这种非 GUI 模式下，**只需要实例化一个简单的 QCoreApplication 就足够了**，这避免了不必要的图形用户界面所需资源的初始化，官方示例如下：

```c++
QCoreApplication* createApplication(int &argc, char *argv[])
{
	for (int i = 1; i < argc; ++i)
		if (!qstrcmp(argv[i], "-no-gui"))
			return new QCoreApplication(argc, argv);
	return new QApplication(argc, argv);
}

int main(int argc, char* argv[])
{
	QScopedPointer<QCoreApplication> app(createApplication(argc, argv));

	if (qobject_cast<QApplication *>(app.data())) {
		// start GUI version...
	}
	else {
		// start non-GUI version...
	}

	return app->exec();
}
```

QApplication 的主要责任有：

*	使用用户的桌面设置初始化应用；
*	执行事件处理；
*	解析常见的命令行参数，从而设置相应的内部状态；
*	定义应用的外观和感觉；
*	指定应用如何分配颜色；
*	字符串的本地化；
*	提供了一些神奇的实例，如 [`desktop()`](http://doc.qt.io/qt-5/qapplication.html#desktop) 和 [`clipboard()`](http://doc.qt.io/qt-5/qguiapplication.html#clipboard)；
*	掌控所有窗口的部件位置；
*	管理应用的鼠标光标处理；

由于 QApplication 做了这么多初始化，所以**它必须在创建与用户界面相关的任何其他对象之前被创建**。

<h3 id="qwidget">基础窗口部件 QWidget</h3>

QWidget 是所有用户界面对象的基类，其继承自 QObject 和 [QPaintDevice](http://doc.qt.io/qt-5/qpaintdevice.html#details)，QDialog、QMainWindow、QLabel、QPushButton、QListWidget 等都是它的子类。

查看其公有构造函数：

```c++
explicit QWidget(QWidget* parent = Q_NULLPTR, Qt::WindowFlags f = Qt::WindowFlags());
```

当不传入参数或传入的第一个参数为空时，表示该部件是一个窗口，也被称为顶层部件(top-level widget)，顶层部件可以使用成员函数 `setWindowTitle` 来设置标题栏、`setWindowIcon` 来设置窗口图标；当传入的第一个参数不为空时，表示该部件是传入参数的一个子部件，**由于对象树特性，当父部件被删除时，所有该父部件的子部件都将被删除。当你为一个可视部件添加一个子部件时，要想子部件变得可见，你必须显式调用其成员函数 `show()`**。

第二个参数指定部件的各种窗口系统属性，其默认值已适应大多数部件，你可以查看[`Qt::WindowFlags`](http://doc.qt.io/qt-5/qt.html#WindowType-enum)了解各种标志的意义。

查看 QMainWindow 和 QDialog 的公有构造函数：

```c++
QMainWindow::QMainWindow(QWidget *parent, Qt::WindowFlags flags)
    : QWidget(*(new QMainWindowPrivate()), parent, flags | Qt::Window)
{
    d_func()->init();
}

QDialog::QDialog(QWidget *parent, Qt::WindowFlags f)
    : QWidget(*new QDialogPrivate, parent,
              f | ((f & Qt::WindowType_Mask) == 0 ? Qt::Dialog : Qt::WindowType(0)))
{
}
```

由于它们分别指定了 `Qt::Window` 和 `Qt::Dialog` 作为 `Qt::WindowFlags` 的默认值，并且分别在自己的窗口类型的基础上添加了相应的功能，所以 **QMainWindow 和 QDialog 的各种子类是 Qt 中最常用的顶层部件类型**。

QWidget 包含[相当多的功能和属性](http://doc.qt.io/qt-5/qwidget.html#groups-of-functions-and-properties)，其中包含大量的事件处理虚函数，这意味着你可以重新实现它们以完成自定义功能：

```c++
protected:
    // Event handlers
    bool event(QEvent *event) Q_DECL_OVERRIDE;
    virtual void mousePressEvent(QMouseEvent *event);
    virtual void mouseReleaseEvent(QMouseEvent *event);
    virtual void mouseDoubleClickEvent(QMouseEvent *event);
    virtual void mouseMoveEvent(QMouseEvent *event);
#if QT_CONFIG(wheelevent)
    virtual void wheelEvent(QWheelEvent *event);
#endif
    virtual void keyPressEvent(QKeyEvent *event);
    virtual void keyReleaseEvent(QKeyEvent *event);
    virtual void focusInEvent(QFocusEvent *event);
    virtual void focusOutEvent(QFocusEvent *event);
    virtual void enterEvent(QEvent *event);
    virtual void leaveEvent(QEvent *event);
    virtual void paintEvent(QPaintEvent *event);
    virtual void moveEvent(QMoveEvent *event);
    virtual void resizeEvent(QResizeEvent *event);
    virtual void closeEvent(QCloseEvent *event);
#ifndef QT_NO_CONTEXTMENU
    virtual void contextMenuEvent(QContextMenuEvent *event);
#endif
#if QT_CONFIG(tabletevent)
    virtual void tabletEvent(QTabletEvent *event);
#endif
#ifndef QT_NO_ACTION
    virtual void actionEvent(QActionEvent *event);
#endif

#ifndef QT_NO_DRAGANDDROP
    virtual void dragEnterEvent(QDragEnterEvent *event);
    virtual void dragMoveEvent(QDragMoveEvent *event);
    virtual void dragLeaveEvent(QDragLeaveEvent *event);
    virtual void dropEvent(QDropEvent *event);
#endif

    virtual void showEvent(QShowEvent *event);
    virtual void hideEvent(QHideEvent *event);
    virtual bool nativeEvent(const QByteArray &eventType, void *message, long *result);

    // Misc. protected functions
    virtual void changeEvent(QEvent *);
```

<h3 id="qsplashscreen">启动界面 QSplashScreen</h3>

有时候你的 GUI 应用在启动时非常耗时，这时就需要一个启动界面来表示程序正在启动。很多图形界面都会有一个启动界面，比如你最常用的 Windows、Linux、Visual Studio、以及你正在学习的 Qt Creator。

QSplashScreen 提供了启动界面的功能，它实现的启动界面位于屏幕中心：

```c++
#include <QMainWindow>
#include <QApplication>
#include <QSplashScreen>

#include <thread>    // sleep_for

int main(int argc, char *argv[])
{
	QApplication a(argc, argv);

	QPixmap pixmap("welcome.jpg");
	QSplashScreen splash(pixmap);
	splash.show();

	splash.showMessage("Loaded module 1"); // 显示一些字符串信息
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(1000)  // 1s
	);

	splash.showMessage("Loaded module 2");
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(1000)  // 1s
	);

	QMainWindow window;
	window.resize(250, 150);
	window.move(300, 300);
	window.setWindowTitle("QMainWindow");
	window.show();

	splash.finish(&window); // 待 window 显示之后关闭 splash
	return a.exec();
}
```

**如果你想自定义启动界面的话，可以继承 QSplashScreen，然后重新实现 [drawContents 函数](http://doc.qt.io/qt-5/qsplashscreen.html#drawContents)**。

<h3 id="qdialog">对话框 QDialog</h3>

