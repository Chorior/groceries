---
title:      "Qt5 基础篇"
subtitle:   "Hello Qt5"
date:       2017-08-28 20:20:00 +0800
header-img: "img/stock-photo-8.jpg"
tags:
    - C++
    - Qt5
---

本文将根据[官方说明文档](http://doc.qt.io/qt-5/)、一些QT书籍、及一些个人经验来讲解QT的基础知识，鉴于水平有限，可能会有些错误。**但这篇文章的目的主要是我个人使用**。

#   本文结构

*   [Qt 概述](#overview)
*	[Hello QT](#hello_qt)
*	[命令行参数](#qcommandlineparser)
*   [字符串](#qstring_qbytearray)
*	[QVariant](#qvariant)
*	[日期时间](#qdate_qtime_and_qdatetime)
	*	[QDate](#qdate)
	*	[QTime](#qtime)
	*	[QDateTime](#qdatetime)
*	[文件输入输出](#qfile_qdir)

<h2 id="overview">Qt 概述</h2>

Qt 是一个跨平台的应用开发框架，它被广泛用于开发GUI应用，一些著名的软件，如Opera、Google Earth 和 Skype都是基于它进行开发的，你可以用它创建开源应用程序以及商业应用程序。相对于只支持Windows的MFC来说，虽然MFC更为强大，但是MFC的封装不是很好，很多地方很乱很杂(来自网络)，Qt除了跨平台之外，各个组件也封装得非常好，这意味着使用Qt你将更容易的编写程序。

Qt 一般使用C++进行开发，通过语言绑定，也可以使用其它语言。

Qt开放源代码，你可以在[Qt github](https://github.com/qt)上获取；其提供三种授权方式：

*	商业版：可以任意的修改源代码而不必公开，适用于开发专属或商业软件；
*	GNU LGPL：可以被专属软件作为类库引用、发布和销售；
*	GNU GPL：可以自由运行，学习，共享和修改。

<h2 id="hello_qt">Hello QT</h2>

到<http://download.qt.io/official_releases/qt/>下载开源QT，选择 mingw 安装完成后开始我们的第一个程序--Hello QT。

首先，我们创建一个文件夹，例如`E:\qt_practice`，然后创建一个main.cpp:

```c++
#include <QDebug>

int main() 
{
    qDebug() << "Hello QT.";
	return 0;
}
```

然后打开**qt命令行**：

```bash
$ cd E:\qt_practice
$ qmake -project       # 生成QT工程文件
```

这时会生成一个`.pro`文件：

```text
######################################################################
# Automatically generated by qmake (3.0) ?? ?? 28 09:37:58 2017
######################################################################

TEMPLATE = app
TARGET = qt_practice
INCLUDEPATH += .

# Input
SOURCES += main.cpp

```

由于我们需要在命令行上进行输出，所以在`.pro`文件末尾加上 `CONFIG += console`，然后执行：

```bash
$ qmake          # 生成 makefile
$ mingw32-make   # 编译
```

这里默认执行的是 `mingw32-make -f Makefile.Release`，你也可以手动执行 `mingw32-make -f Makefile.Debug`，然后你会在相应文件夹下看到可运行的exe:

```bash
$ e:\qt_practice>release\qt_practice.exe
Hello QT.

```

可以看到，qDebug 默认会输出换行，如果你了解输出缓冲和一些输出调试的知识的话，**这个换行是为了调试方便而加上的**。

<h2 id="qcommandlineparser">命令行参数</h2>

所谓命令行参数，举一个简单的例子 `prog -i file_in -o file_out`，其中 `file_in` 和 `file_out` 就是命令行参数，而 `i` 和 `o` 被称为命令行选项，命令行选项通常用来表示后面命令行参数的类型，这意味着你可以修改命令行参数的顺序，如 `prog -o file_out -i file_in`。

我知道 linux 下面有 `getopt` 函数可以获取命令行参数，但标准 C++ 似乎没有这种函数，所以一般我都是将命令行参数转化为 `std::string`，然后自行解析。你可以查看 [stackoverflow](https://stackoverflow.com/questions/865668/how-to-parse-command-line-arguments-in-c) 获取如何在标准 C++ 中进行命令行参数解析。

QT 提供了 QCommandLineParser 专门用于命令行参数解析。

命令行选项通常以单个破折号或双个破折号开始，**单个字母的命令行选项可以进行合并**，如 `-a -b -c` 可以写成 `-abc`，**但多个字母的命令行选项不能进行合并，且一般以双个破折号开始**。**你可以使用等号或空格符为选项赋值**，如 `-v=value --verbose=value`、`-v value --verbose value`。

我仿照官方示例做了一个演示：

```c++
#include <QDebug>
#include <QCoreApplication>
#include <QCommandLineParser>

void initInputParser(QCommandLineParser &parser);

int main(int argc, char *argv[])
{
	// QCoreApplication 提供命令行参数作为一个简单的字符串列表
	QCoreApplication app(argc, argv);
	QCoreApplication::setApplicationName("my-copy-program");
	QCoreApplication::setApplicationVersion("1.0");

	// QCommandLineParser 初始化，由于其不可复制，故而采用引用方式进行处理
	QCommandLineParser parser;
	initInputParser(parser);

	// 处理用户给出的实际命令行参数
	parser.process(app);

	// 所有基于位置的命令行参数列表，可能包含未定义的命令行参数
	const QStringList args = parser.positionalArguments();

	// 检查命令行选项是否被指定，多个名字的话被认为是相等的
	bool showProgress = parser.isSet("p");
	bool force = parser.isSet("f");
	bool target = parser.isSet("t");
	bool dft = parser.isSet("default");

	// 获取命令行选项对应的值，即命令行参数
	QString targetDir = parser.value("t");
	QString defaultName = parser.value("default-name");

	// 输出
	qDebug() << "-p: " << showProgress;
	qDebug() << "-f: " << force;
	qDebug() << "-t, --target-directory: " << target;
	qDebug() << "-d, --default, --default-name: " << dft;

	qDebug() << "target directory: " << targetDir;
	qDebug() << "default name: " << defaultName;
	
	qDebug() << "positionalArguments: ";
	for (int i = 0; i < args.size(); ++i) {
		qDebug() << " " << args[i];
	}
}

void initInputParser(QCommandLineParser &parser)
{
	parser.setApplicationDescription("Test helper");
	parser.addHelpOption();    // -h, --help and -? on Windows
	parser.addVersionOption(); // -v / --version

	// 添加基于位置的命令行参数，这意味着你不能随意调换它们的相对顺序
	// QCoreApplication::translate: 返回第二个参数翻译后的字符串，这意味着支持多种语言
	parser.addPositionalArgument("source", 
		QCoreApplication::translate("main", "Source file to copy."));
	parser.addPositionalArgument("destination", 
		QCoreApplication::translate("main", "Destination directory."));

	// http://doc.qt.io/qt-5/qcommandlineparser.html#addOptions
	// http://doc.qt.io/qt-5/qcommandlineoption.html
	parser.addOptions({
		// 不带命令行参数的命令行选项(-p)，这意味着你不能为该选项赋值
		// 第二个参数是选项描述，见帮助菜单
		{ "p",
			QCoreApplication::translate("main", "Show progress during copy") },
		// 不带命令行参数的命令行选项(-f, --force)
		// 为一个选项指定多个名字时，列表中任何单个字符的名字都被认为是短名
		// 名字列表不允许为空，名字不能以破折号或斜杠开头、不能包含=、也不能重复
		{ { "f", "force" },
			QCoreApplication::translate("main", "Overwrite existing files.") },
		// 带命令行参数的命令行选项(-t, --target-directory)
		// 第三个参数为命令行参数名，见帮助菜单
		{ { "t", "target-directory" },
			QCoreApplication::translate("main", "Copy all source files into <directory>."),
			QCoreApplication::translate("main", "directory") },
		// 带命令行参数的命令行选项(-d, --default, --default-name)
		// 第四个参数为默认选项值
		{ { "d","default","default-name" },
			QCoreApplication::translate("main", "default name <name>."),
			QCoreApplication::translate("main", "name"),
			QCoreApplication::translate("main", "untitled") }
	});
}
```

编译完成之后，首先查看 help:

```text
$ e:\qt_practice>release\qt_practice.exe -h
Usage: release\qt_practice.exe [options] source destination
Test helper

Options:
  -?, -h, --help                        Displays this help.
  -v, --version                         Displays version information.
  -p                                    Show progress during copy
  -f, --force                           Overwrite existing files.
  -t, --target-directory <directory>    Copy all source files into <directory>.
  -d, --default, --default-name <name>  default name <name>.

Arguments:
  source                                Source file to copy.
  destination                           Destination directory.

```

这样就对上面的代码有了更深的了解了，接下来我们只需要按照 help 显示的那样进行测试即可：

```cmd
$ e:\qt_practice>release\qt_practice.exe -v
my-copy-program 1.0

$ e:\qt_practice>release\qt_practice.exe -pf -t target -d default src dst undef
-p:  true
-f:  true
-t, --target-directory:  true
-d, --default, --default-name:  true
target directory:  "target"
default name:  "default"
positionalArguments:
  "src"
  "dst"
  "undef"

$ e:\qt_practice>release\qt_practice.exe src dst -t=dir undef
-p:  false
-f:  false
-t, --target-directory:  true
-d, --default, --default-name:  false
target directory:  "dir"
default name:  "untitled"
positionalArguments:
  "src"
  "dst"
  "undef"

$ e:\qt_practice>release\qt_practice.exe -a
Unknown option 'a'.

$ e:\qt_practice>release\qt_practice.exe -t
Missing value after '-t'.

$ e:\qt_practice>release\qt_practice.exe -default name
-p:  false
-f:  false
-t, --target-directory:  false
-d, --default, --default-name:  true
target directory:  ""
default name:  "efault"
positionalArguments:
  "name"

$ e:\qt_practice>release\qt_practice.exe --default name
-p:  false
-f:  false
-t, --target-directory:  false
-d, --default, --default-name:  true
target directory:  ""
default name:  "name"
positionalArguments:

```

可以看到，**如果一个选项被设置为需要一个值，则必须存在一个、当不指定有默认值的命令行选项时，就会得到该选项的默认值、使用长字符选项时一定要使用双破折号**。

<h2 id="qstring_qbytearray">字符串</h2>

QT5 默认兼容标准 C++11，但 QT4 需要在 `.pro` 文件中加上 `CONFIG += c++11`，这意味着你不必特意去学习新的类似的库，能用标准 C++ 处理的就用标准 C++ 进行处理，但在 QT 下写程序你却全部使用标准 C++，那使用 QT 的意义又在哪儿呢？由于 QT 所有 API 的参数和返回值除了简单类型之外都是自行封装的，这又意味着**你需要对 QT 的库有一定的了解才行**。

QT 有两个类来存储字符串，它们分别是 QString 和 QByteArray。其中 QString 是 QT 最为常用的字符串，因为它存储了一串 QChar 字符，而一个 QChar 提供了一个16位的 Unicode 字符；而 QByteArray 提供的是一个字节数组，即一个元素是一个字节，以空字符`'\0'`结尾的8位字符串。**除了需要存储原始二进制数据或者对内存保护要求很高的情况下，一般都推荐使用 QString，但使用 QByteArray 比使用 `const char *` 更方便，它确保数据后跟`'\0'`终止符**。

**QString 和 QByteArray 都是采用的[写时复制](http://doc.qt.io/qt-5/implicit-sharing.html)来减少内存使用量和不必要的复制操作**。

下面我们就来对 QString 的常用操作来做一个简单的演示，更多的操作你可以查看[说明文档](http://doc.qt.io/qt-5/qstring.html#details)：

```c++
#include <string>     // 标准字符串

#include <QDebug>
#include <QString>

int main()
{
	std::string std_str = "World";

	// 赋值
	QString str0 = QChar('H');                      // QChar 赋值运算符
	QString str1 = "Hello";                         // const char* 赋值运算符
	QString str2 = QString::fromStdString(std_str); // 标准字符串转 QString 
	qDebug() << str0 << " " << str1 << " " << str2;

	// 访问
	bool isEmpty = str2.isEmpty();                  // 是否为空
	int size = str0.size();                         // 获取字符串大小
	str0[0] = QChar('E');                           // 修改字符
	QChar ch = str1.at(1);                          // at 用于只读
	qDebug() << str0 << " size: " << size;
	qDebug() << str1 << ".at(1): " << ch;
	qDebug() << str2 << " is empty?: " << isEmpty;

	// 修改
	str0.prepend("haha");                           // 前置添加
	str0.push_front("wa");                          // 前置添加
	str1.append(" ");                               // 后置添加
	str1.push_back(str2);                           // 后置添加
	str1 += "!";                                    // 后置添加
	str2.insert(0, "Hello ");                       // 在位置0上插入“Hello "
	QString str3 = str2;                            // str3: Hello World
	str3.replace(6, 5, "QT");                       // 将从位置6开始的5个字符替换为"QT"
	QString str4(str3);                             // str4: Hello QT
	str4.remove(0, 6);                              // 移除从位置0开始的6个字符
	str3.swap(str4);                                // 交换
	qDebug() << str0 << " " << str1 << " "
		<< str2 << " " << str3 << " " << str4;

	// 获取子串
	QString sub0 = str2.right(5);                   // 右边5个字符
	QString sub1 = str2.mid(1, 4);                  // 位置1开始4个字符
	QString sub2 = str2.left(5);                    // 左边5个字符
	qDebug() << sub0 << " " << sub1 << " " << sub2;

	// 比较
	QString str5("_raw.png");
	QString str6("_RAW.png");
	bool equal = (str5 == str6);                    // 比较运算符
	bool startsWith = str5.startsWith("_");         // 是否以"_"开始
	bool endsWith = str5.endsWith(".png");          // 是否以".png"结尾
	bool contains =
		str5.contains("RAW", Qt::CaseInsensitive);  // 是否包含"raw",大小写无关
	qDebug() << equal << " " << startsWith << " "
		<< endsWith << " " << contains;

	// 标记替换
	QString s0 = "file name is %1, function name is %2.";
	QString s1 = s0.arg(__FILE__);                  // 将s1的最小的标记%1替换为文件名
	QString s2 = s1.arg(__func__);                  // 将s2的最小的标记%2替换为函数名
	qDebug() << s0 << "\n" << s1 << "\n" << s2;

	// 转换
	QString str_num0 = QString::number(123);        // 数字转 QString
	QString str_num1 = QString().setNum(1.234);     // 数字转 QString
	std::string std_num = str_num0.toStdString();   // QString 转 std::string
	int num0 = str_num0.toInt();                    // QString 转数字
	double num1 = str_num1.toDouble();              // QString 转数字
	str5 = str5.toUpper();                          // 转换为大写
	str6 = str6.toLower();                          // 转换为小写
	qDebug() << str_num0 << ": " << num0 << ", "
		<< str_num1 << ": " << num1;
	qDebug() << str5 << " " << str6;

	// 字符类型
	QString str7 = "7 white, 3 red roses.";
	int digits = 0, letters = 0;
	int spaces = 0, puncts = 0;
	for (const QChar &s : str7)
	{
		if (s.isDigit()) {
			digits++;
		}
		else if (s.isLetter()) {
			letters++;
		}
		else if (s.isSpace()) {
			spaces++;
		}
		else if (s.isPunct()) {
			puncts++;
		}
	}
	qDebug() << QString("There are %1 characters").arg(str7.count());
	qDebug() << QString("There are %1 letters").arg(letters);
	qDebug() << QString("There are %1 digits").arg(digits);
	qDebug() << QString("There are %1 spaces").arg(spaces);
	qDebug() << QString("There are %1 punctuation characters").arg(puncts);
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
"H"   "Hello"   "World"
"E"  size:  1
"Hello" .at(1):  'e'
"World"  is empty?:  false
"wahahaE"   "Hello World!"   "Hello World"   "QT"   "Hello QT"
"World"   "ello"   "Hello"
false   true   true   true
"file name is %1, function name is %2."
 "file name is main.cpp, function name is %2."
 "file name is main.cpp, function name is main."
"123" :  123 ,  "1.234" :  1.234
"_RAW.PNG"   "_raw.png"
"There are 21 characters"
"There are 13 letters"
"There are 2 digits"
"There are 4 spaces"
"There are 2 punctuation characters"
```

上面打印出来的字符串有引号，如果你觉得不爽的话，可以使用[qPrintable](http://doc.qt.io/qt-5/qtglobal.html#qPrintable)全局函数将 QString 转换为 `const char *`后再进行输出。

<h2 id="qvariant">QVariant</h2>

QVariant 像是一个 QT 常见数据类型的共用体。由于标准 union 只支持有默认构造函数和析构函数的类型，然而许多有用的 QT 类都不满足这一要求，所以有了 QVariant。

**一个 QVariant 对象在同一时间只持有一种数据类型的一个值**，假定该类型为 T，那么你就可以使用成员函数 `toT()` 来获取这个值，你还可以使用成员函数 `canConvert` 来判断该类型是否能够转换到你想要的类型，你甚至可以使用成员函数 `typename()` 来得到该类型的类型字符串。

由于 QVariant 是 Qt Core 模块的一部分，所以没有提供 Qt GUI 定义的数据类型的额转换函数 `toT()`，但是 [QVariant 支持的类型](http://doc.qt.io/qt-5/qvariant-obsolete.html#Type-enum)是包含一些 GUI 定义的类型的，如 QColor、QImage、QPixmap 等，这时你可以使用成员函数 `value` 或者转换函数 `qvariant_cast` 来获取存储的值。**实际上所有的 QVariant 对象都可以使用这样的方式来获取值**。

演示：

```c++
#include <QDebug>
#include <QColor>
#include <QString>
#include <QVariant>

int main()
{
	QVariant v(123);
	bool isInt = v.canConvert<int>();        // 能否转为 int
	bool isString = v.canConvert<QString>(); // 能否转为 QString
	int x = v.toInt();                       // 转换到 int
	QString str = v.toString();              // 转换到 QString
	QString type = v.typeName();             // v 的类型
	qDebug() << "QVariant: " << v;
	qDebug() << "isInt: " << isInt;
	qDebug() << "isString: " << isString;
	qDebug() << "toInt: " << x;
	qDebug() << "toString: " << str;
	qDebug() << "typeName: " << type;

	QColor color = QColor(Qt::red);
	v = color;
	qDebug() << "QVariant: " << v;
	qDebug() << "typeName: " << v.typeName();
	qDebug() << "value: " << v.value<QColor>();
	qDebug() << "value: " << qvariant_cast<QColor>(v);
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
QVariant:  QVariant(int, 123)
isInt:  true
isString:  true
toInt:  123
toString:  "123"
typeName:  "int"
QVariant:  QVariant(QColor, QColor(ARGB 1, 1, 0, 0))
typeName:  QColor
value:  QColor(ARGB 1, 1, 0, 0)
value:  QColor(ARGB 1, 1, 0, 0)
```

<h2 id="qdate_qtime_and_qdatetime">日期时间</h2>

熟悉 C 的兄弟们应该知道 `<time.h>` 是专门用来处理日期时间的，C++ 将该头文件放在命名空间 `std` 下，并重新构建了一个新的头文件 `<ctime>`，你可以使用该头文件来获取日期时间：

```c++
#include <ctime>
#include <string>
#include <iostream>

int main()
{
	time_t t = time(0);   // get time now
	struct tm * now = localtime(&t);

	std::cout << "year: " << now->tm_year + 1900 << "\n"
		<< "month: " << now->tm_mon + 1 << "\n"
		<< "day: " << now->tm_mday << "\n"
		<< "hour: " << now->tm_hour << "\n"
		<< "minute: " << now->tm_min << "\n"
		<< "second: " << now->tm_sec
		<< std::endl;
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
year: 2017
month: 8
day: 31
hour: 15
minute: 8
second: 21
```

在 C++11 中还有头文件 `<chrono>` 中的 `system_clock` 也可以获取当前时间，因为它提供了向 `time_t` 的类型转换函数 `to_time_t`，另外它还支持超**高精度的计时功能**，而使用 `time_t` 你只能获取到精确到秒的计时功能：

```c++
#include <ctime>
#include <thread> // sleep_for
#include <chrono>
#include <iostream>

int main()
{
	//auto now_steady = std::chrono::steady_clock::now();
	auto now_system = std::chrono::system_clock::now();

	time_t now = std::chrono::system_clock::to_time_t(now_system);
	std::cout << ctime(&now) << std::endl;  // unsafe way

	// safe way
	/*char buffer[26];
	ctime_s(buffer, 26, &now);
	std::cout << buffer << std::endl;*/

	// 计时
	// https://chorior.github.io/2017/04/24/C++-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/#clock
	auto time_start = std::chrono::high_resolution_clock::now();
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(100.001));
	auto time_stop = std::chrono::high_resolution_clock::now();
	std::cout << "took "
		<< std::chrono::duration<double, std::milli>(time_stop - time_start).count()
		<< " ms\n";
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
Thu Aug 31 15:22:07 2017

took 100.01 ms
```

**在 Qt 中，如果你想处理日期的话，你可以使用 QDate，如果你想处理时间的话，你可以使用 QTime，如果你想日期、时间一起处理的话，你可以使用 QDateTime**。

<h3 id="qdate">QDate</h3>

```c++
#include <QDate>
#include <QDebug>

int main()
{
	// 访问
	QDate d1 = QDate::currentDate();
	qDebug() << "year: " << d1.year() << "\n"
		<< "month: " << d1.month() << "\n"
		<< "day: " << d1.day() << "\n"
		<< "dayOfWeek: " << d1.dayOfWeek() << "\n"
		<< "dayOfYear: " << d1.dayOfYear() << "\n"
		<< "daysInMonth: " << d1.daysInMonth() << "\n"
		<< "TextDate: " << d1.toString(Qt::TextDate) << "\n"
		<< "ISODate: " << d1.toString(Qt::ISODate) << "\n"
		<< "SystemLocaleShortDate: " << d1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< "SystemLocaleLongDate: " << d1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< "DefaultLocaleShortDate: " << d1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< "DefaultLocaleLongDate: " << d1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< "RFC2822Date: " << d1.toString(Qt::RFC2822Date);

	// 字符串转 QDate
	QString str("2017-08-31");
	d1 = QDate::fromString(str, Qt::ISODate);
	qDebug() << d1.toString(Qt::ISODate);

	// 修改、比较
	d1.setDate(2017, 8, 1);
	qDebug() << d1.daysTo(QDate::currentDate()) << "\n"
		<< d1.addDays(2).toString(Qt::ISODate) << "\n"
		<< d1.addMonths(2).toString(Qt::ISODate) << "\n"
		<< d1.addYears(2).toString(Qt::ISODate) << "\n"
		<< d1.toString(Qt::ISODate) << " > "
		<< QDate::currentDate().toString(Qt::ISODate)
		<< " is " << static_cast<bool>(d1 > QDate::currentDate());
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
year:  2017
month:  8
day:  31
dayOfWeek:  4
dayOfYear:  243
daysInMonth:  31
TextDate:  "周四 八月 31 2017"
ISODate:  "2017-08-31"
SystemLocaleShortDate:  "2017/8/31"
SystemLocaleLongDate:  "2017年8月31日"
DefaultLocaleShortDate:  "2017/8/31"
DefaultLocaleLongDate:  "2017年8月31日"
RFC2822Date:  "31 Aug 2017"
"2017-08-31"
30
"2017-08-03"
"2017-10-01"
"2019-08-01"
"2017-08-01"  >  "2017-08-31"  is  false
```

**除了使用 QT 定义的格式进行输出和输入之外，你还可以自定义日期的格式**：

Expression | Output
------------ | ---------------------------------
yy | 两位数年份(00~99)
yyyy | 四位数年份
M | 不带前置零的月份数(1 ~ 12)
MM | 带有前置零的月份数(01 ~ 12)
MMM | 短的本地化月份名(如 Jan ~ Dec)
MMMM | 长的本地化月份名(如 January ~ December)
d | 不带前置零的天数(1 ~ 31)
dd | 带有前置零的天数(01 ~ 31)
ddd | 短的本地化天名(如 Mon ~ Sun)
dddd | 长的本地化天名(如 Monday ~ Sunday)

```c++
#include <QDate>
#include <QDebug>

int main()
{
	QDate cd = QDate::currentDate();

	qDebug() << "Today is " << cd.toString("yyyy-MM-dd");
	qDebug() << "Today is " << cd.toString("yy/M/dd");
	qDebug() << "Today is " << cd.toString("d. M. yyyy");
	qDebug() << "Today is " << cd.toString("d-MMMM-yyyy");

	QString fmt("yyyy-MM-dd");
	QString str("2017-08-31");
	qDebug() << QDate::fromString(str, fmt).toString("yy/M/dd");
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
Today is  "2017-08-31"
Today is  "17/8/31"
Today is  "31. 8. 2017"
Today is  "31-八月-2017"
"17/8/31"
```

<h3 id="qtime">QTime</h3>

```c++
#include <QTime>
#include <QDebug>

int main()
{
	// 访问
	QTime t1 = QTime::currentTime();
	qDebug() << "hour: " << t1.hour() << "\n"
		<< "minute: " << t1.minute() << "\n"
		<< "second: " << t1.second() << "\n"
		<< "msec: " << t1.msec() << "\n"
		<< "TextDate: " << t1.toString(Qt::TextDate) << "\n"
		<< "ISODate: " << t1.toString(Qt::ISODate) << "\n"
		<< "SystemLocaleShortDate: " << t1.toString(Qt::SystemLocaleShortDate) << "\n"
		<< "SystemLocaleLongDate: " << t1.toString(Qt::SystemLocaleLongDate) << "\n"
		<< "DefaultLocaleShortDate: " << t1.toString(Qt::DefaultLocaleShortDate) << "\n"
		<< "DefaultLocaleLongDate: " << t1.toString(Qt::DefaultLocaleLongDate) << "\n"
		<< "RFC2822Date: " << t1.toString(Qt::RFC2822Date);

	// 字符串转 QTime
	QString str("20:02:20.22");
	QTime t2 = QTime::fromString(str, Qt::ISODate);
	qDebug() << t2.toString(Qt::ISODate);

	// 修改、比较
	t1.setHMS(20, 01, 00, 00);
	qDebug() << t1.secsTo(t2) << "\n"
		<< t1.msecsTo(t2) << "\n"
		<< t1.addSecs(2).toString(Qt::ISODate) << "\n"
		<< t1.addMSecs(1000).toString(Qt::ISODate) << "\n"
		<< t1.toString(Qt::ISODate) << " > " << t2.toString(Qt::ISODate)
		<< " is " << static_cast<bool>(t1 > t2);
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
hour:  16
minute:  27
second:  49
msec:  351
TextDate:  "16:27:49"
ISODate:  "16:27:49"
SystemLocaleShortDate:  "16:27"
SystemLocaleLongDate:  "16:27:49"
DefaultLocaleShortDate:  "16:27"
DefaultLocaleLongDate:  "16:27:49"
RFC2822Date:  "16:27:49"
"20:02:20"
80
80220
"20:01:02"
"20:01:01"
"20:01:00"  >  "20:02:20"  is  false
```

**除了使用 QT 定义的格式进行输出和输入之外，你还可以自定义时间的格式**：

Expression | Output
------------ | ---------------------------------
AP <br> A | AM/PM
ap <br> a | am/pm
t | 时区
h | 0 ~ 23 或 1 ~ 12
hh | 00 ~ 23 或 01 ~ 12
H | 0 ~ 23
HH | 00 ~ 23
m | 0 ~ 59
mm | 00 ~ 59
s | 0 ~ 59
ss | 00 ~ 59
z | 0 ~ 999
zzz | 000 ~ 999

```c++
#include <QTime>
#include <QDebug>

int main()
{
	QTime cd = QTime::currentTime();

	qDebug() << "current time is " << cd.toString("hh:mm:ss.zzz");
	qDebug() << "current time is " << cd.toString("h:m:s a");
	qDebug() << "current time is " << cd.toString("H:m:s A");
	qDebug() << "current time is " << cd.toString("h:m AP");

	QString fmt("hh:mm:ss.zzz");
	QString str("20:20:20.200");
	qDebug() << QTime::fromString(str, fmt).toString("h:m:s a");
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
current time is  "16:32:43.386"
current time is  "4:32:43 下午"
current time is  "16:32:43 下午"
current time is  "4:32 下午"
"8:20:20 下午"
```

我们知道时间的计量就是**计时**，当然你可以自己编写函数进行计时，就像上面的 `system_clock` 一样，相减就可以，但 QT 帮你实现了这个 API：

```c++
void QTime::start()
{
    *this = currentTime();
}

int QTime::restart()
{
    QTime t = currentTime();
    int n = msecsTo(t);
    if (n < 0)                                // passed midnight
        n += 86400*1000;                      // 一天86400秒
    *this = t;
    return n;
}

int QTime::elapsed() const
{
    int n = msecsTo(currentTime());
    if (n < 0)                                // passed midnight
        n += 86400 * 1000;
    return n;
}
```

根据上面的源码，你应该很容易进行理解和测试：

```c++
#include <thread>  // sleep_for
#include <chrono>

#include <QTime>
#include <QDebug>

int main()
{
	QTime t;
	t.start();
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(100));
	
	qDebug() << "took " << t.restart() << " ms";
	std::this_thread::sleep_for(
		std::chrono::duration<double, std::milli>(200));
	qDebug() << "took " << t.elapsed() << " ms";
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
took  100  ms
took  206  ms
```

**可以看到，其精度只到达毫秒，远不如 `chrono` 的精度高**。

<h3 id="qdatetime">QDateTime</h3>

**你可以把 QDateTime 当做 QDate 和 QTime 的并集**，使用时可以使用成员函数`date()`和`time()`来获取对应的 QDate 和 QTime，修改之后再通过成员函数`setDate`和`setTime`将修改合并到原 QDateTime 实例中；剩余比较独立的函数是`toUTC`和`toTime_t`，其中UTC时间是世界标准时间，不随地区、季节的改变而改变，`time_t`是Unix时间。

```c++
#include <QDebug>
#include <QDateTime>

int main()
{
	QDate d = QDate::currentDate();
	QTime t = QTime::currentTime();
	QDateTime dt1(d, t);
	QDateTime dt2 = QDateTime::currentDateTime();
	QDateTime dt3 = QDateTime::currentDateTimeUtc();

	qDebug() << dt1.toString(Qt::ISODate) << "\n"
		<< dt2.toString(Qt::ISODate) << "\n"
		<< dt3.toString(Qt::ISODate) << "\n"
		<< dt2.date().toString(Qt::ISODate) << "\n"
		<< dt2.time().toString(Qt::ISODate) << "\n"
		<< dt1.toUTC().toString(Qt::ISODate) << "\n"
		<< dt2.toTime_t();
}
```

结果：

```text
$ e:\qt_practice>release\qt_practice.exe
"2017-08-31T16:50:22"
"2017-08-31T16:50:22"
"2017-08-31T08:50:22Z"
"2017-08-31"
"16:50:22"
"2017-08-31T08:50:22Z"
1504169422
```

<h2 id="qfile_qdir">文件输入输出</h2>

