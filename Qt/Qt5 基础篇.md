---
title:      "Qt5 基础篇"
subtitle:   "Hello Qt5"
date:       2017-08-28 20:20:00 +0800
header-img: "img/stock-photo-8.jpg"
tags:
    - C++
    - Qt5
---

本文将根据[官方说明文档](http://doc.qt.io/qt-5/)、一些QT书籍、及一些个人经验来讲解QT的基础知识，鉴于水平有限，可能会有些错误。**但这篇文章的目的主要是我个人使用**。

#   本文结构

*   [Qt 概述](#overview)
*	[Hello QT](#hello_qt)
*	[命令行参数](#qcommandlineparser)
*   [字符串](#qstring)

<h2 id="overview">Qt 概述</h2>

Qt 是一个跨平台的应用开发框架，它被广泛用于开发GUI应用，一些著名的软件，如Opera、Google Earth 和 Skype都是基于它进行开发的，你可以用它创建开源应用程序以及商业应用程序。相对于只支持Windows的MFC来说，虽然MFC更为强大，但是MFC的封装不是很好，很多地方很乱很杂(来自网络)，Qt除了跨平台之外，各个组件也封装得非常好，这意味着使用Qt你将更容易的编写程序。

Qt 一般使用C++进行开发，通过语言绑定，也可以使用其它语言。

Qt开放源代码，你可以在[Qt github](https://github.com/qt)上获取；其提供三种授权方式：

*	商业版：可以任意的修改源代码而不必公开，适用于开发专属或商业软件；
*	GNU LGPL：可以被专属软件作为类库引用、发布和销售；
*	GNU GPL：可以自由运行，学习，共享和修改。

<h2 id="hello_qt">Hello QT</h2>

到<http://download.qt.io/official_releases/qt/>下载开源QT，选择 mingw 安装完成后开始我们的第一个程序--Hello QT。

首先，我们创建一个文件夹，例如`E:\qt_practice`，然后创建一个main.cpp:

```c++
#include <QDebug>

int main() 
{
    qDebug() << "Hello QT.";
	return 0;
}
```

然后打开**qt命令行**：

```bash
$ cd E:\qt_practice
$ qmake -project       # 生成QT工程文件
```

这时会生成一个`.pro`文件：

```text
######################################################################
# Automatically generated by qmake (3.0) ?? ?? 28 09:37:58 2017
######################################################################

TEMPLATE = app
TARGET = qt_practice
INCLUDEPATH += .

# Input
SOURCES += main.cpp

```

由于我们需要在命令行上进行输出，所以在`.pro`文件末尾加上 `CONFIG += console`，然后执行：

```bash
$ qmake          # 生成 makefile
$ mingw32-make   # 编译
```

这里默认执行的是 `mingw32-make -f Makefile.Release`，你也可以手动执行 `mingw32-make -f Makefile.Debug`，然后你会在相应文件夹下看到可运行的exe:

```bash
$ e:\qt_practice>release\qt_practice.exe
Hello QT.

```

可以看到，qDebug 默认会输出换行。

<h2 id="qcommandlineparser">命令行参数</h2>

所谓命令行参数，举一个简单的例子 `prog -i file_in -o file_out`，其中 `file_in` 和 `file_out` 就是命令行参数，而 `i` 和 `o` 被称为命令行选项，命令行选项通常用来表示后面命令行参数的类型，这意味着你可以修改命令行参数的顺序，如 `prog -o file_out -i file_in`。

我知道 linux 下面有 `getopt` 函数可以获取命令行参数，但标准 C++ 似乎没有这种函数，所以一般我都是将命令行参数转化为 `std::string`，然后自行解析。你可以查看 [stackoverflow](https://stackoverflow.com/questions/865668/how-to-parse-command-line-arguments-in-c) 获取如何在标准 C++ 中进行命令行参数解析。

QT 提供了 QCommandLineParser 专门用于命令行参数解析。

命令行选项通常以单个破折号或双个破折号开始，**单个字母的命令行选项可以进行合并**，如 `-a -b -c` 可以写成 `-abc`，**但多个字母的命令行选项不能进行合并，且一般以双个破折号开始**。**你可以使用等号或空格符为选项赋值**，如 `-v=value --verbose=value`、`-v value --verbose value`。

我仿照官方示例做了一个演示：

```c++
#include <QDebug>
#include <QCoreApplication>
#include <QCommandLineParser>

void initInputParser(QCommandLineParser &parser);

int main(int argc, char *argv[])
{
	// QCoreApplication 提供命令行参数作为一个简单的字符串列表
	QCoreApplication app(argc, argv);
	QCoreApplication::setApplicationName("my-copy-program");
	QCoreApplication::setApplicationVersion("1.0");

	// QCommandLineParser 初始化，由于其不可复制，故而采用引用方式进行处理
	QCommandLineParser parser;
	initInputParser(parser);

	// 处理用户给出的实际命令行参数
	parser.process(app);

	// 所有基于位置的命令行参数列表，可能包含未定义的命令行参数
	const QStringList args = parser.positionalArguments();

	// 检查命令行选项是否被指定，多个名字的话被认为是相等的
	bool showProgress = parser.isSet("p");
	bool force = parser.isSet("f");
	bool target = parser.isSet("t");
	bool dft = parser.isSet("default");

	// 获取命令行选项对应的值，即命令行参数
	QString targetDir = parser.value("t");
	QString defaultName = parser.value("default-name");

	// 输出
	qDebug() << "-p: " << showProgress;
	qDebug() << "-f: " << force;
	qDebug() << "-t, --target-directory: " << target;
	qDebug() << "-d, --default, --default-name: " << dft;

	qDebug() << "target directory: " << targetDir;
	qDebug() << "default name: " << defaultName;
	
	qDebug() << "positionalArguments: ";
	for (int i = 0; i < args.size(); ++i) {
		qDebug() << " " << args[i];
	}
}

void initInputParser(QCommandLineParser &parser)
{
	parser.setApplicationDescription("Test helper");
	parser.addHelpOption();    // -h, --help and -? on Windows
	parser.addVersionOption(); // -v / --version

	// 添加基于位置的命令行参数，这意味着你不能随意调换它们的相对顺序
	// QCoreApplication::translate: 返回第二个参数翻译后的字符串，这意味着支持多种语言
	parser.addPositionalArgument("source", 
		QCoreApplication::translate("main", "Source file to copy."));
	parser.addPositionalArgument("destination", 
		QCoreApplication::translate("main", "Destination directory."));

	// http://doc.qt.io/qt-5/qcommandlineparser.html#addOptions
	// http://doc.qt.io/qt-5/qcommandlineoption.html
	parser.addOptions({
		// 不带命令行参数的命令行选项(-p)，这意味着你不能为该选项赋值
		// 第二个参数是选项描述，见帮助菜单
		{ "p",
			QCoreApplication::translate("main", "Show progress during copy") },
		// 不带命令行参数的命令行选项(-f, --force)
		// 为一个选项指定多个名字时，列表中任何单个字符的名字都被认为是短名
		// 名字列表不允许为空，名字不能以破折号或斜杠开头、不能包含=、也不能重复
		{ { "f", "force" },
			QCoreApplication::translate("main", "Overwrite existing files.") },
		// 带命令行参数的命令行选项(-t, --target-directory)
		// 第三个参数为命令行参数名，见帮助菜单
		{ { "t", "target-directory" },
			QCoreApplication::translate("main", "Copy all source files into <directory>."),
			QCoreApplication::translate("main", "directory") },
		// 带命令行参数的命令行选项(-d, --default, --default-name)
		// 第四个参数为默认选项值
		{ { "d","default","default-name" },
			QCoreApplication::translate("main", "default name <name>."),
			QCoreApplication::translate("main", "name"),
			QCoreApplication::translate("main", "untitled") }
	});
}
```

编译完成之后，首先查看 help:

```cmd
$ e:\qt_practice>release\qt_practice.exe -h
Usage: release\qt_practice.exe [options] source destination
Test helper

Options:
  -?, -h, --help                        Displays this help.
  -v, --version                         Displays version information.
  -p                                    Show progress during copy
  -f, --force                           Overwrite existing files.
  -t, --target-directory <directory>    Copy all source files into <directory>.
  -d, --default, --default-name <name>  default name <name>.

Arguments:
  source                                Source file to copy.
  destination                           Destination directory.

```

这样就对上面的代码有了更深的了解了，接下来我们只需要按照 help 显示的那样进行测试即可：

```cmd
$ e:\qt_practice>release\qt_practice.exe -v
my-copy-program 1.0

$ e:\qt_practice>release\qt_practice.exe -pf -t target -d default src dst undef
-p:  true
-f:  true
-t, --target-directory:  true
-d, --default, --default-name:  true
target directory:  "target"
default name:  "default"
positionalArguments:
  "src"
  "dst"
  "undef"

$ e:\qt_practice>release\qt_practice.exe src dst -t=dir undef
-p:  false
-f:  false
-t, --target-directory:  true
-d, --default, --default-name:  false
target directory:  "dir"
default name:  "untitled"
positionalArguments:
  "src"
  "dst"
  "undef"

$ e:\qt_practice>release\qt_practice.exe -a
Unknown option 'a'.

$ e:\qt_practice>release\qt_practice.exe -t
Missing value after '-t'.

$ e:\qt_practice>release\qt_practice.exe -default name
-p:  false
-f:  false
-t, --target-directory:  false
-d, --default, --default-name:  true
target directory:  ""
default name:  "efault"
positionalArguments:
  "name"

$ e:\qt_practice>release\qt_practice.exe --default name
-p:  false
-f:  false
-t, --target-directory:  false
-d, --default, --default-name:  true
target directory:  ""
default name:  "name"
positionalArguments:

```

可以看到，**如果一个选项被设置为需要一个值，则必须存在一个、当不指定有默认值的命令行选项时，就会得到该选项的默认值、使用长字符选项时一定要使用双破折号**。

<h2 id="qstring">字符串</h2>
